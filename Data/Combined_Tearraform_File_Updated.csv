,repo_owner,repo_name,path,combined_content,user_query
0,tcnksm,tf-dnsimple-gh-pages,,"# Configure the DNSimple Provider
provider ""dnsimple"" {
  token = ""${var.dnsimple_token}""
  email = ""${var.dnsimple_email}""
}


variable ""dnsimple_token"" {
  description = ""DNSimple API token""
}

variable ""dnsimple_email"" {
  description = ""DNSimple email address""
}

variable ""domain"" {
  description = ""Domain to use""
}

variable ""gh_pages_url"" {
  description = ""GitHub Pages URL""
}



# Add ALIAS record of GitHub page to the domain 
resource ""dnsimple_record"" ""alias-record"" {
  domain = ""${var.domain}""
  name = ""@""
  value = ""${var.gh_pages_url}""
  type = ""ALIAS""
  ttl = 600
}


# Add A record of GitHub page to the domain 
resource ""dnsimple_record"" ""a-record1"" {
  domain = ""${var.domain}""
  name = ""@""
  value = ""192.30.252.153""
  type = ""A""
  ttl = 600
}

# Add A record of GitHub page to the domain 
resource ""dnsimple_record"" ""a-record2"" {
  domain = ""${var.domain}""
  name = ""@""
  value = ""192.30.252.154""
  type = ""A""
  ttl = 600
}



","{
  ""userQuery1"": ""The user needs to configure the DNSimple provider with an API token and an email address. The API token and email address are not hard-coded into the configuration, but are expected to be provided as variables."",
  ""userQuery2"": ""The user intends to manage a specific domain, which is also expected to be provided as a variable. The user also needs to specify a GitHub Pages URL, which is used in the creation of an ALIAS record."",
  ""userQuery3"": ""The user wants to create three DNS records for the specified domain. The first is an ALIAS record that points to the provided GitHub Pages URL. The other two are A records that point to the IP addresses '192.30.252.153' and '192.30.252.154'. All three records have a TTL (time to live) of 600 seconds, meaning they will be cached for that duration before a new request is made to the DNS server"
1,GoogleCloudPlatform,terraform-gce-packetmirror,,"#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#<!--* freshness: { owner: 'ttaggart@google.com' reviewed: '2020-sep-01' } *-->

 
variable ""user_account"" {
   type        = string
   description = ""GCP user account used to complete solution.""
}

variable ""billing_account"" {
   type        = string
   description = ""GCP billing account number."" 
}

variable ""billing_name"" {
   type        = string
   description = ""GCP billing account number.""
   default     = ""My Billing Account""
}

variable ""org_id"" {
   type        = string
   default     = ""0""
   description = ""GCP organization number.""
}

variable ""pid"" {
   type        = string
   description = ""GCP project.""
}

variable ""region"" {
   type        = string
   description = ""GCP region where resources are created.""
}

variable ""zone"" {
   type        = string
   description = ""GCP zone in the var.region where resources are created.""
}


#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#<!--* freshness: { owner: 'ttaggart@google.com' reviewed: '2020-sep-01' } *-->


provider ""google"" {
  version    = ""2.20.1""
  region     = var.region
  zone       = var.zone
  project    = var.pid
}

provider ""google-beta"" {
  version    = ""2.20.1""
  region     = var.region
  zone       = var.zone
  project    = var.pid
}

data ""google_billing_account"" ""acct"" {
  billing_account = var.billing_account
  open            = true
}

resource ""google_project"" ""packetMirror"" {
  name            = ""packetMirror-test""
  project_id      = var.pid
  # If your gcp account is part of a gcp organization
  # uncomment the line below.
  #org_id          = var.org_id
  billing_account = data.google_billing_account.acct.id
}

resource ""google_project_service"" ""compute_api"" {
  project   = google_project.packetMirror.project_id
  service   = ""compute.googleapis.com""
}

resource ""google_project_service"" ""logging_api"" {
  project   = google_project.packetMirror.project_id
  service   = ""logging.googleapis.com""

  disable_dependent_services=true
}

resource ""google_project_service"" ""cloudfunctions_api"" {
  project   = google_project.packetMirror.project_id
  service   = ""cloudfunctions.googleapis.com""

  disable_dependent_services=true
}


#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#<!--* freshness: { owner: 'ttaggart@google.com' reviewed: '2020-sep-01' } *-->

 
resource ""google_compute_network"" ""packetMirror_vpc"" {
  name                    = ""packet-mirror-vpc""
  auto_create_subnetworks = ""false""
  routing_mode            = ""GLOBAL""
  project                 = google_project.packetMirror.project_id

  depends_on = [
    # The project's services must be set up before the
    # network is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]

  timeouts {
    create = ""10m""
    delete = ""10m""
  }
}

resource ""google_compute_subnetwork"" ""webservers"" {
  region        = var.region
  name          = ""webservers""
  ip_cidr_range = ""172.16.20.0/24""
  project       = google_project.packetMirror.project_id
  network       = google_compute_network.packetMirror_vpc.self_link

  timeouts {
    create = ""10m""
    delete = ""10m""
  }
}


resource ""google_compute_subnetwork"" ""collectors"" {
  region        = var.region
  name          = ""collectors""
  ip_cidr_range = ""172.16.21.0/24""
  project       = google_project.packetMirror.project_id
  network       = google_compute_network.packetMirror_vpc.self_link

  timeouts {
    create = ""10m""
    delete = ""10m""
  }
}



#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#<!--* freshness: { owner: 'ttaggart@google.com' reviewed: '2020-sep-01' } *-->
 
resource ""google_compute_router"" ""nat_router"" {
  project = var.pid
  name    = ""nat-router""
  network = google_compute_network.packetMirror_vpc.self_link
  region  = var.region

  depends_on = [
    # The project's services must be set up before the
    # instance is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]

}

resource ""google_compute_router_nat"" ""nat_config"" {
  name                               = ""nat-config""
  router                             = google_compute_router.nat_router.name
  region                             = var.region  
  nat_ip_allocate_option             = ""AUTO_ONLY""
  source_subnetwork_ip_ranges_to_nat = ""ALL_SUBNETWORKS_ALL_IP_RANGES""

  log_config {
    enable = true
    filter = ""ALL""
  }
}


#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#<!--* freshness: { owner: 'ttaggart@google.com' reviewed: '2019-mar-01' } *-->

 
resource ""google_compute_firewall"" ""allow-collector-ingress"" {
  name          = ""allow-collector-ingress""
  network       = google_compute_network.packetMirror_vpc.name
  project       = google_project.packetMirror.project_id
  target_tags   = [""collector""]

  source_ranges = [
    ""0.0.0.0/0"", 
  ]

  allow {
    protocol    = ""tcp""
  }

   allow {
    protocol    = ""udp""
  }

  allow {
    protocol    = ""icmp""
  }
}

resource ""google_compute_firewall"" ""allow-ssh"" {
  name          = ""allow-ssh""
  network       = google_compute_network.packetMirror_vpc.name
  project       = google_project.packetMirror.project_id

  source_ranges = [
    ""35.235.240.0/20"", 
  ]

  allow {
    protocol    = ""tcp""
    ports       = [""22""]
  }
}

resource ""google_compute_firewall"" ""allow-health-check-and-proxy"" {
  name          = ""allow-health-check-and-proxy""
  network       = google_compute_network.packetMirror_vpc.name
  project       = google_project.packetMirror.project_id
  target_tags   = [""webservers""]

  source_ranges = [
    ""35.191.0.0/16"",
    ""130.211.0.0/22"", 
  ]

  allow {
    protocol    = ""tcp""
    ports       = [""80"",""443""]
  }
}


#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#<!--* freshness: { owner: 'ttaggart@google.com' reviewed: '2020-sep-01' } *-->


locals {
  startup = ""${file(""${path.module}/startup.sh"")}""
}

resource ""google_compute_instance_template"" ""webserver"" {
  project       = google_project.packetMirror.project_id
  region        = var.region
  name          = ""webserver-template""
  description   = ""This template is used to create web server instances.""

  tags = [""webservers""]

  machine_type   = ""n1-standard-1""
  can_ip_forward = false

  scheduling {
    automatic_restart   = true
    on_host_maintenance = ""MIGRATE""
  }

  // Create a new boot disk from an image
  disk {
    source_image = ""debian-cloud/debian-9""
    auto_delete  = true
    boot         = true
  }

  // Use an existing disk resource
  disk {
    // Instance Templates reference disks by name, not self link
    source_image = ""debian-cloud/debian-9""
    auto_delete  = true
    boot         = false
  }

  network_interface {
    subnetwork = google_compute_subnetwork.webservers.self_link
  }

  metadata = {
    startup-script = local.startup
  }

  depends_on = [
    # The project's services must be set up before the
    # instance is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]

}

resource ""google_compute_health_check"" ""http_basic"" {
  name                = ""http-basic-check""
  project             = google_project.packetMirror.project_id
  check_interval_sec  = 5
  timeout_sec         = 5
  healthy_threshold   = 2
  unhealthy_threshold = 10

  http_health_check {
    request_path = ""/""
    port         = ""80""
  }

  depends_on = [
    # The project's services must be set up before the
    # instance is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,  
  ]

}

resource ""google_compute_instance_group_manager"" ""webserver"" {
  name               = ""webserver-igm""
  project            = var.pid
  base_instance_name = ""webserver""
  zone               = var.zone

  version {
    instance_template  = google_compute_instance_template.webserver.self_link
  }

  target_size  = 3

  named_port {
    name = ""webservers""
    port = 80
  }

  auto_healing_policies {
    health_check      = google_compute_health_check.http_basic.self_link
    initial_delay_sec = 300
  }

  depends_on = [
    # The project's services must be set up before the
    # instance is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,  
  ]

}

resource ""google_compute_instance"" ""collector"" {
  name                      = ""collector""
  machine_type              = ""n1-standard-1""
  zone                      = var.zone
  project                   = var.pid
  allow_stopping_for_update = ""true""
  can_ip_forward            = ""true""

  depends_on = [
    # The compute api must be set up before
    # the collector is created.
    google_project_service.compute_api,
  ]

  metadata_startup_script = local.startup

  tags         = [
    ""collector"",
  ]

  boot_disk {
    initialize_params {
      image    = ""debian-cloud/debian-9""
    }
  }

  network_interface {
    subnetwork =google_compute_subnetwork.collectors.self_link
  }
}

resource ""google_compute_instance_group"" ""collector-ig"" {
  name = ""collector-ig""
  zone = var.zone

  instances = [
    google_compute_instance.collector.self_link,
  ]

  depends_on = [
    # The project's services must be set up before the
    # instance is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,  
  ]
}


#
# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#<!--* freshness: { owner: 'ttaggart@google.com' reviewed: '2020-sep-01' } *-->


resource ""google_compute_global_address"" ""lb"" {
  name    = ""global-lb-ip""
  project = var.pid

  depends_on = [
    # The project's services must be set up before the
    # resource is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]
}

resource ""google_compute_backend_service"" ""packetMirror"" {
  provider      = google-beta
  project       = var.pid
  name          = ""packet-mirror-backend""
  health_checks = [google_compute_http_health_check.lb.self_link]

  backend {
    balancing_mode  = ""UTILIZATION""
    max_utilization = "".08""
    capacity_scaler = ""1""
    group           = google_compute_instance_group_manager.webserver.instance_group
  }
  
  log_config {
    enable = ""true""
    sample_rate = ""1.0""
  }

  depends_on = [
    # The project's services must be set up before the
    # resource is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]
}

resource ""google_compute_http_health_check"" ""lb"" {
  project            = var.pid
  name               = ""health-check""
  request_path       = ""/""
  check_interval_sec = 1
  timeout_sec        = 1

  depends_on = [
    # The project's services must be set up before the
    # resource is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]
}

resource ""google_compute_url_map"" ""http_lb"" {
  project         = var.pid
  name            = ""http-lb""
  default_service = google_compute_backend_service.packetMirror.self_link

  depends_on = [
    # The project's services must be set up before the
    # resource is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]
}

resource ""google_compute_target_http_proxy"" ""http_ib_proxy"" {
  project = var.pid
  name    = ""http-lb-proxy""
  url_map = google_compute_url_map.http_lb.self_link

  depends_on = [
    # The project's services must be set up before the
    # resource is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]
}

resource ""google_compute_global_forwarding_rule"" ""packetMirror_gfr"" {
  project    = var.pid
  name       = ""packet-mirror-gfr""
  target     = google_compute_target_http_proxy.http_ib_proxy.self_link
  port_range = ""80""
  ip_address = google_compute_global_address.lb.self_link

  depends_on = [
    # The project's services must be set up before the
    # resource is enabled as the compute API will not
    # be enabled and cause the setup to fail.
    google_project_service.compute_api,
  ]
}




","{
  ""userQuery1"": ""The user wants to set up a Google Cloud Platform (GCP) project with specific configurations such as user account, billing account, organization ID, project ID, region, and zone."",
  ""userQuery2"": ""The user intends to create a network infrastructure on GCP, including a VPC network, subnetworks, a NAT router, and firewall rules. The user also wants to set up a health check for HTTP traffic."",
  ""userQuery3"": ""The user plans to deploy compute instances on GCP, including a web server and a collector. The user also wants to create an instance group for the collector and an instance group manager for the web server."",
  ""userQuery4"": ""The user wants to set up a load balancer on GCP, including a global IP address, backend service, URL map, HTTP proxy, and a global forwarding rule."",
  ""userQuery5"": ""The user wants to ensure that certain"
2,immutability-io,terraform-modules,aws/tf_aws_dhcp,"# DHCP Options

## Set Terraform version constraint
terraform {
  required_version = ""> 0.10.0""
}

data ""aws_caller_identity"" ""current"" {}

## Provisions DHCP options
resource ""aws_vpc_dhcp_options"" ""dhcp"" {
  domain_name          = ""${var.domain_name}""
  domain_name_servers  = [""${compact(var.name_servers)}""]
  netbios_name_servers = [""${compact(var.netbios_name_servers)}""]
  netbios_node_type    = ""${var.netbios_node_type}""
  ntp_servers          = [""${compact(var.ntp_servers)}""]

  tags {
    module_version = ""${var.module_version}""
    application = ""${var.stack_item_fullname}""
    account_id = ""${data.aws_caller_identity.current.account_id}""
    caller_arn = ""${data.aws_caller_identity.current.arn}""
    caller_id  = ""${data.aws_caller_identity.current.user_id}""
    terraform  = ""true""
    Name        = ""${var.stack_item_label}-dhcp""
  }
}

resource ""aws_vpc_dhcp_options_association"" ""dns_resolver"" {
  dhcp_options_id = ""${aws_vpc_dhcp_options.dhcp.id}""
  vpc_id          = ""${var.vpc_id}""
}


# Input Variables

## Resource Tags
variable ""stack_item_fullname"" {
  type        = ""string""
  description = ""Long form descriptive name for this stack item. This value is used to create the 'application' resource tag for resources created by this stack item.""
}

variable ""stack_item_label"" {
  type        = ""string""
  description = ""Short form identifier for this stack. This value is used to create the 'Name' resource tag for resources created by this stack item, and also serves as a unique key for re-use.""
}

variable ""module_version"" {
  type        = ""string""
  description = ""Identifies the version of the terraform module used for this stack. This value is used to create the 'module_version' resource tag for resources created by this stack item.""
}

## VPC parameters
variable ""vpc_id"" {
  type        = ""string""
  description = ""The ID of the VPC""
}

## DHCP parameters
variable ""domain_name"" {
  type        = ""string""
  description = ""The suffix domain name to use by default when resolving non Fully Qualified Domain Names""
  default     = """"
}

variable ""name_servers"" {
  type        = ""list""
  description = ""List of name servers to configure in '/etc/resolv.conf'""
  default     = [""AmazonProvidedDNS""]
}

variable ""netbios_name_servers"" {
  type        = ""list""
  description = ""List of NETBIOS name servers""
  default     = []
}

variable ""netbios_node_type"" {
  type        = ""string""
  description = ""The NetBIOS node type (1, 2, 4, or 8). AWS recommends to specify 2 since broadcast and multicast are not supported in their network.""
  default     = """"
}

variable ""ntp_servers"" {
  type        = ""list""
  description = ""List of NTP servers to configure""
  default     = []
}


# Output variables

output ""dhcp_id"" {
  value = ""${aws_vpc_dhcp_options.dhcp.id}""
}


","{
  ""userQuery1"": ""The user needs to provision DHCP options for a specific VPC in AWS. The DHCP options include domain name, domain name servers, NETBIOS name servers, NETBIOS node type, and NTP servers."",
  ""userQuery2"": ""The user wants to tag the created resources with specific information such as the module version, application name, account ID, caller ARN, caller ID, and a custom name. The user also wants to indicate that these resources are managed by Terraform."",
  ""userQuery3"": ""The user wants to associate the created DHCP options with a specific VPC. The ID of the VPC is provided as an input variable."",
  ""userQuery4"": ""The user wants to use a specific version of Terraform, which is greater than 0.10.0, to manage these resources."",
  ""userQuery5"": ""The user wants to output the ID of the created DHCP options for further use"
3,forseti-security,terraform-google-forseti,modules/real_time_enforcer_organization_sink,"/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


terraform {
  required_version = "">= 0.12""
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""pubsub_project_id"" {
  description = ""The project ID containing the Enforcer pubsub topic.""
}

variable ""org_id"" {
  description = ""The organization ID where logs will be exported from.""
}



/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

resource ""random_string"" ""main"" {
  upper   = ""false""
  lower   = ""true""
  special = ""false""
  length  = 4
}

#----------------------------------#
# Real Time Enforcer Pub/Sub topic #
#----------------------------------#

resource ""google_pubsub_topic"" ""main"" {
  name    = ""real-time-enforcer-events-topic-${random_string.main.result}""
  project = var.pubsub_project_id
}

resource ""google_logging_organization_sink"" ""main"" {
  name             = ""real-time-enforcer-log-sink-${random_string.main.result}""
  org_id           = var.org_id
  destination      = ""pubsub.googleapis.com/projects/${var.pubsub_project_id}/topics/${google_pubsub_topic.main.name}""
  include_children = ""true""

  filter = <<EOD
protoPayload.@type=type.googleapis.com/google.cloud.audit.AuditLog
severity != ERROR
protoPayload.serviceName != ""k8s.io""
NOT protoPayload.methodName: ""delete""
EOD

}

resource ""google_pubsub_topic_iam_member"" ""publisher"" {
  topic   = google_pubsub_topic.main.name
  role    = ""roles/pubsub.publisher""
  project = var.pubsub_project_id
  member  = google_logging_organization_sink.main.writer_identity
}



/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""sink_name"" {
  description = ""The organization log sink name.""
  value       = google_logging_organization_sink.main.name
}

output ""topic"" {
  description = ""The pubsub topic receiving exported logs.""
  value       = google_pubsub_topic.main.name
}

output ""writer_identity"" {
  description = ""The identity of the sink writer""
  value       = google_logging_organization_sink.main.writer_identity
}


","{
  ""userQuery1"": ""The user needs to specify the version of Terraform that is required for this configuration. The version specified is 0.12 or higher."",
  ""userQuery2"": ""The user needs to define two variables: 'pubsub_project_id' and 'org_id'. The 'pubsub_project_id' is the ID of the project that contains the Enforcer pubsub topic, and the 'org_id' is the ID of the organization from where the logs will be exported."",
  ""userQuery3"": ""The user intends to create a random string of 4 lowercase letters. This string will be used in the names of the resources that will be created."",
  ""userQuery4"": ""The user wants to create a Google Pub/Sub topic with a name that includes the previously generated random string. This topic will be located in the project specified by the 'pubsub_project_id' variable."",
  ""userQuery5"": ""The user intends to create"
4,cncf,demo,provisioning/gce/modules/vpc,"# resource ""azurerm_network_security_group"" ""cncf"" {
#   name                = ""${ var.name }""
#   location            = ""${ var.location }""
#   resource_group_name = ""${ var.name }""

#   }


resource ""google_compute_subnetwork"" ""cncf"" {
  name          = ""${ var.name }""
  ip_cidr_range = ""${ var.cidr }""
  network       = ""${ google_compute_network.cncf.self_link }""
  region        = ""${ var.region }""
}

/*
# gateway"" ""nat"" {
  depends_on = [
    ""aws_eip.nat"",
    ""aws_internet_gateway.main"",
  ]

  allocation_id = ""${ aws_eip.nat.id }""
  subnet_id = ""${ aws_subnet.public.0.id }""
}

resource ""aws_subnet"" ""private"" {
  count = ""${ length( split("","", var.azs) ) }""

  availability_zone = ""${ element( split("","", var.azs), count.index ) }""
  cidr_block = ""${ cidrsubnet(var.cidr, 8, count.index + 10) }""
  vpc_id = ""${ aws_vpc.cncf.id }""

  tags {
    ""kubernetes.io/role/internal-elb"" = ""${ var.name }""
    builtWith = ""terraform""
    KubernetesCluster = ""${ var.name }""
    kz8s = ""${ var.name }""
    Name = ""kz8s-${ var.name }-private""
    visibility = ""private""
  }
}

resource ""aws_route_table"" ""private"" {
  vpc_id = ""${ aws_vpc.cncf.id }""

  route {
    cidr_block = ""0.0.0.0/0""
    nat_gateway_id = ""${ aws_nat_gateway.nat.id }""
  }

  tags {
    builtWith = ""terraform""
    KubernetesCluster = ""${ var.name }""
    kz8s = ""${ var.name }""
    Name = ""kz8s-${ var.name }""
    visibility = ""private""
  }
}

resource ""aws_route_table_association"" ""private"" {
  count = ""${ length(split("","", var.azs)) }""

  route_table_id = ""${ aws_route_table.private.id }""
  subnet_id = ""${ element(aws_subnet.private.*.id, count.index) }""
}
*/


#variable ""azs"" {}
variable ""cidr"" {}
#variable ""hyperkube-tag"" {}
#variable ""depends-id"" {}
variable ""name"" {}
# variable ""name-servers-file"" {}
# variable ""location"" {}
variable ""region"" {}

#output ""depends-id"" { value = ""${null_resource.dummy_dependency.id}"" }
#output ""gateway-id"" { value = ""${ aws_internet_gateway.cncf.id }"" }
#output ""id"" { value = ""${ aws_vpc.cncf.id }"" }
#output ""route-table-id"" { value = ""${ aws_route_table.private.id }"" }
#output ""subnet-ids-private"" { value = ""${ join("","", aws_subnet.private.*.id) }"" }
#output ""subnet-ids-public"" { value = ""${ join("","", aws_subnet.public.*.id) }"" }
# output ""subnet-id"" { value = ""${ azurerm_subnet.cncf.id }"" }


output ""network"" { value = ""${ google_compute_network.cncf.self_link }"" }
output ""subnetwork"" { value = ""${ google_compute_subnetwork.cncf.self_link }"" }


/*
resource ""aws_eip"" ""nat"" { vpc = true }

resource ""aws_nat_gateway"" ""nat"" {
  depends_on = [
    ""aws_eip.nat"",
    ""aws_internet_gateway.main"",
  ]

  allocation_id = ""${ aws_eip.nat.id }""
  subnet_id = ""${ aws_subnet.public.0.id }""
}

resource ""aws_subnet"" ""private"" {
  count = ""${ length( split("","", var.azs) ) }""

  availability_zone = ""${ element( split("","", var.azs), count.index ) }""
  cidr_block = ""${ cidrsubnet(var.cidr, 8, count.index + 10) }""
  vpc_id = ""${ aws_vpc.cncf.id }""

  tags {
    ""kubernetes.io/role/internal-elb"" = ""${ var.name }""
    builtWith = ""terraform""
    KubernetesCluster = ""${ var.name }""
    kz8s = ""${ var.name }""
    Name = ""kz8s-${ var.name }-private""
    visibility = ""private""
  }
}

resource ""aws_route_table"" ""private"" {
  vpc_id = ""${ aws_vpc.cncf.id }""

  route {
    cidr_block = ""0.0.0.0/0""
    nat_gateway_id = ""${ aws_nat_gateway.nat.id }""
  }

  tags {
    builtWith = ""terraform""
    KubernetesCluster = ""${ var.name }""
    kz8s = ""${ var.name }""
    Name = ""kz8s-${ var.name }""
    visibility = ""private""
  }
}

resource ""aws_route_table_association"" ""private"" {
  count = ""${ length(split("","", var.azs)) }""

  route_table_id = ""${ aws_route_table.private.id }""
  subnet_id = ""${ element(aws_subnet.private.*.id, count.index) }""
}
*/


/*
resource ""aws_internet_gateway"" ""main"" {
  vpc_id = ""${ aws_vpc.cncf.id }""

  tags {
    builtWith = ""terraform""
    KubernetesCluster = ""${ var.name }""
    kz8s = ""${ var.name }""
    Name = ""kz8s-${ var.name }""
    version = ""${ var.hyperkube-tag }""
  }
}

resource ""aws_subnet"" ""public"" {
  count = ""${ length( split("","", var.azs) ) }""

  availability_zone = ""${ element( split("","", var.azs), count.index ) }""
  cidr_block = ""${ cidrsubnet(var.cidr, 8, count.index) }""
  vpc_id = ""${ aws_vpc.cncf.id }""

  tags {
    ""kubernetes.io/role/elb"" = ""${ var.name }""
    builtWith = ""terraform""
    KubernetesCluster = ""${ var.name }""
    kz8s = ""${ var.name }""
    Name = ""kz8s-${ var.name }-public""
    version = ""${ var.hyperkube-tag }""
    visibility = ""public""
  }
}

resource ""aws_route"" ""public"" {
  route_table_id = ""${ aws_vpc.cncf.main_route_table_id }""
  destination_cidr_block = ""0.0.0.0/0""
  gateway_id = ""${ aws_internet_gateway.cncf.id }""
}

resource ""aws_route_table_association"" ""public"" {
  count = ""${ length(split("","", var.azs)) }""

  route_table_id = ""${ aws_vpc.cncf.main_route_table_id }""
  subnet_id = ""${ element(aws_subnet.public.*.id, count.index) }""
}
*/


resource ""google_compute_network"" ""cncf"" {
  name                = ""${ var.name }""
  auto_create_subnetworks = ""false""
}




","{
  ""userQuery1"": ""The user wants to create a Google Compute subnetwork with a specific name, IP CIDR range, network, and region. The name, IP CIDR range, and region are provided as variables."",
  ""userQuery2"": ""The user wants to output the self link of the Google Compute network and subnetwork that are created."",
  ""userQuery3"": ""The user wants to create a Google Compute network with a specific name. The network should not auto create subnetworks. The name is provided as a variable.""
}"
5,terraform-google-modules,docs-examples,ssl_certificate_basic,"resource ""google_compute_ssl_certificate"" ""default"" {
  name_prefix = ""my-certificate-""
  description = ""a description""
  private_key = file(""../static/ssl_cert/test.key"")
  certificate = file(""../static/ssl_cert/test.crt"")

  lifecycle {
    create_before_destroy = true
  }
}


# This file has some scaffolding to make sure that names are unique and that
# a region and zone are selected when you try to create your Terraform resources.

locals {
  name_suffix = ""${random_pet.suffix.id}""
}

resource ""random_pet"" ""suffix"" {
  length = 2
}

provider ""google"" {
  region = ""us-central1""
  zone   = ""us-central1-c""
}


","{
  ""userQuery1"": ""The user needs to create a Google Compute SSL certificate with a unique name that starts with 'my-certificate-'. The certificate and private key files are located in the '../static/ssl_cert/' directory with the names 'test.crt' and 'test.key' respectively. The user also wants to ensure that a new certificate is created before the old one is destroyed."",
  ""userQuery2"": ""The user wants to generate a random pet name with a length of 2 characters. This name will be used as a suffix to ensure the uniqueness of the SSL certificate name."",
  ""userQuery3"": ""The user intends to use the Google Cloud provider for their resources. They have specified 'us-central1' as their region and 'us-central1-c' as their zone.""
}"
6,russmckendrick,terraform-examples,multi,"variable ""pvt_key"" {
	description = ""Path to your private key""
	default = ""~/.ssh/id_rsa""
}

variable ""do_token"" {
	description = ""Your Digital Ocean API token""
	default = """"
}

variable ""do_ssh_fingerprint"" {
	description = ""The fingerprint of your Digital Ocean SSH Key""
	default = """"
}

variable ""server_name"" {
	description = ""What do you want to tag / name your servers as?""
    default = ""server""
}

variable ""azure_settings_file"" {
    default = ""settings.publishsettings""
}

variable ""azure_ssh_key_thumbprint"" {
	description = ""The fingerprint of your Azure SSH Key""
	default = """"
}

variable ""hosted_service"" {
	description = ""Which hosted service would you like to launch your VM in?""
	default = """"
}

variable ""storage_service"" {
	description = ""Which storeage would you like to store your VM in?""
	default = """"
}

variable ""azure_username"" {
	description = ""What username would you like to create on your VM?""
	default = ""azureuser""
}

variable ""aws_access_key"" {
	description = ""Your AWS Access Key""
	default = """"
}

variable ""aws_secret_key"" {
	description = ""Your AWS Secret Key""
	default = """"
}

variable ""aws_subnet_id"" {
	description = ""Which AWS Subnet to launch instance in?""
	default = """"
}

variable ""aws_vpc"" {
	description = ""Which AWS VPC to launch instance in?""
	default = """"
}

variable ""aws_key_name"" {
	description = ""Which Key to launch your instance with?""
	default = """"
}

variable ""aws_hosted_zone_id"" {
	description = ""Which Zone file to add A Record to?""
	default = """"
}

variable ""fqdn"" {
	description = ""What sub-domain to add?""
	default = """"
}

provider ""azure"" {
    settings_file = ""${var.azure_settings_file}""
}

resource ""azure_instance"" ""server"" {
    name = ""russ-terraform-test""
    hosted_service_name = ""${var.hosted_service}""
    image = ""OpenLogic 7.1""
    size = ""Basic_A1""
    storage_service_name = ""${var.storage_service}""
    location = ""West Europe""
    username = ""${var.azure_username}""
    ssh_key_thumbprint = ""${var.azure_ssh_key_thumbprint}""

    endpoint {
        name = ""SSH""
        protocol = ""tcp""
        public_port = 22
        private_port = 22
    }

    endpoint {
        name = ""WEB""
        protocol = ""tcp""
        public_port = 80
        private_port = 80
    }

    connection {
        user = ""${var.azure_username}""
        type = ""ssh""
        key_file = ""${var.pvt_key}""
        timeout = ""2m""
        agent = false
    }

    provisioner ""file"" {
        source = ""script.sh""
        destination = ""/tmp/script.sh""
    }

    provisioner ""remote-exec"" {
        inline = [""bash /tmp/script.sh""]
    }

}

provider ""digitalocean"" {
    token = ""${var.do_token}""
}

resource ""digitalocean_droplet"" ""server"" {
    image = ""centos-7-0-x64""
    name = ""${var.server_name}""
    region = ""nyc2""
    size = ""512mb""
    ssh_keys = [
        ""${var.do_ssh_fingerprint}""
    ]

    connection {
        user = ""root""
        type = ""ssh""
        key_file = ""${var.pvt_key}""
        timeout = ""2m""
        agent = false
    }

    provisioner ""file"" {
        source = ""script.sh""
        destination = ""/tmp/script.sh""
    }

    provisioner ""remote-exec"" {
        inline = [""bash /tmp/script.sh""]
    }

}

provider ""aws"" {
    access_key = ""${var.aws_access_key}""
    secret_key = ""${var.aws_secret_key}""
    region = ""us-east-1""
}

resource ""aws_instance"" ""server"" {

    ami = ""ami-96a818fe""
    instance_type = ""t2.micro""
    subnet_id = ""${var.aws_subnet_id }""
    security_groups = [ ""${aws_security_group.web.id}"", ""${aws_security_group.ssh.id}"", ""${aws_security_group.all_outgoing.id}""]
    key_name = ""${var.aws_key_name}""

    connection {
        user = ""centos""
        type = ""ssh""
        key_file = ""${var.pvt_key}""
        timeout = ""2m""
        agent = false
    }

    provisioner ""file"" {
        source = ""script.sh""
        destination = ""/tmp/script.sh""
    }

    provisioner ""remote-exec"" {
        inline = [""bash /tmp/script.sh""]
    }

    tags {
        Name = ""${var.server_name}""
    }

}

resource ""aws_security_group"" ""web"" {
  name = ""web""
  description = ""Allow all web traffic""
  vpc_id = ""${var.aws_vpc}""

  ingress {
      from_port = 80
      to_port = 80
      protocol = ""tcp""
      cidr_blocks = [""0.0.0.0/0""]
  }

  tags {
    Name = ""web""
  }
}

resource ""aws_security_group"" ""ssh"" {
  name = ""ssh""
  description = ""Allow all ssh traffic""
  vpc_id = ""${var.aws_vpc}""

  ingress {
      from_port = 22
      to_port = 22
      protocol = ""tcp""
      cidr_blocks = [""0.0.0.0/0""]
  }

  tags {
    Name = ""ssh""
  }
}

resource ""aws_security_group"" ""all_outgoing"" {
  name = ""all_outgoing""
  description = ""Allow all outgoing traffic""
  vpc_id = ""${var.aws_vpc}""

  egress {
      from_port = 0
      to_port = 0
      protocol = ""-1""
      cidr_blocks = [""0.0.0.0/0""]
  }

    tags {
    Name = ""all_outgoing""
  }

}

resource ""aws_route53_record"" ""testing"" {
   zone_id = ""${var.aws_hosted_zone_id}""
   name = ""${var.fqdn}""
   type = ""A""
   ttl = ""300""
   records = [ ""${aws_instance.server.public_ip}"", ""${azure_instance.server.vip_address}"", ""${digitalocean_droplet.server.ipv4_address}""]
}

","{
""userQuery1"": ""The user wants to create a server on three different cloud platforms: Azure, DigitalOcean, and AWS. They want to specify the settings for each server, including the server name, the image to use, the size of the server, and the region where the server will be located. They also want to specify the SSH key to use for each server and the path to their private key."",
""userQuery2"": ""The user wants to connect to each server using SSH. They want to specify the username to use for the connection, the type of connection, the key file to use, and the timeout for the connection. They also want to disable the use of an SSH agent."",
""userQuery3"": ""The user wants to run a script on each server after it is created. They want to specify the source and destination of the script. They also want to create security groups on AWS for web, SSH, and all outgoing traffic, specifying the name, description, and"
7,GoogleContainerTools,kpt-functions-catalog,functions/go/export-terraform/testdata/projects/tf,"variable ""billing_account"" {
  description = ""The ID of the billing account to associate projects with""
  type        = string
  default     = ""AAAAAA-AAAAAA-AAAAAA""
}

variable ""org_id"" {
  description = ""The organization id for the associated resources""
  type        = string
  default     = ""123456789012""
}


terraform {
  required_version = "">=0.13""

  required_providers {
    google = {
      source  = ""hashicorp/google""
      version = "">= 4.0.0""
    }
  }
  provider_meta ""google"" {
    module_name = ""blueprints/terraform/exported-krm/v0.1.0""
  }
}


resource ""google_folder"" ""test"" {
  display_name = ""Test Display""
  parent       = ""organizations/${var.org_id}""
}


module ""project-in-external"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 12.0""

  name       = ""project-in-external""
  org_id     = var.org_id
  folder_id  = ""335620346181""

  billing_account = var.billing_account
}

module ""project-in-folder"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 12.0""

  name       = ""project-name""
  project_id = ""project-in-folder""
  org_id     = var.org_id
  folder_id  = google_folder.test.name

  billing_account = var.billing_account
}

module ""project-in-org"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 12.0""

  name       = ""project-in-org""
  org_id     = var.org_id

  billing_account = var.billing_account
}


","{
  ""userQuery1"": ""The user needs to specify a billing account ID to associate with the projects. The default ID is 'AAAAAA-AAAAAA-AAAAAA'."",
  ""userQuery2"": ""The user needs to specify an organization ID for the associated resources. The default ID is '123456789012'."",
  ""userQuery3"": ""The user intends to use a version of Terraform that is 0.13 or higher, and a version of the Google provider that is 4.0.0 or higher."",
  ""userQuery4"": ""The user wants to create a Google folder with the display name 'Test Display' under the specified organization."",
  ""userQuery5"": ""The user intends to create a project named 'project-in-external' in a specific folder within the organization, using the specified billing account."",
  ""userQuery6"": ""The user intends to create a project named 'project-name' with the ID 'project"
8,lucchmielowski,aws-mandelbrot,conf,"# Specify the provider and access details
provider ""aws"" {
  region = ""${var.aws_region}""
}

# Our default security group to access
# the instances over SSH and HTTP
resource ""aws_security_group"" ""default"" {
  name        = ""instance_sg""
  description = ""Used in the terraform""

  # SSH access from anywhere
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }

  # HTTP access from anywhere
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }

  # outbound internet access
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}

# Our elb security group to access
# the ELB over HTTP
resource ""aws_security_group"" ""elb"" {
  name        = ""elb_sg""
  description = ""Used in the terraform""

  # HTTP access from anywhere
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }

  # outbound internet access
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}

resource ""aws_elb"" ""web"" {
  name = ""mandelbrot-elb""

  # Same availability zone as our instances
  availability_zones = [""${split("","", var.availability_zones)}""]
  security_groups    = [""${aws_security_group.elb.id}""]

  listener {
    instance_port     = 80
    instance_protocol = ""http""
    lb_port           = 80
    lb_protocol       = ""http""
  }

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 4
    timeout             = 3
    target              = ""HTTP:80/""
    interval            = 60
  }

  cross_zone_load_balancing   = true
  idle_timeout                = 400
  connection_draining         = true
  connection_draining_timeout = 400
}

resource ""aws_lb_cookie_stickiness_policy"" ""default"" {
  name                     = ""lbpolicy""
  load_balancer            = ""${aws_elb.web.id}""
  lb_port                  = 80
  cookie_expiration_period = 600
}

resource ""aws_autoscaling_group"" ""web-asg"" {
  availability_zones = [""${split("","", var.availability_zones)}""]
  name = ""mandelbrot-asg""
  max_size              = ""${var.asg_max}""
  min_size              = ""${var.asg_min}""
  desired_capacity      = ""${var.asg_desired}""
  force_delete          = true
  launch_configuration  = ""${aws_launch_configuration.web-lc.name}""
  load_balancers        = [""${aws_elb.web.name}""]

  tag {
    key                 = ""Name""
    value               = ""web-asg""
    propagate_at_launch = ""true""
  }
}

resource ""aws_launch_configuration"" ""web-lc"" {
  name          = ""mandelbrot-lc""
  image_id      = ""${lookup(var.aws_amis, var.aws_region)}""
  instance_type = ""${var.instance_type}""
  iam_instance_profile = ""${aws_iam_instance_profile.deploy_instance_profile.name}""
  # Security group
  security_groups = [""${aws_security_group.default.id}""]
  user_data       = ""${file(""userdata2.sh"")}""
  key_name        = ""${var.key_name}""
}

resource ""aws_autoscaling_policy"" ""scale-up"" {
  name = ""mandelbrot-scale-up""
  scaling_adjustment = 50
  adjustment_type = ""PercentChangeInCapacity""
  cooldown = 300
  autoscaling_group_name = ""${aws_autoscaling_group.web-asg.name}""
}

resource ""aws_autoscaling_policy"" ""scale-down"" {
    name = ""mandelbrot-scale-down""
    scaling_adjustment = -1
    adjustment_type = ""ChangeInCapacity""
    cooldown = 300
    autoscaling_group_name = ""${aws_autoscaling_group.web-asg.name}""
}

resource ""aws_cloudwatch_metric_alarm"" ""highcpualarm"" {
    alarm_name = ""mandelbrot-highcpualarm""
    comparison_operator = ""GreaterThanThreshold""
    evaluation_periods = ""2""
    metric_name = ""CPUUtilization""
    namespace = ""AWS/EC2""
    period = ""60""
    statistic = ""Average""
    threshold = ""70""
    dimensions {
        AutoScalingGroupName = ""${aws_autoscaling_group.web-asg.name}""
    }
    alarm_description = ""This metric monitor ec2 cpu utilization""
    alarm_actions = [""${aws_autoscaling_policy.scale-up.arn}""]
}

resource ""aws_cloudwatch_metric_alarm"" ""lowcpualarm"" {
  alarm_name = ""mandelbrot-lowcpualarm""
  comparison_operator = ""LessThanThreshold""
  evaluation_periods = ""2""
  metric_name = ""CPUUtilization""
  namespace = ""AWS/EC2""
  period = ""60""
  statistic = ""Average""
  threshold = ""36""
  dimensions {
      AutoScalingGroupName = ""${aws_autoscaling_group.web-asg.name}""
  }
  alarm_description = ""This metric monitor ec2 cpu utilization""
  alarm_actions = [""${aws_autoscaling_policy.scale-down.arn}""]
}

resource ""aws_cloudwatch_metric_alarm"" ""highlatency"" {
  alarm_name = ""mandelbrot-highlatencyalarm""
  comparison_operator = ""GreaterThanThreshold""
  evaluation_periods = ""1""
  metric_name = ""Latency""
  namespace = ""AWS/ELB""
  period = ""60""
  statistic = ""Average""
  threshold = ""3""
  dimensions {
      LoadBalancerName = ""${aws_elb.web.name}""
  }
  alarm_description = ""This metric monitor ec2 cpu utilization""
  alarm_actions = [""${aws_autoscaling_policy.scale-up.arn}""]
}

resource ""aws_codedeploy_app"" ""aws-mandelbrot"" {
  name = ""aws_mandelbrot""
}

resource ""aws_iam_role_policy"" ""deploy_policy"" {
    name = ""deploy_policy""
    role = ""${aws_iam_role.deploy_role.id}""
    policy = <<EOF
{
    ""Version"": ""2012-10-17"",
    ""Statement"": [
        {
            ""Effect"": ""Allow"",
            ""Action"": [
                ""autoscaling:CompleteLifecycleAction"",
                ""autoscaling:DeleteLifecycleHook"",
                ""autoscaling:DescribeAutoScalingGroups"",
                ""autoscaling:DescribeLifecycleHooks"",
                ""autoscaling:PutLifecycleHook"",
                ""autoscaling:RecordLifecycleActionHeartbeat"",
                ""ec2:DescribeInstances"",
                ""ec2:DescribeInstanceStatus"",
                ""s3:Get*"",
                ""s3:List*"",
                ""tag:GetTags"",
                ""tag:GetResources""
            ],
            ""Resource"": ""*""
        }
    ]
}
EOF
}

resource ""aws_iam_instance_profile"" ""deploy_instance_profile"" {
    name = ""deploy_instance_profile""
    roles = [""${aws_iam_role.deploy_role.name}""]
}

resource ""aws_iam_role"" ""deploy_role"" {
    name = ""deploy_role""
    assume_role_policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Statement"": [
    {
      ""Sid"": """",
      ""Effect"": ""Allow"",
      ""Principal"": {
        ""Service"": [
          ""codedeploy.amazonaws.com"",
          ""codedeploy.eu-west-1.amazonaws.com"",
          ""ec2.amazonaws.com""
        ]
      },
      ""Action"": ""sts:AssumeRole""
    }
  ]
}
EOF
}

resource ""aws_codedeploy_deployment_group"" ""mandelbrot"" {
    app_name = ""${aws_codedeploy_app.aws-mandelbrot.name}""
    deployment_group_name = ""mandelbrot""
    service_role_arn = ""${aws_iam_role.deploy_role.arn}""
    autoscaling_groups = [""${aws_autoscaling_group.web-asg.id}""]
}

resource ""aws_s3_bucket"" ""codedeploy"" {
    bucket = ""mandelbrot-codedeploy""
    acl = ""private""
    force_destroy = true

    tags {
        Name = ""codedeploy""
        Environment = ""Dev""
    }
}


variable ""key_name"" {
  description = ""Name of the SSH keypair to use in AWS.""
}

variable ""aws_region"" {
  description = ""AWS region to deploy to launch servers""
  default = ""eu-west-1""
}

variable ""aws_amis"" {
  default = {
    ""eu-west-1"" = ""ami-07174474""
    ""eu-central-1"" = ""ami-82cf0aed""
  }
}

variable ""availability_zones"" {
  default     = ""eu-west-1b,eu-west-1c,eu-west-1a""
  description = ""List of availability zones, use AWS CLI to find your ""
}

variable ""instance_type"" {
  default     = ""t2.micro""
  description = ""AWS instance type""
}

variable ""asg_min"" {
  description = ""Min numbers of servers in ASG""
  default     = ""1""
}

variable ""asg_max"" {
  description = ""Max numbers of servers in ASG""
  default     = ""4""
}

variable ""asg_desired"" {
  description = ""Desired numbers of servers in ASG""
  default     = ""1""
}


output ""elb-address"" {
  value = ""${aws_elb.web.dns_name}""
}


","{
  ""userQuery1"": ""The user wants to set up an AWS environment in a specific region, which can be accessed using a specific SSH keypair."",
  ""userQuery2"": ""The user intends to create two security groups, one for instances and another for an Elastic Load Balancer (ELB). Both security groups should allow inbound traffic for SSH and HTTP from any IP address, and allow all outbound traffic."",
  ""userQuery3"": ""The user wants to create an ELB in the same availability zones as the instances, with a specific health check configuration and connection settings. The ELB should use the previously created security group."",
  ""userQuery4"": ""The user intends to set up an Auto Scaling Group (ASG) that scales based on specific conditions. The ASG should use a specific launch configuration and be associated with the ELB."",
  ""userQuery5"": ""The user wants to create a launch configuration with a specific AMI, instance type,"
9,blalor,blalor.github.io,terraform/modules/functions/thumbor,"terraform {
    required_version = "">= 0.13""

    required_providers {
        aws = {
            source = ""hashicorp/aws""
        }
    }
}


variable ""bucket"" {
    type = string
    description = ""bucket where deployment package and images are stored""
}

variable ""bucket_region"" {
    type = string
    description = ""the region where the bucket resides""
}

variable ""container_image_uri"" {
    type = string
    description = ""ECR container image URI""
}

variable ""photos_prefix"" {
    type = string
    description = ""prefix in bucket where images are stored""
}

variable ""api_gateway_exec_arn"" {
    type = string
    description = ""full execution arn for the api gateway""
}

locals {
    fn_name = ""thumbor""
}


data ""aws_iam_policy_document"" ""assume"" {
    statement {
        actions = [""sts:AssumeRole""]

        principals {
            type = ""Service""
            identifiers = [""lambda.amazonaws.com""]
        }
    }
}

data ""aws_iam_policy_document"" ""exec"" {
    statement {
        sid = ""getdemphotos""

        actions = [
            ""s3:GetObject"",
        ]

        resources = [
            ""arn:aws:s3:::${var.bucket}/${var.photos_prefix}/*"",
        ]
    }

    ## allow logging
    statement {
        sid = ""loggit""

        actions = [
            ""logs:PutLogEvents"",
            ""logs:CreateLogGroup"",
            ""logs:CreateLogStream"",
        ]

        resources = [""*""]
    }
}

resource ""aws_iam_role"" ""lambda"" {
    path = ""/service-role/""
    name = ""LambdaThumbor""
    description = ""Permissions for the ${local.fn_name} function""
    assume_role_policy = data.aws_iam_policy_document.assume.json
}

resource ""aws_iam_role_policy"" ""lambda"" {
    name = aws_iam_role.lambda.name
    role = aws_iam_role.lambda.id
    policy = data.aws_iam_policy_document.exec.json
}


resource ""aws_lambda_function"" ""fn"" {
    function_name = local.fn_name

    role = aws_iam_role.lambda.arn

    package_type = ""Image""
    image_uri = var.container_image_uri

    memory_size = 1536
    timeout = 10

    environment {
        variables = {
            ENABLE_CORS = ""no""
            LOG_LEVEL = ""INFO""

            SEND_ANONYMOUS_DATA = ""Hell no""

            RESPECT_ORIENTATION = ""True""

            TC_AWS_ENDPOINT = ""https://s3.amazonaws.com""
            TC_AWS_REGION = var.bucket_region
            TC_AWS_LOADER_BUCKET = var.bucket
            TC_AWS_LOADER_ROOT_PATH = var.photos_prefix
        }
    }
}

resource ""aws_lambda_permission"" ""api_gateway"" {
    statement_id = ""AllowAPIGatewayInvoke""
    action = ""lambda:InvokeFunction""
    function_name = aws_lambda_function.fn.function_name
    principal = ""apigateway.amazonaws.com""

    source_arn = var.api_gateway_exec_arn
}


output ""invoke_arn"" {
    value = aws_lambda_function.fn.invoke_arn
}


","{
    ""userQuery1"": ""The user needs to create an AWS Lambda function named 'thumbor'. This function should be packaged as a container image, with the image URI provided by the user. The function should have a memory size of 1536 MB and a timeout of 10 seconds. The function's environment variables should be set as specified in the code. The function should be able to be invoked by an API Gateway, with the execution ARN provided by the user."",
    ""userQuery2"": ""The user needs to create an IAM role named 'LambdaThumbor' for the Lambda function. This role should have permissions to assume the 'lambda.amazonaws.com' service. The role should also have a policy that allows it to perform 's3:GetObject' actions on a specific S3 bucket and prefix, both provided by the user, and 'logs:PutLogEvents', 'logs:CreateLogGroup', and 'logs:CreateLogStream' actions on all resources"
10,GoogleCloudPlatform,pci-anthos-blueprint,google-cloud/admin,"module ""admin-bucket"" {
  source     = ""terraform-google-modules/cloud-storage/google""
  version    = ""~> 1.7""
  project_id = module.admin-project.project_id
  names      = [local.admin_bucket]
  prefix     = var.project_prefix
   force_destroy = {
    (local.admin_bucket) = true
  }
  versioning = {
    (local.admin_bucket) = true
  }
}

# Add a list of roles to the cloud build service account in the admin project
resource ""google_folder_iam_binding"" ""infrastructure-folder"" {
  folder   = module.infrastructure-folder.id
  for_each = toset(local.infrastructure_folder_roles)
  role     = ""roles/${each.key}""
  members = [
    ""serviceAccount:${module.admin-project.project_number}@cloudbuild.gserviceaccount.com"",
  ]
}

# Set billing.user for the service account on the billing account
resource ""google_billing_account_iam_binding"" ""binding"" {
  billing_account_id = var.billing_account
  role               = ""roles/billing.user""
  members = [
    ""serviceAccount:${module.admin-project.project_number}@cloudbuild.gserviceaccount.com"",
  ]
}



module ""parent-folder"" {
  source = ""github.com/terraform-google-modules/terraform-google-folders?ref=00f2aac""
  parent = local.admin_parent
  names  = [local.admin_folder_name]
}

module ""admin-project"" {
  source                  = ""github.com/terraform-google-modules/terraform-google-project-factory?ref=v9.2.0""
  random_project_id       = true
  name                    = local.admin_project_name
  folder_id               = module.parent-folder.id
  org_id                  = var.organization_id
  billing_account         = var.billing_account
  default_service_account = ""keep""
  activate_apis           = local.admin_project_activate_apis
}

module ""infrastructure-folder"" {
  source = ""github.com/terraform-google-modules/terraform-google-folders?ref=00f2aac""
  parent = module.parent-folder.id
  names  = [local.infrastructure_folder_name]
}


variable ""project_prefix"" {
  description = ""Segment to prefix all project names with.""
  default     = """"
}
variable ""billing_account"" {
  description = ""The ID of the associated billing account""
  default     = """"
}
variable ""organization_id"" {
  description = ""The Ggoogle Cloud Organization ID""
  default     = """"
}
variable ""region"" {
  description = ""The Google Cloud region to use""
}

variable ""parent_folder_id"" {
  description = ""Optional Google Cloud parent folder ID to use""
}

locals {
  admin_parent       = var.parent_folder_id != """" ? ""folders/${var.parent_folder_id}"" : ""organizations/${var.organization_id}""
  admin_folder_name  = ""${var.project_prefix}-anthos""
  admin_project_name = ""${var.project_prefix}-admin""
  admin_project_activate_apis = [
    ""cloudbuild.googleapis.com"",
    ""cloudresourcemanager.googleapis.com"",
    ""secretmanager.googleapis.com"",
    ""iam.googleapis.com"",
    ""cloudbilling.googleapis.com"",
    ""container.googleapis.com"",
    ""serviceusage.googleapis.com""
  ]
  admin_bucket               = ""admin""
  infrastructure_folder_name = ""infrastructure""
  infrastructure_folder_roles = [
    ""resourcemanager.projectCreator"",
    ""billing.projectManager"",
    ""compute.xpnAdmin"",
    ""compute.admin"",
    ""container.admin"",
    ""iam.serviceAccountKeyAdmin""
  ]
}


# These outputs are consumed by the cloud-build/ root module
output ""admin_project_id"" {
  value = module.admin-project.project_id
}
output ""admin_project_number"" {
  value = module.admin-project.project_number
}
output ""infrastructure_folder_id"" {
  value = module.infrastructure-folder.id
}
output ""cloud-build-service-account"" {
  value = ""serviceAccount:${module.admin-project.project_number}@cloudbuild.gserviceaccount.com""
}
output ""admin-bucket-name"" {
  value = module.admin-bucket.bucket.name
}

","{
  ""userQuery1"": ""The user needs to create a Google Cloud Storage bucket with a specific name, versioning enabled, and the ability to force destroy it. The bucket is associated with a specific project."",
  ""userQuery2"": ""The user intends to add a list of roles to the Cloud Build service account in the admin project. These roles are associated with a specific folder in the Google Cloud infrastructure."",
  ""userQuery3"": ""The user wants to set the 'billing.user' role for the service account on the billing account. This is associated with a specific project."",
  ""userQuery4"": ""The user needs to create a parent folder and an admin project within the Google Cloud infrastructure. The admin project has a specific set of APIs activated."",
  ""userQuery5"": ""The user intends to create an infrastructure folder within the parent folder in the Google Cloud infrastructure."",
  ""userQuery6"": ""The user needs to define a set of variables, including the"
11,dcloud9,terraform-buildme,aws/vpc/vpc-demo1/group/db/role/mysql,"variable ""associate_public_ip_address"" {
  description = ""(Optional) Associate a public ip address with an instance in a VPC. Boolean value.""
  default     = false
}

variable ""availability_zone"" {
  description = ""(Optional) The AZ to start the instance in.""
  default     = """"
}

variable ""disable_api_termination"" {
  description = ""(Optional) If true, enables EC2 Instance Termination Protection""
  default     = false
}

variable ""ebs_optimized"" {
  description = ""(Optional) If true, the launched EC2 instance will be EBS-optimized.""
  default     = true
}

variable ""iam_instance_profile"" {
  description = ""(Optional) The IAM Instance Profile to launch the instance with.""
  default     = """"
}

variable ""instance_initiated_shutdown_behavior"" {
  description = ""(Optional) Shutdown behavior for the instance. Amazon defaults this to stop for EBS-backed instances and terminate for instance-store instances. Cannot be set on instance-store instances. See Shutdown Behavior for more information.""
  default     = ""stop""
}

variable ""monitoring"" {
  description = ""(Optional) If true, the launched EC2 instance will have detailed monitoring enabled. (Available since v0.6.0)""
  default     = true
}

variable ""placement_group"" {
  description = ""(Optional) The Placement Group to start the instance in.""
  default     = """"
}

variable ""private_ip"" {
  description = ""(Optional) Private IP address to associate with the instance in a VPC.""
  default     = """"
}

variable ""source_dest_check"" {
  description = ""(Optional) Controls if traffic is routed to the instance when the destination address does not match the instance. Used for NAT or VPNs. Defaults true.""
  default     = true
}

variable ""tenancy"" {
  description = ""(Optional) The tenancy of the instance (if the instance is running in a VPC). An instance with a tenancy of dedicated runs on single-tenant hardware. The host tenancy is not supported for the import-instance command.""
  default     = """"
}

variable ""user_data"" {
  description = ""(Optional) The user data to provide when launching the instance.""
  default     = """"
}

variable ""userdata_extra_script"" {
  description = ""(Optional) Additional bootstrap script.""
  default     = ""# Extra Script""
}

# Root Block Device
variable ""root_delete_on_termination"" {
  description = ""(Optional) Whether the volume should be destroyed on instance termination (Default: true).""
  default     = true
}

variable ""root_iops"" {
  description = ""(Optional) The amount of provisioned IOPS. This must be set with a volume_type of io1.""
  default     = """"
}

variable ""root_volume_type"" {
  description = ""(Optional) The type of volume. Can be standard, gp2, or io1. (Default: gp2).""
  default     = ""gp2""
}

variable ""root_volume_size"" {
  description = ""(Optional) The size of the volume in gigabytes.""
  default     = """"
}

# Tags
variable ""owner"" {
  description = ""(Optional) The owner responsible for managing the resource - used for tagging.""
  default     = ""Terraform""
}

variable ""tags"" {
  description = ""(Optional) A map of additional tags to associate with the resource.""
  type        = ""map""
  default     = {}
}


# Required vars
variable ""s3tfstate"" {
  description = ""(Required) The S3 bucket name to store tfstate files""
}

variable ""ami"" {
  description = ""(Required) The AMI to use for the instance.""
}

variable ""instance_type"" {
  description = ""(Required) The type of instance to start""
}

variable ""hostname"" {
  description = ""(Required) Hostname of instance""
  type        = ""list""
}

variable ""domainname"" {
  description = ""(Optional) Domain Name. e.g mydomain.io""
  default     = ""localdomain""
}

variable ""use_eip"" {
  description = ""(Required) Use or do not use EIP""
  default     = ""no""
}

# Tags
variable ""built_by"" {
  description = ""(Required) The id of the person - used for tagging. e.g. jbloggs or jbloggs@email.com""
}

variable ""environment"" {
  description = ""(Required) The name of the environment that the resource belongs to - used for tagging.""
}

variable ""environment_vpc"" {
  description = ""(Required) The name of the VPC that the resource belongs to - used for tagging.""
}

variable ""environment_group"" {
  description = ""(Required) The name of the Group within VPC that the resource belongs to - used for tagging.""
}

variable ""environment_role"" {
  description = ""(Required) The Role of the EC2 instance within VPC - used for tagging.""
}

variable ""region"" {
  description = ""(Required) The region that the resource belongs to - used for tagging.""
}


# Store remote state file to S3. Use 'terraform env/workspace' to decouple state files per env.
terraform {
  backend ""s3"" {
    encrypt = true
  }
}

data ""terraform_remote_state"" ""vpc"" {
  backend = ""s3""

  config {
    region  = ""${var.region}""
    bucket  = ""${var.s3tfstate}""
    key     = ""aws/vpc/vpc-${var.environment_vpc}/terraform.tfstate""
    encrypt = true
  }
}

data ""terraform_remote_state"" ""network"" {
  backend = ""s3""

  config {
    region  = ""${var.region}""
    bucket  = ""${var.s3tfstate}""
    key     = ""aws/vpc/vpc-${var.environment_vpc}/network/terraform.tfstate""
    encrypt = true
  }
}

data ""terraform_remote_state"" ""group"" {
  backend = ""s3""

  config {
    region  = ""${var.region}""
    bucket  = ""${var.s3tfstate}""
    key     = ""aws/vpc/vpc-${var.environment_vpc}/group/${var.environment_group}/terraform.tfstate""
    encrypt = true
  }
}

data ""terraform_remote_state"" ""group_app"" {
  backend = ""s3""

  config {
    region  = ""${var.region}""
    bucket  = ""${var.s3tfstate}""
    key     = ""aws/vpc/vpc-${var.environment_vpc}/group/app/terraform.tfstate""
    encrypt = true
  }
}

data ""terraform_remote_state"" ""role_bastion"" {
  backend = ""s3""

  config {
    region  = ""${var.region}""
    bucket  = ""${var.s3tfstate}""
    key     = ""aws/vpc/vpc-${var.environment_vpc}/group/dmz/role/bastion/terraform.tfstate""
    encrypt = true
  }
}


resource ""aws_iam_instance_profile"" ""iamprofile"" {
  name = ""iamprofile-${var.environment_role}-${var.environment}-${var.environment_vpc}-${var.region}""
  role = ""${aws_iam_role.iamrole.name}""
}

resource ""aws_iam_role"" ""iamrole"" {
  name = ""iamrole-${var.environment_role}-${var.environment}-${var.environment_vpc}-${var.region}""
  path = ""/""

  assume_role_policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Statement"": [
    {
      ""Action"": ""sts:AssumeRole"",
      ""Principal"": { ""Service"": ""ec2.amazonaws.com"" },
      ""Effect"": ""Allow"",
      ""Sid"": """"
    }
  ]
}
EOF
}


# Deny instances to read tfstate files stored in S3
data ""aws_iam_policy_document"" ""s3_read"" {
  statement {
    effect = ""Allow""

    actions = [
      ""s3:List*"",
      ""s3:Get*"",
    ]

    resources = [
      ""arn:aws:s3:::*"",
    ]
  }

  statement {
    effect  = ""Deny""
    actions = [""s3:*""]

    resources = [
      ""arn:aws:s3:::${replace(var.s3tfstate, var.region, ""*"")}"",
    ]
  }
}

resource ""aws_iam_policy"" ""s3_read"" {
  description = ""${var.environment_role} S3 ReadOnly Policy""
  name        = ""iampolicy-${var.environment_role}-s3-read-${var.region}""
  policy      = ""${data.aws_iam_policy_document.s3_read.json}""
}

resource ""aws_iam_role_policy_attachment"" ""iamrole_attach"" {
  role       = ""${aws_iam_role.iamrole.name}""
  policy_arn = ""${aws_iam_policy.s3_read.arn}""
}


resource ""aws_security_group"" ""sg"" {
  description = ""${var.environment_role} Role Security Group""
  name        = ""sgrp-${var.environment_role}-${var.environment}-${var.environment_vpc}-${var.environment_group}""
  vpc_id      = ""${data.terraform_remote_state.vpc.vpc_id}""

  tags = ""${merge(map(
    ""BuiltBy"", ""${var.built_by}"",
    ""Environment"", ""${var.environment}"",
    ""Name"", ""sg-${var.environment_role}-${var.environment}-${var.environment_vpc}-${var.environment_group}"",
    ""Owner"", ""${var.owner}"",
    ""Region"", ""${var.region}"",
    ""Role"", ""${var.environment_role}""),""${var.tags}"",
  )}""

  lifecycle {
    create_before_destroy = true
  }
}

# Allow all outbound
resource ""aws_security_group_rule"" ""sgr_egress_all"" {
  type              = ""egress""
  protocol          = ""-1""
  from_port         = 0
  to_port           = 0
  cidr_blocks       = [""0.0.0.0/0""]
  security_group_id = ""${aws_security_group.sg.id}""
}


# Allow SSH from Bastion
resource ""aws_security_group_rule"" ""sgr_ingress_tcp_22_bastion"" {
  type                     = ""ingress""
  protocol                 = ""tcp""
  from_port                = 22
  to_port                  = 22
  source_security_group_id = ""${data.terraform_remote_state.role_bastion.role_sg_id}""
  security_group_id        = ""${aws_security_group.sg.id}""
}

# Allow MariaDB port from App group
resource ""aws_security_group_rule"" ""sgr_ingress_tcp_3306_app"" {
  type                     = ""ingress""
  protocol                 = ""tcp""
  from_port                = 3306
  to_port                  = 3306
  source_security_group_id = ""${data.terraform_remote_state.group_app.group_sg_id}""
  security_group_id        = ""${aws_security_group.sg.id}""
}


resource ""aws_instance"" ""instance"" {
  count                = ""${length(var.hostname)}""
  ami                  = ""${var.ami}""
  iam_instance_profile = ""${aws_iam_instance_profile.iamprofile.id}""
  instance_type        = ""${var.instance_type}""
  key_name             = ""${data.terraform_remote_state.vpc.vpc_key_name}""
  subnet_id            = ""${element(data.terraform_remote_state.network.private1_subnet_ids, count.index)}""
  user_data            = ""${element(data.template_cloudinit_config.userdata.*.rendered, count.index)}""

  vpc_security_group_ids = [
    ""${data.terraform_remote_state.vpc.vpc_sg_id}"",
    ""${data.terraform_remote_state.group.group_sg_id}"",
    ""${aws_security_group.sg.id}"",
  ]

  tags = ""${merge(map(
    ""BuiltBy"", ""${var.built_by}"",
    ""Environment"", ""${var.environment}"",
    ""Name"", ""${element(var.hostname, count.index)}"",
    ""Owner"", ""${var.owner}"",
    ""Region"", ""${var.region}"",
    ""Role"", ""${var.environment_role}""),""${var.tags}"",
  )}""

  associate_public_ip_address = ""${var.associate_public_ip_address}""
}

resource ""aws_cloudwatch_metric_alarm"" ""service"" {
  count               = ""${length(var.hostname)}""
  alarm_name          = ""cw-autorecover-${var.environment_role}${count.index + 1}-${var.environment}-${var.environment_vpc}""
  namespace           = ""AWS/EC2""
  evaluation_periods  = ""2""
  period              = ""60""
  alarm_description   = ""This metric auto recovers EC2 instances""
  alarm_actions       = [""arn:aws:automate:${var.region}:ec2:recover""]
  statistic           = ""Minimum""
  comparison_operator = ""GreaterThanThreshold""
  threshold           = ""0""
  metric_name         = ""StatusCheckFailed_System""

  dimensions {
    InstanceId = ""${element(aws_instance.instance.*.id, count.index)}""
  }
}


data ""template_file"" ""cloudconfig"" {
  count    = ""${length(var.hostname)}""
  template = ""${file(""${path.module}/userdata_files/cloudconfig.tpl"")}""
  vars     = {}
}

data ""template_file"" ""bootscript"" {
  count    = ""${length(var.hostname)}""
  template = ""${file(""${path.module}/userdata_files/bootscript.tpl"")}""

  vars = {
    hostname   = ""${element(var.hostname, count.index)}""
    domainname = ""${var.domainname}""
  }
}

# Merge cloudconfig and bootstrap scripts to feed userdata
data ""template_cloudinit_config"" ""userdata"" {
  count         = ""${length(var.hostname)}""
  gzip          = true
  base64_encode = true

  part {
    filename     = ""cloudconfig.cfg""
    content      = ""${element(data.template_file.cloudconfig.*.rendered, count.index)}""
    content_type = ""text/cloud-config""
  }

  part {
    filename     = ""bootscript.sh""
    content      = ""${element(data.template_file.bootscript.*.rendered, count.index)}""
    content_type = ""text/x-shellscript""
  }
}


output ""role_sg_id"" {
  value = ""${aws_security_group.sg.id}""
}

output ""iamrole_name"" {
  value = ""${aws_iam_role.iamrole.name}""
}


","{
  ""userQuery1"": ""The user wants to create an AWS EC2 instance with specific configurations such as the instance type, AMI, IAM instance profile, and user data. The instance should be launched in a specific availability zone and VPC, with options to associate a public IP address, enable detailed monitoring, and control traffic routing."",
  ""userQuery2"": ""The user intends to manage the root block device of the instance, specifying whether the volume should be destroyed on instance termination, the amount of provisioned IOPS, the type of volume, and the size of the volume."",
  ""userQuery3"": ""The user wants to tag the resources for better management and identification. They also want to store the Terraform state file in an S3 bucket and use remote state data for VPC, network, group, and role configurations."",
  ""userQuery4"": ""The user intends to create an IAM role and instance profile for the instance, with a policy to deny"
12,dechiad1,aws-setup,eks,"variable ""eks_cluster_name"" {}
variable ""eks_subnet_1"" {}
variable ""eks_subnet_2"" {}
variable ""eks_vpc_id"" {}
variable ""eks_worker_count"" {}
variable ""eks_worker_instance_type"" {}
variable ""eks_worker_key_name"" {}
variable ""workstation_ip"" {}


/*
* EKS master IAM role & associated policies
*/
resource ""aws_iam_role"" ""eks-cluster"" {
	name = ""${var.eks_cluster_name}""
  
	assume_role_policy = <<MASTER_POLICY
{
	""Version"" : ""2012-10-17"",
  ""Statement"": [
		{
			""Effect"": ""Allow"",
			""Principal"": {
				""Service"": ""eks.amazonaws.com""
			},
		""Action"": ""sts:AssumeRole""
		}
	]
}
	MASTER_POLICY
}

resource ""aws_iam_role_policy_attachment"" ""eks-cluster-AmazonEKSClusterPolicy"" {
	policy_arn = ""arn:aws:iam::aws:policy/AmazonEKSClusterPolicy""
  role       = ""${aws_iam_role.eks-cluster.name}""
}

resource ""aws_iam_role_policy_attachment"" ""eks-cluster-AmazonEKSServicePolicy"" {
	policy_arn = ""arn:aws:iam::aws:policy/AmazonEKSServicePolicy""
  role       = ""${aws_iam_role.eks-cluster.name}""
}

/*
* EKS master plane security groups
*/
resource ""aws_security_group"" ""eks-cluster"" {
	name        = ""eks-cluster-masters""
  description = ""sg for eks master plane""
  vpc_id      = ""${var.eks_vpc_id}""

  egress {
		from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
	}

  tags {
		Name = ""${var.eks_cluster_name}""
	}
}

resource ""aws_security_group_rule"" ""eks-cluster-masterplane-workstation-ingress"" {
	cidr_blocks       = [""${var.workstation_ip}""]
  description       = ""Allow workstation to speak to api server""
	from_port         = 443
  to_port           = 443
  protocol          = ""tcp""
	security_group_id = ""${aws_security_group.eks-cluster.id}""
  type              = ""ingress""
}

resource ""aws_security_group_rule"" ""eks-cluster-masterplane-workernodes-ingress"" {
  description              = ""Allow workers to speak to api server""
	from_port                = 443
  to_port                  = 443
  protocol                 = ""tcp""
	security_group_id        = ""${aws_security_group.eks-cluster.id}""
	source_security_group_id = ""${aws_security_group.eks-worker.id}""
  type                     = ""ingress""
}

/*
* EKS master plane
*/
resource ""aws_eks_cluster"" ""eks-cluster"" {
	name     = ""${var.eks_cluster_name}""
	role_arn = ""${aws_iam_role.eks-cluster.arn}""

  vpc_config {
		security_group_ids = [""${aws_security_group.eks-cluster.id}""]
    subnet_ids         = [""${var.eks_subnet_1}"", ""${var.eks_subnet_2}""]
	}

	depends_on = [
		""aws_iam_role_policy_attachment.eks-cluster-AmazonEKSClusterPolicy"",
		""aws_iam_role_policy_attachment.eks-cluster-AmazonEKSServicePolicy"",
	]
}


/*
* EKS worker policies
*/
resource ""aws_iam_role"" ""eks-worker"" {
  name = ""eks-worker-node""

  assume_role_policy = <<WORKER_POLICY
{
	""Version"": ""2012-10-17"",
	""Statement"": [
		{
			""Effect"": ""Allow"",
			""Principal"": {
				""Service"": ""ec2.amazonaws.com""
			},
			""Action"": ""sts:AssumeRole""
		}
	]
}
	WORKER_POLICY
}

resource ""aws_iam_role_policy_attachment"" ""eks-worker-AmazonEKSWorkerNodePolicy"" {
	policy_arn = ""arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy""
  role       = ""${aws_iam_role.eks-worker.name}""
}

resource ""aws_iam_role_policy_attachment"" ""eks-worker-AmazonEKS_CNI_Policy"" {
	policy_arn = ""arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy""
  role       = ""${aws_iam_role.eks-worker.name}""
}

resource ""aws_iam_role_policy_attachment"" ""eks-worker-AmazonEC2ContainerRegistryReadOnly"" {
	policy_arn = ""arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly""
  role       = ""${aws_iam_role.eks-worker.name}""
}

resource ""aws_iam_instance_profile"" ""eks-worker"" {
	name = ""eks-worker""
  role = ""${aws_iam_role.eks-worker.name}""
}

/*
* EKS worker sg
*/

resource ""aws_security_group"" ""eks-worker"" {
	name        = ""eks-worker sg""
	description = ""security group for traffic to/from eks worker nodes""
  vpc_id      = ""${var.eks_vpc_id}""

  egress {
		from_port   = 0
		to_port     = 0
		protocol    = ""-1""
		cidr_blocks = [""0.0.0.0/0""]
	}

	tags = ""${
		map(
			""Name"", ""eks-worker-node"",
			""kubernetes.io/cluster/${var.eks_cluster_name}"", ""owned"",
		)
	}""
} 

resource ""aws_security_group_rule"" ""eks-worker-ingress-self"" {
	description              = ""Allow nodes to speak to each other""
	from_port                = 0
	to_port                  = 65535
	protocol                 = ""-1""
	security_group_id        = ""${aws_security_group.eks-worker.id}""	
	source_security_group_id = ""${aws_security_group.eks-worker.id}""
	type                     = ""ingress""
}

resource ""aws_security_group_rule"" ""eks-worker-ingress-master"" {
	description              = ""Allow masters to speak to workers""
	from_port                = 0
	to_port                  = 65535
	protocol                 = ""-1""
	security_group_id        = ""${aws_security_group.eks-worker.id}""	
	source_security_group_id = ""${aws_security_group.eks-cluster.id}""
	type                     = ""ingress""
}

/*
* EC2 launch configuration and autoscaling group
*/
data ""aws_ami"" ""eks-worker"" {
	filter {
		name   = ""name""
		values = [""amazon-eks-node-1.11-v20181210""] #this is usually amazon-eks-node-v* & the most_recent can take it from there 
	}
	
	most_recent = true
	owners      = [""602401143452""] # Amazon EKS AMI Account ID - according to hashi docs
}


locals {
	eks-worker-userdata = <<USERDATA
#!/bin/bash
set -o xtrace
/etc/eks/bootstrap.sh --apiserver-endpoint '${aws_eks_cluster.eks-cluster.endpoint}' --b64-cluster-ca '${aws_eks_cluster.eks-cluster.certificate_authority.0.data}' '${var.eks_cluster_name}'
USERDATA
}

resource ""aws_launch_configuration"" ""workers"" {
	associate_public_ip_address = false
	iam_instance_profile        = ""${aws_iam_instance_profile.eks-worker.name}""
  image_id                    = ""${data.aws_ami.eks-worker.id}""
  instance_type               = ""${var.eks_worker_instance_type}""
	name_prefix                 = ""eks-terraform""
	security_groups             = [""${aws_security_group.eks-worker.id}""]
	user_data_base64            = ""${base64encode(local.eks-worker-userdata)}""
	key_name                    = ""${var.eks_worker_key_name}""

  lifecycle {
		create_before_destroy = true #why do we need this
	}
}

resource ""aws_autoscaling_group"" ""eks-workers"" {
	desired_capacity     = ""${var.eks_worker_count}""
	launch_configuration = ""${aws_launch_configuration.workers.id}""
	max_size             = ""${var.eks_worker_count}""
  min_size             = 1
	name                 = ""eks-asg""
	vpc_zone_identifier  = [""${var.eks_subnet_1}"", ""${var.eks_subnet_2}""]

	tag {
		key                 = ""Name""
		value               = ""eks-workers""
		propagate_at_launch = true
	}

	tag {
		key                 = ""kubernetes.io/cluster/${var.eks_cluster_name}""
		value               = ""owned""
		propagate_at_launch = true
	}
}


output ""eks_worker_arn"" {
	value = ""${aws_iam_role.eks-worker.arn}""
}

output ""worker_sg_id"" {
	value = ""${aws_security_group.eks-worker.id}""
}


","{
  ""userQuery1"": ""The user wants to create an Amazon EKS (Elastic Kubernetes Service) cluster with a specific name, which is provided as a variable. The cluster should be associated with a specific IAM (Identity and Access Management) role that allows the EKS service to assume this role."",
  ""userQuery2"": ""The user wants to set up security groups for the EKS cluster and worker nodes. These security groups should allow specific inbound and outbound traffic. The user also wants to specify the VPC (Virtual Private Cloud) in which these security groups and the EKS cluster will be created."",
  ""userQuery3"": ""The user wants to create worker nodes for the EKS cluster. These worker nodes should be associated with a specific IAM role and instance profile. The user also wants to specify the instance type, key name, and the number of worker nodes to be created."",
  ""userQuery4"": ""The user wants to create an autoscaling group"
13,oracle,terraform-provider-baremetal,examples/container_engine/regional_subnet,"// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

/*
 * This example file shows how to configure the oci provider to target a single region.
 */

// These variables would commonly be defined as environment variables or sourced in a .env file
variable ""tenancy_ocid"" {
}

variable ""user_ocid"" {
}

variable ""fingerprint"" {
}

variable ""private_key_path"" {
}

variable ""compartment_ocid"" {
}

variable ""region"" {
  default = ""us-ashburn-1""
}

provider ""oci"" {
  region           = var.region
  tenancy_ocid     = var.tenancy_ocid
  user_ocid        = var.user_ocid
  fingerprint      = var.fingerprint
  private_key_path = var.private_key_path
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

variable ""cluster_name"" {
  default = ""tfTestCluster""
}

variable ""availability_domain"" {
  default = 3
}

variable ""cluster_options_add_ons_is_kubernetes_dashboard_enabled"" {
  default = true
}

variable ""cluster_options_add_ons_is_tiller_enabled"" {
  default = true
}

variable ""cluster_options_kubernetes_network_config_pods_cidr"" {
  default = ""10.1.0.0/16""
}

variable ""cluster_options_kubernetes_network_config_services_cidr"" {
  default = ""10.2.0.0/16""
}

variable ""node_pool_initial_node_labels_key"" {
  default = ""key""
}

variable ""node_pool_initial_node_labels_value"" {
  default = ""value""
}

variable ""node_pool_name"" {
  default = ""tfPool""
}

variable ""node_pool_node_image_name"" {
  default = ""Oracle-Linux-7.6""
}

variable ""node_pool_node_shape"" {
  default = ""VM.Standard2.1""
}

variable ""node_pool_quantity_per_subnet"" {
  default = 2
}

variable ""node_pool_ssh_public_key"" {
  default = ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDOuBJgh6lTmQvQJ4BA3RCJdSmxRtmiXAQEEIP68/G4gF3XuZdKEYTFeputacmRq9yO5ZnNXgO9akdUgePpf8+CfFtveQxmN5xo3HVCDKxu/70lbMgeu7+wJzrMOlzj+a4zNq2j0Ww2VWMsisJ6eV3bJTnO/9VLGCOC8M9noaOlcKcLgIYy4aDM724MxFX2lgn7o6rVADHRxkvLEXPVqYT4syvYw+8OVSnNgE4MJLxaw8/2K0qp19YlQyiriIXfQpci3ThxwLjymYRPj+kjU1xIxv6qbFQzHR7ds0pSWp1U06cIoKPfCazU9hGWW8yIe/vzfTbWrt2DK6pLwBn/G0x3 sample""
}

variable ""node_pool_boot_volume_size_in_gbs"" {
  default = ""60""
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

data ""oci_identity_availability_domain"" ""ad1"" {
  compartment_id = var.tenancy_ocid
  ad_number      = 1
}

data ""oci_identity_availability_domain"" ""ad2"" {
  compartment_id = var.tenancy_ocid
  ad_number      = 2
}

data ""oci_containerengine_cluster_option"" ""test_cluster_option"" {
  cluster_option_id = ""all""
}

data ""oci_containerengine_node_pool_option"" ""test_node_pool_option"" {
  node_pool_option_id = ""all""
}

data ""oci_core_images"" ""shape_specific_images"" {
  #Required
  compartment_id = var.tenancy_ocid
  shape = ""VM.Standard2.1""
}

locals {
  all_images = ""${data.oci_core_images.shape_specific_images.images}""
  all_sources = ""${data.oci_containerengine_node_pool_option.test_node_pool_option.sources}""

  compartment_images = [for image in local.all_images : image.id if length(regexall(""Oracle-Linux-[0-9]*.[0-9]*-20[0-9]*"",image.display_name)) > 0 ]

  oracle_linux_images = [for source in local.all_sources : source.image_id if length(regexall(""Oracle-Linux-[0-9]*.[0-9]*-20[0-9]*"",source.source_name)) > 0]

  image_id = tolist(setintersection( toset(local.compartment_images), toset(local.oracle_linux_images)))[0]

}

output ""cluster_kubernetes_versions"" {
  value = [data.oci_containerengine_cluster_option.test_cluster_option.kubernetes_versions]
}

output ""node_pool_kubernetes_version"" {
  value = [data.oci_containerengine_node_pool_option.test_node_pool_option.kubernetes_versions]
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

resource ""oci_core_vcn"" ""test_vcn"" {
  cidr_block     = ""10.0.0.0/16""
  compartment_id = var.compartment_ocid
  display_name   = ""tfVcnForClusters""
}

resource ""oci_core_network_security_group"" ""test_nsg"" {
  compartment_id = var.compartment_ocid
  display_name   = ""tfNsgForClusters""
  vcn_id         = oci_core_vcn.test_vcn.id
}

resource ""oci_core_internet_gateway"" ""test_ig"" {
  compartment_id = var.compartment_ocid
  display_name   = ""tfClusterInternetGateway""
  vcn_id         = oci_core_vcn.test_vcn.id
}

resource ""oci_core_route_table"" ""test_route_table"" {
  compartment_id = var.compartment_ocid
  vcn_id         = oci_core_vcn.test_vcn.id
  display_name   = ""tfClustersRouteTable""

  route_rules {
    destination       = ""0.0.0.0/0""
    destination_type  = ""CIDR_BLOCK""
    network_entity_id = oci_core_internet_gateway.test_ig.id
  }
}

resource ""oci_core_subnet"" ""clusterSubnet_1"" {
  #Required
  availability_domain = data.oci_identity_availability_domain.ad1.name
  cidr_block          = ""10.0.20.0/24""
  compartment_id      = var.compartment_ocid
  vcn_id              = oci_core_vcn.test_vcn.id

  # Provider code tries to maintain compatibility with old versions.
  security_list_ids = [oci_core_vcn.test_vcn.default_security_list_id]
  display_name      = ""tfSubNet1ForClusters""
  route_table_id    = oci_core_route_table.test_route_table.id
}

resource ""oci_core_subnet"" ""clusterSubnet_2"" {
  #Required
  availability_domain = data.oci_identity_availability_domain.ad2.name
  cidr_block          = ""10.0.21.0/24""
  compartment_id      = var.compartment_ocid
  vcn_id              = oci_core_vcn.test_vcn.id
  display_name        = ""tfSubNet1ForClusters""

  # Provider code tries to maintain compatibility with old versions.
  security_list_ids = [oci_core_vcn.test_vcn.default_security_list_id]
  route_table_id    = oci_core_route_table.test_route_table.id
}

resource ""oci_core_subnet"" ""cluster_regional_subnet"" {
  #Required
  cidr_block     = ""10.0.26.0/24""
  compartment_id = var.compartment_ocid
  vcn_id         = oci_core_vcn.test_vcn.id

  # Provider code tries to maintain compatibility with old versions.
  security_list_ids = [oci_core_vcn.test_vcn.default_security_list_id]
  display_name      = ""clusterRegionalSubnet""
  route_table_id    = oci_core_route_table.test_route_table.id
}

resource ""oci_core_subnet"" ""node_pool_regional_subnet_1"" {
  #Required
  cidr_block     = ""10.0.24.0/24""
  compartment_id = var.compartment_ocid
  vcn_id         = oci_core_vcn.test_vcn.id

  # Provider code tries to maintain compatibility with old versions.
  security_list_ids = [oci_core_vcn.test_vcn.default_security_list_id]
  display_name      = ""regionalSubnet1""
  route_table_id    = oci_core_route_table.test_route_table.id
}

resource ""oci_core_subnet"" ""node_pool_regional_subnet_2"" {
  #Required
  cidr_block     = ""10.0.25.0/24""
  compartment_id = var.compartment_ocid
  vcn_id         = oci_core_vcn.test_vcn.id

  # Provider code tries to maintain compatibility with old versions.
  security_list_ids = [oci_core_vcn.test_vcn.default_security_list_id]
  display_name      = ""regionalSubnet2""
  route_table_id    = oci_core_route_table.test_route_table.id
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

resource ""oci_containerengine_cluster"" ""test_cluster"" {
  #Required
  compartment_id     = var.compartment_ocid
  kubernetes_version = data.oci_containerengine_cluster_option.test_cluster_option.kubernetes_versions[0]
  name               = var.cluster_name
  vcn_id             = oci_core_vcn.test_vcn.id

  #Optional
  endpoint_config {
    subnet_id             = oci_core_subnet.cluster_regional_subnet.id
    is_public_ip_enabled  = ""true""
    nsg_ids               = [oci_core_network_security_group.test_nsg.id]
  }

  options {
    service_lb_subnet_ids = [oci_core_subnet.clusterSubnet_1.id, oci_core_subnet.clusterSubnet_2.id]

    #Optional
    add_ons {
      #Optional
      is_kubernetes_dashboard_enabled = var.cluster_options_add_ons_is_kubernetes_dashboard_enabled
      is_tiller_enabled               = var.cluster_options_add_ons_is_tiller_enabled
    }

    kubernetes_network_config {
      #Optional
      pods_cidr     = var.cluster_options_kubernetes_network_config_pods_cidr
      services_cidr = var.cluster_options_kubernetes_network_config_services_cidr
    }
  }
}

resource ""oci_containerengine_node_pool"" ""test_node_pool"" {
  #Required
  cluster_id         = oci_containerengine_cluster.test_cluster.id
  compartment_id     = var.compartment_ocid
  kubernetes_version = data.oci_containerengine_node_pool_option.test_node_pool_option.kubernetes_versions[0]
  name               = var.node_pool_name
  node_shape         = var.node_pool_node_shape

  #Optional
  initial_node_labels {
    #Optional
    key   = var.node_pool_initial_node_labels_key
    value = var.node_pool_initial_node_labels_value
  }

  node_source_details {
    #Required
    image_id    = local.oracle_linux_images.0
    source_type = ""IMAGE""

    #Optional
    boot_volume_size_in_gbs = var.node_pool_boot_volume_size_in_gbs
  }

  ssh_public_key = var.node_pool_ssh_public_key

  node_config_details {
    placement_configs {
      availability_domain = data.oci_identity_availability_domain.ad2.name
      subnet_id           = oci_core_subnet.node_pool_regional_subnet_2.id
    }

    placement_configs {
      availability_domain = data.oci_identity_availability_domain.ad1.name
      subnet_id           = oci_core_subnet.node_pool_regional_subnet_1.id
    }

    size = 4
  }
}

output ""cluster"" {
  value = {
    id                 = oci_containerengine_cluster.test_cluster.id
    kubernetes_version = oci_containerengine_cluster.test_cluster.kubernetes_version
    name               = oci_containerengine_cluster.test_cluster.name
  }
}

output ""node_pool"" {
  value = {
    id                 = oci_containerengine_node_pool.test_node_pool.id
    kubernetes_version = oci_containerengine_node_pool.test_node_pool.kubernetes_version
    name               = oci_containerengine_node_pool.test_node_pool.name
  }
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

variable ""cluster_kube_config_expiration"" {
  default = 2592000
}

variable ""cluster_kube_config_token_version"" {
  default = ""2.0.0""
}

data ""oci_containerengine_cluster_kube_config"" ""test_cluster_kube_config"" {
  #Required
  cluster_id = oci_containerengine_cluster.test_cluster.id

  #Optional
  expiration    = var.cluster_kube_config_expiration
  token_version = var.cluster_kube_config_token_version
}

resource ""local_file"" ""test_cluster_kube_config_file"" {
  content  = data.oci_containerengine_cluster_kube_config.test_cluster_kube_config.content
  filename = ""${path.module}/test_cluster_kubeconfig""
}



","{
  ""userQuery1"": ""The user wants to set up an Oracle Cloud Infrastructure (OCI) provider to target a specific region. They need to provide their tenancy OCID, user OCID, fingerprint, private key path, and compartment OCID. The default region is set to 'us-ashburn-1'."",
  ""userQuery2"": ""The user intends to create a Kubernetes cluster in the OCI. They need to specify the cluster name, availability domain, whether the Kubernetes dashboard and Tiller are enabled, the CIDR blocks for pods and services, the node pool name, node image name, node shape, quantity per subnet, SSH public key, and boot volume size in GBs."",
  ""userQuery3"": ""The user wants to create a Virtual Cloud Network (VCN) with an internet gateway, route table, and several subnets. They also want to create a network security group. The VCN and its components are used to host the Kubernetes"
14,bobtfish,tf_aws_mesos,,"## credential stuff
variable ""domain"" {}
variable ""admin_key_name"" {}
variable ""region"" {}
variable ""vpc_id"" {}
variable ""admin_iprange"" {}
variable ""vpc_iprange"" {
  default = ""0.0.0.0/0""
}
variable ""adminlb_instance_type"" {
    default = ""t2.micro""
}
variable ""lb_instance_type"" {
    default = ""t2.micro""
}
variable ""master_instance_type"" {
    default = ""t2.micro""
}
variable ""discovery_instance_profile"" {}
variable ""slave_instance_type"" {
    default = ""t2.micro""
}
variable ""private_subnet_ids"" {}
variable ""public_subnet_ids"" {}
variable ""domain"" {}
variable ""adminlbs"" {
    default = ""1""
}
variable ""lbs"" {
    default = ""2""
}
variable ""masters"" {
    default = ""3""
}
# number of slaves to install
variable ""slaves"" {
    default = ""3""
}





module ""adminlb"" {
    source = ""adminlb""
    security_group_http = ""${aws_security_group.mesos_http_admin.id}""
    security_group_ssh = ""${aws_security_group.mesos_ssh.id}""
    security_group_internal = ""${aws_security_group.mesos_internal.id}""
    discovery_instance_profile = ""${var.discovery_instance_profile}""
    count = ""${var.adminlbs}""
    instance_type = ""${var.adminlb_instance_type}""
    subnet_ids = ""${var.public_subnet_ids}""
    admin_key_name = ""${var.admin_key_name}""
    domain = ""${var.domain}""
    region = ""${var.region}""
}



module ""dns"" {
    source = ""dns/""
    domain = ""${var.domain}""
    elb_name = ""${module.elb.dns_name}""
    adminlb_public_ips = ""${module.adminlb.public_ips}""
}



module ""elb"" {
    source = ""elb/""
    instance_ids = ""${module.lb.instance_ids}""
    subnet_ids = ""${var.public_subnet_ids}""
    security_group_ids = ""${aws_security_group.mesos_http_all.id}""
}



resource ""aws_security_group"" ""mesos_internal"" {
  name = ""mesos-${var.domain}-internal_allow_all""
  description = ""Allow all inbound traffic""
  vpc_id = ""${var.vpc_id}""
  ingress {
      from_port = 0
      to_port = 65535
      protocol = ""-1""
      self        = true
  }

  tags {
    Name = ""mesos-${var.domain}-internal_allow_all""
  }
}

resource ""aws_security_group"" ""mesos_http_all"" {
  name = ""mesos-${var.domain}-http_all""
  description = ""Allow all inbound HTTP traffic""
  vpc_id = ""${var.vpc_id}""
  ingress {
      from_port = 80
      to_port = 80
      protocol = ""tcp""
      cidr_blocks = [""0.0.0.0/0""]
  }

  tags {
    Name = ""mesos-${var.domain}-http_all""
  }
}

resource ""aws_security_group"" ""mesos_http_admin"" {
  name = ""mesos-${var.domain}-http_admin""
  description = ""Allow inbound HTTP traffic from admin IP range""
  vpc_id = ""${var.vpc_id}""
  ingress {
      from_port = 80
      to_port = 80
      protocol = ""tcp""
      cidr_blocks = [""${var.admin_iprange}""]
  }

  tags {
    Name = ""mesos-${var.domain}-http_admin""
  }
}


resource ""aws_security_group"" ""mesos_ssh"" {
  name = ""mesos-${var.domain}-ssh""
  description = ""Allow all inbound SSH traffic""
  vpc_id = ""${var.vpc_id}""
  ingress {
      from_port = 22
      to_port = 22
      protocol = ""tcp""
      cidr_blocks = [""${var.admin_iprange}"", ""${var.vpc_iprange}""]
  }

  tags {
    Name = ""mesos-${var.domain}-ssh""
  }
}




module ""lb"" {
    source = ""lb""
    security_group_http = ""${aws_security_group.mesos_http_all.id}""
    security_group_ssh = ""${aws_security_group.mesos_ssh.id}""
    security_group_internal = ""${aws_security_group.mesos_internal.id}""
    subnet_ids = ""${var.private_subnet_ids}""
    discovery_instance_profile = ""${var.discovery_instance_profile}""
    count = ""${var.lbs}""
    instance_type = ""${var.lb_instance_type}""
    admin_key_name = ""${var.admin_key_name}""
    domain = ""${var.domain}""
    region = ""${var.region}""
}




module ""mesos_master"" {
    source = ""mesos_master""
    security_group_ssh = ""${aws_security_group.mesos_ssh.id}""
    security_group_internal = ""${aws_security_group.mesos_internal.id}""
    discovery_instance_profile = ""${var.discovery_instance_profile}""
    subnet_ids = ""${var.private_subnet_ids}""
    count = ""${var.masters}""
    instance_type = ""${var.master_instance_type}""
    admin_key_name = ""${var.admin_key_name}""
    region = ""${var.region}""
}



module ""mesos_slave"" {
    source = ""mesos_slave""
    discovery_instance_profile = ""${var.discovery_instance_profile}""
    count = ""${var.slaves}""
    instance_type = ""${var.slave_instance_type}""
    subnet_ids = ""${var.private_subnet_ids}""
    security_group_ssh = ""${aws_security_group.mesos_ssh.id}""
    security_group_internal = ""${aws_security_group.mesos_internal.id}""
    admin_key_name = ""${var.admin_key_name}""
    zookeeper_cluster_size = ""${var.masters}""
    region = ""${var.region}""
}



output ""mesos_elb_dns_name"" {
  value = ""${module.elb.dns_name}""
}
output ""mesos_elb_id"" {
  value = ""${module.elb.id}""
}
output ""marathon_api"" {
  value = ""http://marathon.admin.${var.domain}""
}
output ""mesos_api"" {
  value = ""http://mesos.admin.${var.domain}""
}
output ""domain"" {
  value = ""${var.domain}""
}



","{
""userQuery1"": ""The user wants to set up a cloud infrastructure on AWS with a specific domain, region, and VPC ID. The user also wants to specify the IP range for the admin and VPC, and the instance types for admin load balancer, load balancer, master, and slave. The user also wants to specify the number of admin load balancers, load balancers, masters, and slaves."",
""userQuery2"": ""The user wants to set up security groups for the infrastructure, allowing all inbound traffic, all inbound HTTP traffic, inbound HTTP traffic from the admin IP range, and all inbound SSH traffic. The user also wants to specify the subnet IDs for public and private networks."",
""userQuery3"": ""The user wants to set up modules for admin load balancer, DNS, ELB, load balancer, Mesos master, and Mesos slave. The user also wants to output the ELB DNS name, ELB ID, Marathon API, Mes"
15,GoogleCloudPlatform,anthos-samples,anthos-bm-gcp-terraform/modules/vm,"/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ""external_ip_addresses"" {
  source   = ""../external-ip""
  region   = var.region
  ip_names = var.vm_names
}

module ""compute_instance"" {
  source            = ""terraform-google-modules/vm/google//modules/compute_instance""
  version           = ""~> 8.0.0""
  instance_template = var.instance_template
  zone              = var.zone
  for_each          = toset(var.vm_names)
  hostname          = each.value
  network           = var.network # --network default
  access_config = [{
    nat_ip       = module.external_ip_addresses.ips[each.value].address
    network_tier = module.external_ip_addresses.ips[each.value].tier
  }]
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""region"" {
  description = ""Google Cloud Region in which the External IP addresses should be provisioned""
  type        = string
  default     = ""us-central1""
}

variable ""zone"" {
  description = ""Google Cloud Zone in which the VMs should be provisioned""
  type        = string
  default     = ""us-central1-a""
}

variable ""network"" {
  description = ""VPC network to which the provisioned VMs are to be connected to""
  type        = string
  default     = ""default""
}

variable ""vm_names"" {
  description = ""List of names to be given to the Compute Engine VMs that are provisioned""
  type        = list(any)
}

variable ""instance_template"" {
  description = ""Google Cloud instance template based on which the VMs are to be provisioned""
  type        = string
}



/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""vm_info"" {
  description = <<EOF
    Information pertaining to all the VMs that were created. It is in the form
    of a list of objects. Each object contains the hostname, internal IP address
    and the external IP address of a specific VM that was created.
  EOF
  value = flatten([
    for group in module.compute_instance[*] : [
      for vm_details in group : [
        for detail in vm_details.instances_details : {
          hostname   = detail.name
          internalIp = detail.network_interface.0.network_ip
          externalIp = detail.network_interface.0.access_config.0.nat_ip
        }
      ]
    ]
  ])
}


","{
  ""userQuery1"": ""The user wants to provision Google Cloud Compute Engine virtual machines (VMs) in a specific region and zone. The names of these VMs are provided by the user."",
  ""userQuery2"": ""The user wants to assign external IP addresses to these VMs. The IP addresses should be provisioned in the same region as the VMs."",
  ""userQuery3"": ""The user wants to connect these VMs to a specific Virtual Private Cloud (VPC) network."",
  ""userQuery4"": ""The user wants to use a specific Google Cloud instance template for provisioning these VMs."",
  ""userQuery5"": ""The user wants to retrieve information about the provisioned VMs, including their hostnames, internal IP addresses, and external IP addresses.""
}"
16,kzap,terraform-modules,providers/aws/app-server,"provider ""aws"" {
    region = ""${var.region}""
    access_key = ""${var.access_key}""
    secret_key = ""${var.secret_key}""
}

resource ""aws_instance"" ""appserver_node"" {
    count = ""${var.servers}""
    ami = ""${var.ami_id}""
    availability_zone = ""${element(var.azs, count.index)}""
    key_name = ""${var.key_name}""
    instance_type = ""${var.instance_type}""
    user_data = ""${var.user_data}""

    tags {
        Name = ""${var.prefix}-node-${count.index}""
        created_by = ""${lookup(var.tags,""created_by"")}""
    }

    root_block_device {
        delete_on_termination = true
    }
}

resource ""aws_eip"" ""appserver_eip"" {
    count = ""${replace(var.create_eip, ""1"", var.servers)}""
    instance = ""${element(aws_instance.appserver_node.*.id, count.index)}""
}

# AWS Provider Variables
variable ""region"" {
    default = ""us-west-2""
    description = ""The region of AWS""
}
variable ""access_key"" {}
variable ""secret_key"" {}

# Instance Variables
variable ""ami_id"" {
    # CentOS 7 AMI: https://aws.amazon.com/marketplace/pp/B00O7WM7QW
    default = ""ami-d2c924b2""
    description = ""The ID of the AMI to use""
}

variable ""azs"" { 
    type = ""list""
    default = [""us-west-2a""]
    description = ""A list of availability zones for your region that you want to put your instances on""
}

variable ""subnet_id"" {
    default = """"
    description = ""The VPC subnet the instance(s) will go in""
}

variable ""key_name"" {
    default = """"
    description = ""The name of they AWS keypair to access the instance""
}

variable ""instance_type"" {
    default = ""t2.micro""
    description = ""The instance you wish to launch""
}

variable ""user_data"" {
    default = """"
    description = ""A string of user_data for this server""
}

variable ""tags"" {
    default = {
        created_by = ""terraform""
    }
}

variable ""prefix"" {
    default = ""apache""
}

variable ""servers"" {
    default = 1
    description = ""The number of App servers to launch.""
}

variable ""public_key"" {}

variable ""key_file_path"" {}

variable ""create_eip"" {
    default = false
    description = ""Whether or not to attach an Elastic IP to this instance""
}


output ""ec2_ips"" {
	value = [""${aws_instance.appserver_node.*.public_ip}""]
}

output ""ec2_eips"" {
	value = [""${aws_eip.appserver_eip.*.public_ip}""]
}

output ""ec2_ids"" {
	value = [""${aws_instance.appserver_node.*.id}""]
}


","{
    ""userQuery1"": ""The user wants to create a specific number of AWS instances in a specified region. The instances should be of a certain type and use a specific Amazon Machine Image (AMI). The instances should be placed in a specific availability zone and should be accessible using a specific key pair. The instances should also have certain tags for identification and management purposes."",
    ""userQuery2"": ""The user wants to attach an Elastic IP to each of the created instances. This should be optional and controlled by a variable."",
    ""userQuery3"": ""The user wants to output the public IP addresses and IDs of the created instances, as well as the public IP addresses of the attached Elastic IPs. This information should be easily accessible after the creation of the resources.""
}"
17,terraform-google-modules,terraform-google-vpc-service-controls,examples/bq-exfil-demo,"/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


###########################
## Source Bastion Host
###########################

module ""bastion"" {
  source  = ""terraform-google-modules/bastion-host/google""
  version = ""~> 6.0""

  project = module.project1.project_id
  zone    = var.zone
  members = var.members
  network = module.vpc.network_self_link
  subnet  = module.vpc.subnets_self_links[0]
  service_account_roles_supplemental = [
    ""roles/bigquery.admin"",
    ""roles/storage.admin"",
  ]
}

module ""vpc"" {
  source  = ""terraform-google-modules/network/google""
  version = ""~> 8.0""

  project_id              = module.project1.project_id
  network_name            = ""test-network""
  auto_create_subnetworks = false
  subnets = [
    {
      subnet_name   = ""test-subnet""
      subnet_ip     = ""10.127.0.0/20""
      subnet_region = var.region
    }
  ]
}

######################################
## Simulate Exfil to other GCP project
######################################

resource ""google_project_iam_member"" ""bound_from_attacker"" {
  project = module.project2.project_id
  role    = ""roles/owner""
  member  = ""serviceAccount:${module.bastion.service_account}""
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

###########################
## Org Policy External IP
###########################

resource ""google_organization_policy"" ""external_ip_policy"" {
  org_id     = var.org_id
  constraint = ""compute.vmExternalIpAccess""

  list_policy {
    deny {
      all = true
    }
  }
}

###########################
## VPC Service Controls
###########################

module ""org_policy"" {
  source      = ""terraform-google-modules/vpc-service-controls/google""
  version     = ""~> 5.0""
  parent_id   = var.org_id
  policy_name = ""VPC SC Demo Policy""
}

module ""access_level_members"" {
  source  = ""terraform-google-modules/vpc-service-controls/google//modules/access_level""
  version = ""~> 5.0""
  policy  = module.org_policy.policy_id
  name    = ""terraform_members""
  members = [""serviceAccount:${var.terraform_service_account}""]
}

module ""regular_service_perimeter_1"" {
  source              = ""terraform-google-modules/vpc-service-controls/google//modules/regular_service_perimeter""
  version             = ""~> 5.0""
  policy              = module.org_policy.policy_id
  perimeter_name      = ""regular_perimeter_1""
  description         = ""Perimeter shielding projects""
  resources           = [module.project1.project_number]
  access_levels       = [module.access_level_members.name]
  restricted_services = [""bigquery.googleapis.com"", ""storage.googleapis.com""]
}



/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ""project1"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 14.0""

  name              = ""vpc-sc-demo-project-1""
  random_project_id = true
  org_id            = var.org_id
  billing_account   = var.billing_account
  folder_id         = var.folder_id
  activate_apis     = var.enabled_apis
}

module ""project2"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 14.0""

  name              = ""vpc-sc-demo-project-2""
  random_project_id = true
  org_id            = var.org_id
  billing_account   = var.billing_account
  folder_id         = var.folder_id
  activate_apis     = var.enabled_apis
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ""bigquery"" {
  source  = ""terraform-google-modules/bigquery/google""
  version = ""~> 7.0""

  dataset_id   = ""project_1_dataset""
  dataset_name = ""project_1_dataset""
  description  = ""Some Cars""
  project_id   = module.project1.project_id
  location     = ""US""
  tables = [
    {
      table_id = ""cars"",
      schema   = ""fixtures/schema.json"",
      time_partitioning = {
        type                     = ""DAY"",
        field                    = null,
        require_partition_filter = false,
        expiration_ms            = null,
      },
      range_partitioning = null,
      expiration_time    = null,
      clustering         = null,
      labels = {
        env = ""dev""
      },
    }
  ]
  dataset_labels = {
    env = ""dev""
  }
}

resource ""null_resource"" ""load_data"" {
  triggers = {
    bq_table = module.bigquery.table_names[0]
  }

  provisioner ""local-exec"" {
    command = <<EOF
      bq --project_id ${module.project1.project_id} \
      load \
      --location=US \
      --format=csv \
      --field_delimiter=';' \
      project_1_dataset.cars \
      gs://${google_storage_bucket.source_bucket.name}/${google_storage_bucket_object.data.output_name}
EOF
  }
}

resource ""google_storage_bucket"" ""source_bucket"" {
  project  = module.project1.project_id
  name     = ""${module.project1.project_id}-source-bucket""
  location = ""US""
}

resource ""google_storage_bucket_object"" ""data"" {
  name   = ""cars.csv""
  source = ""fixtures/cars.csv""
  bucket = google_storage_bucket.source_bucket.name
}


resource ""google_storage_bucket"" ""target_bucket"" {
  project  = module.project2.project_id
  name     = ""${module.project2.project_id}-target-bucket""
  location = ""US""
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""org_id"" {
  description = ""Organization ID. e.g. 1234567898765""
  type        = string
}

variable ""billing_account"" {
  description = ""Billing Account id. e.g. AAAAAA-BBBBBB-CCCCCC""
  type        = string
}

variable ""folder_id"" {
  description = ""Folder ID within the Organization: e.g. 1234567898765""
  type        = string
  default     = """"
}
variable ""members"" {
  description = ""List of members in the standard GCP form: user:{email}, serviceAccount:{email}, group:{email}""
  type        = list(string)
  default     = []
}

variable ""terraform_service_account"" {
  type        = string
  description = ""The Terraform service account email that should still be allowed in the perimeter to create buckets, datasets, etc.""
}

variable ""region"" {
  description = ""Region where the bastion host will run""
  type        = string
  default     = ""us-west1""
}

variable ""zone"" {
  description = ""Zone where the bastion host will run""
  type        = string
  default     = ""us-west1-a""
}

variable ""enabled_apis"" {
  description = ""List of APIs to enable on the created projects""
  type        = list(string)
  default = [
    ""iap.googleapis.com"",
    ""oslogin.googleapis.com"",
    ""compute.googleapis.com"",
    ""bigquery.googleapis.com"",
    ""storage-api.googleapis.com"",
  ]
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""target_bucket"" {
  value = google_storage_bucket.target_bucket.url
}

output ""source_project"" {
  value = module.project1.project_id
}


","{
  ""userQuery1"": ""The user wants to create two Google Cloud Platform (GCP) projects with unique, random project IDs. The projects are named 'vpc-sc-demo-project-1' and 'vpc-sc-demo-project-2'. The user also wants to enable a list of APIs on these projects, including 'iap.googleapis.com', 'oslogin.googleapis.com', 'compute.googleapis.com', 'bigquery.googleapis.com', and 'storage-api.googleapis.com'."",
  ""userQuery2"": ""The user intends to set up a bastion host in a specific zone of a GCP project. The bastion host is sourced from the 'terraform-google-modules/bastion-host/google' module and is given additional roles of 'bigquery.admin' and 'storage.admin'. The user also wants to create a Virtual Private Cloud (VPC) network named 'test-network' with a subnet named 'test-subnet'."",
  ""userQuery3"": ""The user wants to"
18,GoogleCloudPlatform,mlops-on-gcp,environments_setup/mlops-kfp-mlmd/provisioning-kfp/terraform/modules/gke,"# Create a GKE cluster 

resource ""google_container_cluster"" ""gke_cluster"" {
  name               = var.name
  location           = var.location
  description        = var.description
  network            = var.network
  subnetwork         = var.subnetwork     
  initial_node_count = var.node_count

  ip_allocation_policy {
    cluster_ipv4_cidr_block  = ""/16""
    services_ipv4_cidr_block = ""/16""
  }
  
  node_config {
    machine_type = var.node_type

    metadata = {
      disable-legacy-endpoints = ""true""
    }

    service_account = var.sa_full_id

    oauth_scopes = [
      ""https://www.googleapis.com/auth/logging.write"",
      ""https://www.googleapis.com/auth/monitoring"",
      ""https://www.googleapis.com/auth/cloud-platform"",
    ]
    
    
  }
}


variable ""name"" {
    description = ""The name of the GKE cluster""
    type        = string
}

variable ""description"" {
    description = ""The cluster's description""
    type        = string
}

variable ""location"" {
    description = ""The of the GKE cluster""
    type        = string
}

variable ""sa_full_id"" {
    description = ""The cluster's service account full ID""
}

variable ""network"" {
    description = ""The name of the network to which the cluster is connected""
}

variable ""subnetwork"" {
    description = ""The name of the subnetwork to which the cluster is connected""
}


variable ""node_count"" {
    description = ""The cluster's node count""
    default     = 3
}

variable ""node_type"" {
    description = ""The cluster's node type""
    default     = ""n1-standard-1""
}




output ""name"" {
    value = google_container_cluster.gke_cluster.name
}

output ""cluster_endpoint"" {
    value = google_container_cluster.gke_cluster.endpoint
}


","{
  ""userQuery1"": ""The user wants to create a Google Kubernetes Engine (GKE) cluster with a specific name, location, and description. The user also wants to specify the network and subnetwork to which the cluster is connected."",
  ""userQuery2"": ""The user wants to set the initial number of nodes in the cluster and the type of machine for these nodes. The user also wants to disable legacy endpoints and assign a specific service account to the nodes. The user also wants to grant certain OAuth scopes to the nodes, including writing logs, monitoring, and accessing cloud platform services."",
  ""userQuery3"": ""The user wants to output the name and endpoint of the created GKE cluster. The user also wants to specify default values for the node count and node type, in case they are not provided.""
}"
19,tamsky,terrabase,modules/iam-module,"##
## IAM ROLE
##
resource ""aws_iam_role"" ""iam_role"" {
    name  = ""${var.name}-${var.environment}""
    assume_role_policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Statement"": [
    {
      ""Action"": ""sts:AssumeRole"",
      ""Principal"": {
        ""Service"": ""ec2.amazonaws.com""
      },
      ""Effect"": ""Allow"",
      ""Sid"": """"
    }
  ]
}
EOF
}

##
## IAM INSTANCE PROFILE
##
resource ""aws_iam_instance_profile"" ""instance_profile"" {
    name  = ""${var.name}-${var.environment}""
    path  = ""/""
    roles = [""${var.name}-${var.environment}""]
}

","{
  ""userQuery1"": ""The user needs to create an IAM role in AWS with a specific name that is a combination of a variable 'name' and 'environment'. This role should have a policy that allows it to be assumed by the EC2 service."",
  ""userQuery2"": ""The user intends to create an IAM instance profile with a specific name that is a combination of a variable 'name' and 'environment'. This instance profile should be associated with the IAM role created in the first requirement."",
  ""userQuery3"": ""The user wants the IAM instance profile to be created at the root path '/' in the AWS IAM service.""
}"
20,HewlettPackard,terraform-provider-oneview,examples/server_hardware,"provider ""oneview"" {
  ov_username   = var.username
  ov_password   = var.password
  ov_endpoint   = var.endpoint
  ov_sslverify  = var.ssl_enabled
  ov_apiversion = var.api_version
  ov_ifmatch    = ""*""
}

data ""oneview_server_hardware"" ""server_hardware"" {
  name = ""0000A66102, bay 4""
}

output ""oneview_server_hardware_value"" {
  value = data.oneview_server_hardware.server_hardware.uri
}



provider ""oneview"" {
  ov_username   = var.username
  ov_password   = var.password
  ov_endpoint   = var.endpoint
  ov_sslverify  = var.ssl_enabled
  ov_apiversion = var.api_version
  ov_ifmatch    = ""*""
}


data ""oneview_scope"" ""scope_obj"" {
  name = ""Auto-Scope""
}

// Adds Rack server to the appliance
// Licensing can be OneView or OneviewNoiLO for Managed
resource ""oneview_server_hardware"" ""sh"" {
  configuration_state = ""Managed""
  hostname            = ""<serverIp>""
  username            = ""dcs""
  password            = ""dcs""
  licensing_intent    = ""OneView""
  initial_scope_uris  = [data.oneview_scope.scope_obj.uri]
}

// To import server hardware you can use server hardware name. 
// For below example run terraform import oneview_server_hardware.sh <name-of-the-server>
// resource ""oneview_server_hardware"" ""sh"" {
// }


provider ""oneview"" {
  ov_username   = var.username
  ov_password   = var.password
  ov_endpoint   = var.endpoint
  ov_sslverify  = var.ssl_enabled
  ov_apiversion = var.api_version
  ov_ifmatch    = ""*""
}

// Updates oneTimeBoot of the server hardware
// it can be Usb, Network, Hdd, Cdrom, Normal
// values are case sensive for Idempotency
resource ""oneview_server_hardware"" ""sh"" {
  one_time_boot = ""Usb""
}

//Enables or Disables maintenance mode
/*resource ""oneview_server_hardware"" ""sh"" {
  maintenance_mode = ""true""
}

// Turn On or Off Uid Light
resource ""oneview_server_hardware"" ""sh"" {
  uid_state = ""On""
}

//Updates Power State of the server hardware
resource ""oneview_server_hardware"" ""sh"" {
  server_power_state {
        power_state = ""Off""
        power_control = ""MomentaryPress""
  }
}*/


","{
  ""userQuery1"": ""The user wants to connect to the OneView provider using their username, password, endpoint, SSL verification status, API version, and a wildcard for the 'ifmatch' parameter."",
  ""userQuery2"": ""The user wants to retrieve data about a specific server hardware named '0000A66102, bay 4' from the OneView provider and output its URI."",
  ""userQuery3"": ""The user wants to add a Rack server to the appliance with a configuration state of 'Managed', a hostname of '<serverIp>', a username of 'dcs', a password of 'dcs', a licensing intent of 'OneView', and an initial scope URI retrieved from a scope named 'Auto-Scope'."",
  ""userQuery4"": ""The user wants to update the 'one_time_boot' parameter of the server hardware to 'Usb'."",
  ""userQuery5"": ""The user has commented out code that indicates potential"
21,terraform-google-modules,terraform-google-data-fusion,modules/hub_artifact,"/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">= 0.13""
  required_providers {

    google = {
      source  = ""hashicorp/google""
      version = "">= 3.53, < 6""
    }
    cdap = {
      source  = ""GoogleCloudPlatform/cdap""
      version = ""~> 0.10""
    }
  }

  provider_meta ""google"" {
    module_name = ""blueprints/terraform/terraform-google-data-fusion:hub_artifact/v3.0.0""
  }

}


/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""bucket"" {
  description = ""Name of the GCS bucket for the hub.""
  type        = string
}

variable ""package"" {
  description = ""Name of the package within the hub bucket that contains the artifact.""
  type        = string
}

variable ""name"" {
  description = ""Name of the artifact within the package.""
  type        = string
}

variable ""artifact_version"" {
  description = ""Version of the artifact.""
  type        = string
}

variable ""package_version"" {
  description = ""Version of the package. If not set, the artifact version is used.""
  type        = string
  default     = null
}

variable ""namespace"" {
  description = ""Namespace to create the artifact in.""
  type        = string
  default     = null
}


/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

locals {
  package_version = var.package_version != null ? var.package_version : var.artifact_version
  gcs_path        = ""gs://${var.bucket}/packages/${var.package}/${local.package_version}/${var.name}-${var.artifact_version}""
}

resource ""cdap_gcs_artifact"" ""artifact"" {
  name             = var.name
  version          = var.artifact_version
  namespace        = var.namespace
  jar_binary_path  = ""${local.gcs_path}.jar""
  json_config_path = ""${local.gcs_path}.json""
}


/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""artifact"" {
  description = ""The created artifact.""
  value       = cdap_gcs_artifact.artifact
}


","{
  ""userQuery1"": ""What is the minimum version of Terraform and the versions of the providers 'google' and 'cdap' required to run this configuration?"",
  ""userQuery2"": ""What are the necessary input variables to create a CDAP GCS artifact and what are their descriptions?"",
  ""userQuery3"": ""What is the output of this configuration and what does it represent?""
}"
22,pixelcanvasio,pixelcanvas,terraform,"variable ""do_token"" {
  description = ""DigitalOcean Token""
}

variable ""region"" {
  description = ""DigitalOcean region""
  default = ""fra1""
}

variable ""public_key"" {
  description = ""Public key""
}

variable ""private_key"" {
  description = ""Private key""
}

variable ""cloudflare_email"" {
  description = ""Login email cloudflare""
}

variable ""cloudflare_token"" {

}

variable ""redis_password"" {
  description = ""redis auth password""
}

variable ""amqp_user"" {
  description = ""rabbitmq auth password""
}

variable ""amqp_password"" {
  description = ""rabbitmq auth password""
}



# Configure the Cloudflare provider
provider ""cloudflare"" {
  email = ""${var.cloudflare_email}""
  token = ""${var.cloudflare_token}""
}

# Configure the Digital Ocean Provider
provider ""digitalocean"" {
  token = ""${var.do_token}""
}

resource ""digitalocean_ssh_key"" ""ssh_key"" {
  name       = ""PixelCanvas""
  public_key = ""${var.public_key}""
}



resource ""cloudflare_record"" ""production"" {
  domain = ""pixelcanvas.io""
  name   = ""pixelcanvas.io""
  value  = ""${digitalocean_loadbalancer.public.ip}""
  type   = ""A""
  proxied= ""true""
}

resource ""cloudflare_record"" ""staging"" {
  domain = ""pixelcanvas.io""
  name   = ""staging""
  value  = ""${digitalocean_floating_ip.web_staging.ip_address}""
  type   = ""A""
  proxied= ""true""
}

// APOTEMA

resource ""cloudflare_record"" ""apotema_production"" {
  domain = ""apotema.games""
  name   = ""pixelcanvas""
  value  = ""${digitalocean_loadbalancer.public.ip}""
  type   = ""A""
  proxied= ""true""
}

resource ""cloudflare_record"" ""apotema_staging"" {
  domain = ""apotema.games""
  name   = ""staging.pixelcanvas""
  value  = ""${digitalocean_floating_ip.web_staging.ip_address}""
  type   = ""A""
  proxied= ""true""
}



# Create Droplet w/ Docker for Deepstream.io
resource ""digitalocean_droplet"" ""mysql"" {
  image  = ""mysql-16-04""
  name   = ""pixelcanvas-mysql""
  region = ""${var.region}""
  size   = ""2gb""

  ipv6               = true
  private_networking = true

  ssh_keys = [
    ""${digitalocean_ssh_key.ssh_key.fingerprint}"",
  ]
}


# https://www.rabbitmq.com/production-checklist.html
# http://stackoverflow.com/questions/8808909/simple-way-to-install-rabbitmq-in-ubuntu

#admin url http://138.68.88.203:15672
resource ""digitalocean_droplet"" ""rabbitmq"" {
  image  = ""debian-8-x64""
  name   = ""pixelcanvas-rabbitmq""
  region = ""${var.region}""
  size   = ""512mb""

  ipv6               = false
  private_networking = true

  count = 1

  ssh_keys = [
    ""${digitalocean_ssh_key.ssh_key.fingerprint}"",
  ]

  connection {
    host     = ""${digitalocean_droplet.rabbitmq.ipv4_address}""
    user     = ""root""
    type     = ""ssh""
    timeout  = ""2m""
    private_key = ""${var.private_key}""
  }

  # http://stackoverflow.com/questions/8808909/simple-way-to-install-rabbitmq-in-ubuntu
  provisioner ""remote-exec"" {
    inline = [
      ""sleep 30"",
      ""curl -sSL https://agent.digitalocean.com/install.sh | sh"",

      ""apt-get update"",
      ""apt-get install rabbitmq-server -y"",

      ""service rabbitmq-server start"",
      ""rabbitmq-plugins enable rabbitmq_management"",
      ""rabbitmqctl add_user ${var.amqp_user} ${var.amqp_password}"",
      ""rabbitmqctl set_user_tags ${var.amqp_user} administrator"",
      ""rabbitmqctl set_permissions -p / ${var.amqp_user} \"".*\"" \"".*\"" \"".*\"""",
      ""rabbitmqctl delete_user guest"",
      ""service rabbitmq-server restart"",

      ""echo \""RESTARTING rabbitmq!!!!!\"""",
      ""sleep 5""
    ]
  }
}



# Create Droplet w/ Docker for Deepstream.io
resource ""digitalocean_droplet"" ""redis"" {
  image  = ""redis""
  name   = ""pixelcanvas-redis""
  region = ""${var.region}""
  size   = ""2gb""

  ipv6               = true
  private_networking = true

  ssh_keys = [
    ""${digitalocean_ssh_key.ssh_key.fingerprint}"",
  ]
}


resource ""null_resource"" ""redis_ip"" {
  depends_on = [""digitalocean_droplet.redis""]

  connection {
    host     = ""${digitalocean_droplet.redis.ipv4_address}""
    user     = ""root""
    type     = ""ssh""
    timeout  = ""2m""
    private_key = ""${var.private_key}""
  }

  provisioner ""remote-exec"" {
    inline = [
      ""sleep 30"",
      ""curl -sSL https://agent.digitalocean.com/install.sh | sh"",
      ""service redis stop"",
      ""sed -i 's/bind 127.0.0.1$/bind ${digitalocean_droplet.redis.ipv4_address_private}/g' /etc/redis/redis.conf"",
      ""echo \""requirepass ${var.redis_password}\"" >> /etc/redis/redis.conf"",
      ""echo \""RESTARTING redis!!!!!\"""",
      ""service redis start"",
      ""sleep 5""
    ]
  }
}



data ""digitalocean_image"" ""pixelcanvas_green_web"" {
  # STAGING
  name = ""pixelcanvas-1510398298""
}
data ""digitalocean_image"" ""pixelcanvas_green_ws"" {
  # STAGING
  name = ""pixelcanvas-1501248731""
}


data ""digitalocean_image"" ""pixelcanvas_blue"" {
  # PRODUCTION
  name = ""pixelcanvas-1510480311""
}
data ""digitalocean_image"" ""pixelcanvas_blue_ws"" {
  # PRODUCTION
  name = ""pixelcanvas-1510393407""
}

resource ""digitalocean_loadbalancer"" ""public"" {
  name = ""pixelcanvas-loadbalancer""
  region = ""${var.region}""

  forwarding_rule {
    entry_port = 80
    entry_protocol = ""http""

    target_port = 80
    target_protocol = ""http""
  }
  healthcheck {
    port = 80
    protocol = ""http""
    path = ""/api/bigchunk/0.0.bmp""
  }

  droplet_ids = [""${digitalocean_droplet.web_blue.*.id}""]
}

resource ""digitalocean_floating_ip"" ""web_staging"" {
  droplet_id = ""${digitalocean_droplet.web_green.0.id}""
  region     = ""${var.region}""
}



########
# BLUE #
########

# TODO important, we are sharing ws servers!
data ""template_file"" ""pm2_web_blue"" {
  template = ""${file(""${path.module}/blue/processes.yml"")}""

  vars {
    script = ""web""
    REDIS_URL = ""redis://:${var.redis_password}@${digitalocean_droplet.redis.ipv4_address_private}:6379""
    AMQP_URL = ""amqp://${var.amqp_user}:${var.amqp_password}@${digitalocean_droplet.rabbitmq.ipv4_address_private}:5672/""
    WS_HOSTNAMES = ""[${join("","", digitalocean_droplet.websockets_blue.*.ipv4_address)}]""
  }
}

data ""template_file"" ""userdata_web_blue"" {
  template = ""${file(""${path.module}/blue/cloud-config.yml"")}""

  vars {
    userdata_public_key = ""${var.public_key}""
    userdata_pm2_conf = ""${base64encode(""${data.template_file.pm2_web_blue.rendered}"")}""
  }
}


# Create Droplet w/ Docker for Deepstream.io
resource ""digitalocean_droplet"" ""web_blue"" {
  image  = ""${data.digitalocean_image.pixelcanvas_blue.image}""
  name   = ""pixelcanvas-web-blue-${count.index}""
  region = ""${var.region}""
  size   = ""512mb""

  ipv6               = false
  private_networking = true

  ssh_keys = [
    ""${digitalocean_ssh_key.ssh_key.fingerprint}"",
  ]

  user_data = ""${data.template_file.userdata_web_blue.rendered}""

  # This will create 4 instances
  count = 6
}



#########
# GREEN #
#########

data ""template_file"" ""pm2_web_green"" {
  template = ""${file(""${path.module}/green/processes.yml"")}""

  vars {
    script = ""web""
    REDIS_URL = ""redis://:${var.redis_password}@${digitalocean_droplet.redis.ipv4_address_private}:6379""
    AMQP_URL = ""amqp://${var.amqp_user}:${var.amqp_password}@${digitalocean_droplet.rabbitmq.ipv4_address_private}:5672/""
    WS_HOSTNAMES = ""[${join("","", digitalocean_droplet.websockets_blue.*.ipv4_address)}]""
  }
}

data ""template_file"" ""userdata_web_green"" {
  template = ""${file(""${path.module}/green/cloud-config.yml"")}""

  vars {
    userdata_public_key = ""${var.public_key}""
    userdata_pm2_conf = ""${base64encode(""${data.template_file.pm2_web_green.rendered}"")}""
  }
}


# Create Droplet w/ Docker for Deepstream.io
resource ""digitalocean_droplet"" ""web_green"" {
  image  = ""${data.digitalocean_image.pixelcanvas_green_web.image}""
  name   = ""pixelcanvas-web-green-${count.index}""
  region = ""${var.region}""
  size   = ""512mb""

  ipv6               = false
  private_networking = true

  ssh_keys = [
    ""${digitalocean_ssh_key.ssh_key.fingerprint}"",
  ]

  user_data = ""${data.template_file.userdata_web_green.rendered}""

  # This will create 4 instances
  count = 0
}



########
# BLUE #
########

data ""template_file"" ""pm2_websockets_blue"" {
  template = ""${file(""${path.module}/blue/processes.yml"")}""

  vars {
    script = ""websockets""
    REDIS_URL = ""redis://:${var.redis_password}@${digitalocean_droplet.redis.ipv4_address_private}:6379""
    AMQP_URL = ""amqp://${var.amqp_user}:${var.amqp_password}@${digitalocean_droplet.rabbitmq.ipv4_address_private}:5672/""
    WS_HOSTNAMES = ""[]""
  }
}

data ""template_file"" ""userdata_websockets_blue"" {
  template = ""${file(""${path.module}/blue/cloud-config.yml"")}""

  vars {
    userdata_public_key = ""${var.public_key}""
    userdata_pm2_conf = ""${base64encode(""${data.template_file.pm2_websockets_blue.rendered}"")}""
  }
}


# Create Droplet w/ Docker for Deepstream.io
resource ""digitalocean_droplet"" ""websockets_blue"" {
  image  = ""${data.digitalocean_image.pixelcanvas_blue_ws.image}""
  name   = ""pixelcanvas-websockets-blue-${count.index}""
  region = ""${var.region}""
  size   = ""512mb""

  ipv6               = false
  private_networking = true

  ssh_keys = [
    ""${digitalocean_ssh_key.ssh_key.fingerprint}"",
  ]

  user_data = ""${data.template_file.userdata_websockets_blue.rendered}""

  # This will create 8 instances
  count = 2

  provisioner ""local-exec"" {
    command = ""sleep 30""
  }
}



#########
# GREEN #
#########

data ""template_file"" ""pm2_websockets_green"" {
  template = ""${file(""${path.module}/green/processes.yml"")}""

  vars {
    script = ""websockets""
    REDIS_URL = ""redis://:${var.redis_password}@${digitalocean_droplet.redis.ipv4_address_private}:6379""
    AMQP_URL = ""amqp://${var.amqp_user}:${var.amqp_password}@${digitalocean_droplet.rabbitmq.ipv4_address_private}:5672/""
    WS_HOSTNAMES = ""[]""
  }
}

data ""template_file"" ""userdata_websockets_green"" {
  template = ""${file(""${path.module}/green/cloud-config.yml"")}""

  vars {
    userdata_public_key = ""${var.public_key}""
    userdata_pm2_conf = ""${base64encode(""${data.template_file.pm2_websockets_green.rendered}"")}""
  }
}


# Create Droplet w/ Docker for Deepstream.io
resource ""digitalocean_droplet"" ""websockets_green"" {
  image  = ""${data.digitalocean_image.pixelcanvas_green_ws.image}""
  name   = ""pixelcanvas-websockets-green-${count.index}""
  region = ""${var.region}""
  size   = ""512mb""

  ipv6               = false
  private_networking = true

  ssh_keys = [
    ""${digitalocean_ssh_key.ssh_key.fingerprint}"",
  ]

  user_data = ""${data.template_file.userdata_websockets_green.rendered}""

  # This will create 1 instances
  count = 0

  provisioner ""local-exec"" {
    command = ""sleep 30""
  }
}


","{
  ""userQuery1"": ""The user wants to manage and automate the deployment of their infrastructure on DigitalOcean. They need to create and configure several resources including SSH keys, droplets, a load balancer, and a floating IP. They also want to specify the region where these resources will be deployed, with a default region of 'fra1'."",
  ""userQuery2"": ""The user wants to manage DNS records for two domains ('pixelcanvas.io' and 'apotema.games') using Cloudflare. They need to create and configure several DNS records for production and staging environments. They also need to provide their Cloudflare login email and token for authentication."",
  ""userQuery3"": ""The user wants to set up a RabbitMQ server and a Redis server on separate droplets. They need to specify the RabbitMQ authentication password and the Redis authentication password. They also want to install and start the RabbitMQ server and configure the Redis server to bind to a private IP address and"
23,surefire,infrastructure,,"provider ""aws"" {
  alias      = ""main""
  access_key = var.aws_access_key.main
  secret_key = var.aws_secret_key.main
  region     = var.aws_region
}

resource ""aws_iam_user"" ""andrewgarner"" {
  provider = aws.main
  name     = ""andrewgarner""
  path     = ""/users/""
}

resource ""aws_iam_group"" ""main_administrators"" {
  provider = aws.main
  name     = ""Administrators""
  path     = ""/users/""
}

resource ""aws_iam_group_membership"" ""main_administrators"" {
  provider = aws.main
  name     = ""AdministratorsGroupMembership""

  users = [
    aws_iam_user.andrewgarner.name,
  ]

  group = aws_iam_group.main_administrators.name
}

resource ""aws_iam_policy_attachment"" ""main_administrators_administrator_access"" {
  provider = aws.main
  name     = ""AdministratorsAdministratorAccess""

  groups = [
    aws_iam_group.main_administrators.name,
  ]

  policy_arn = ""arn:aws:iam::aws:policy/AdministratorAccess""
}

resource ""aws_s3_bucket"" ""terraform_logs"" {
  provider = aws.main
  bucket   = ""surefire.operations.terraform.logs""
  acl      = ""log-delivery-write""

  lifecycle_rule {
    id      = ""Rule for the Entire Bucket""
    prefix  = """"
    enabled = true

    transition {
      days          = 30
      storage_class = ""STANDARD_IA""
    }

    transition {
      days          = 60
      storage_class = ""GLACIER""
    }

    expiration {
      days = 90
    }
  }

  tags = {
    Tenant      = ""SureFire""
    Environment = ""Operations""
    Name        = ""Terraform""
  }
}

resource ""aws_s3_bucket"" ""terraform"" {
  provider = aws.main
  bucket   = ""surefire.operations.terraform""
  acl      = ""private""

  lifecycle_rule {
    id      = ""Rule for the Entire Bucket""
    prefix  = """"
    enabled = true

    transition {
      days          = 30
      storage_class = ""STANDARD_IA""
    }

    transition {
      days          = 60
      storage_class = ""GLACIER""
    }

    expiration {
      days = 90
    }
  }

  logging {
    target_bucket = aws_s3_bucket.terraform_logs.id
  }

  tags = {
    Tenant      = ""SureFire""
    Environment = ""Operations""
    Name        = ""Terraform""
  }

  versioning {
    enabled = true
  }
}


variable ""aws_region"" {
  description = ""AWS region""
  type        = string
  default     = ""eu-west-1""
}

variable ""aws_account_id"" {
  description = ""AWS account ids indexed by environment""
  type        = map(string)

  default = {
    main        = """"
    development = """"
    test        = """"
    staging     = """"
    production  = """"
  }
}

variable ""aws_access_key"" {
  description = ""AWS access keys indexed by environment""
  type        = map(string)

  default = {
    main        = """"
    development = """"
    test        = """"
    staging     = """"
    production  = """"
  }
}

variable ""aws_secret_key"" {
  description = ""AWS secret keys indexed by environment""
  type        = map(string)

  default = {
    main        = """"
    development = """"
    test        = """"
    staging     = """"
    production  = """"
  }
}


module ""development_identity_and_access"" {
  source                  = ""./identity_and_access""
  aws_access_key          = var.aws_access_key.development
  aws_secret_key          = var.aws_secret_key.development
  aws_region              = var.aws_region
  aws_external_account_id = var.aws_account_id.main
}


module ""staging_identity_and_access"" {
  source                  = ""./identity_and_access""
  aws_access_key          = var.aws_access_key.staging
  aws_secret_key          = var.aws_secret_key.staging
  aws_region              = var.aws_region
  aws_external_account_id = var.aws_account_id.main
}


module ""test_identity_and_access"" {
  source                  = ""./identity_and_access""
  aws_access_key          = var.aws_access_key.test
  aws_secret_key          = var.aws_secret_key.test
  aws_region              = var.aws_region
  aws_external_account_id = var.aws_account_id.main
}


module ""production_identity_and_access"" {
  source                  = ""./identity_and_access""
  aws_access_key          = var.aws_access_key.production
  aws_secret_key          = var.aws_secret_key.production
  aws_region              = var.aws_region
  aws_external_account_id = var.aws_account_id.main
}


","{
  ""userQuery1"": ""The user needs to set up an AWS provider with access and secret keys, and a specific region. The keys and region are defined as variables and can be changed as per the user's requirements."",
  ""userQuery2"": ""The user intends to create an IAM user named 'andrewgarner' and an IAM group named 'Administrators'. The user 'andrewgarner' is added to the 'Administrators' group. The 'Administrators' group is given 'AdministratorAccess' policy."",
  ""userQuery3"": ""The user wants to create two S3 buckets named 'surefire.operations.terraform.logs' and 'surefire.operations.terraform'. The first bucket is for storing logs and the second one is for storing terraform files. Both buckets have lifecycle rules defined for transitioning objects to different storage classes and for object expiration. The second bucket also has versioning enabled and logs are stored in the first bucket."",
  ""userQuery"
24,xueshanf,coreos-docker-dev,terraform/etcd,"provider ""aws"" {
  access_key = ""${var.aws_access_key}""
  secret_key = ""${var.aws_secret_key}""
  region = ""${var.aws_region}""
}


variable ""aws_access_key"" {}
variable ""aws_secret_key"" {}
variable ""security_groups"" {}
variable ""aws_ec2_keypairs"" {}

#variable ""instance_aws_access_key"" {}
#variable ""instance_aws_secret_key"" {}
#variable ""etcd_discovery_url"" {}
variable ""environment"" {
  default = ""test""
}
variable ""aws_instance_type"" {
  default = ""m3.medium""
}

variable ""aws_region"" {
  default = ""us-west-2""
}

variable ""aws_availability_zone"" {
  default = ""us-west-2a""
}

# The net block (CIDR) that SSH is available to.
variable ""allow_ssh_from"" {
  default = ""0.0.0.0/0""
}

# get updates at https://s3.amazonaws.com/coreos.com/dist/aws/coreos-beta-hvm.template
variable ""amis"" {
  default = {
    us-east-1 = ""ami-fe60d496""
    us-west-2 = ""ami-6db7f55d""
  }
}

variable ""subnet"" {
    default = {
      us-west-2a = ""subnet-153de770""
      us-west-2b = ""subnet-102cd467""
      us-west-2c = ""subnet-830d15c5""
    } 
}

variable ""private_ip"" {
    default = {
      us-west-2a = ""10.42.2.50""
      us-west-2b = ""10.42.2.100""
      us-west-2c = ""10.42.2.150""
    }
}

variable ""aws_ec2_keypairs"" {
    default = {
      etcd = ""etcd""
      registry = ""registry""
      hosting = ""hosting""
    }
}

variable ""security_groups"" {
    default = {
      etcd = ""sg-01fe6164""
      registry = ""sg-01fe6164""
      hosting = ""sg-07fe6162""
    }
}

#variable ""aws_route53_zone_id_itlab"" {}


# This file is generated by tf-generator.py

resource ""aws_instance"" ""etcd-a-01"" {
    ami = ""${lookup(var.amis, var.aws_region)}""
    instance_type = ""${var.aws_instance_type}""
    key_name = ""${var.aws_ec2_keypairs.etcd}""
    security_groups = [ ""${var.security_groups.etcd}"" ]
    # associate_public_ip_address = true: 
    # Error launching source instance: Network interfaces and an instance-level private IP address may not be specified on the same 
    # request (InvalidParameterCombination). Workaround: turn on associate_public_ip_address for each subnet
    private_ip = ""${var.private_ip.us-west-2a}""
    subnet_id = ""${var.subnet.us-west-2a}""
    iam_instance_profile = ""registry-profile""
    user_data = <<USER_DATA
    ${file(""cloud-config/etcd.yaml"")}
USER_DATA
    
    provisioner ""local-exec"" {
        # command = ""echo ${aws_instance.etcd-a-01.public_ip} > etcd.txt; echo ${aws_instance.etcd-a-01.id}""
        command = ""/usr/local/bin/aws ec2 create-tags --resources ${aws_instance.etcd-a-01.id} --tags Key=Name,Value=docker-etcd-a-01""
    }
}

resource ""aws_instance"" ""etcd-b-01"" {
    depends_on = [ ""aws_instance.etcd-a-01"" ]
    ami = ""${lookup(var.amis, var.aws_region)}""
    instance_type = ""${var.aws_instance_type}""
    key_name = ""${var.aws_ec2_keypairs.etcd}""
    security_groups = [ ""${var.security_groups.etcd}"" ]
    # associate_public_ip_address = true: 
    # Error launching source instance: Network interfaces and an instance-level private IP address may not be specified on the same 
    # request (InvalidParameterCombination). Workaround: turn on associate_public_ip_address for each subnet
    private_ip = ""${var.private_ip.us-west-2b}""
    subnet_id = ""${var.subnet.us-west-2b}""
    iam_instance_profile = ""registry-profile""
    user_data = <<USER_DATA
    ${file(""cloud-config/etcd-join.yaml"")}
USER_DATA
    
    provisioner ""local-exec"" {
        # command = ""echo ${aws_instance.etcd-a-01.public_ip} > etcd.txt; echo ${aws_instance.etcd-a-01.id}""
        command = ""/usr/local/bin/aws ec2 create-tags --resources ${aws_instance.etcd-b-01.id} --tags Key=Name,Value=docker-etcd-b-01""
    }
}

resource ""aws_instance"" ""etcd-c-01"" {
    depends_on = [ ""aws_instance.etcd-a-01"" ]
    ami = ""${lookup(var.amis, var.aws_region)}""
    instance_type = ""${var.aws_instance_type}""
    key_name = ""${var.aws_ec2_keypairs.etcd}""
    security_groups = [ ""${var.security_groups.etcd}"" ]
    # associate_public_ip_address = true: 
    # Error launching source instance: Network interfaces and an instance-level private IP address may not be specified on the same 
    # request (InvalidParameterCombination). Workaround: turn on associate_public_ip_address for each subnet
    private_ip = ""${var.private_ip.us-west-2c}""
    subnet_id = ""${var.subnet.us-west-2c}""
    iam_instance_profile = ""registry-profile""
    user_data = <<USER_DATA
    ${file(""cloud-config/etcd-join.yaml"")}
USER_DATA
    
    provisioner ""local-exec"" {
        # command = ""echo ${aws_instance.etcd-a-01.public_ip} > etcd.txt; echo ${aws_instance.etcd-a-01.id}""
        command = ""/usr/local/bin/aws ec2 create-tags --resources ${aws_instance.etcd-c-01.id} --tags Key=Name,Value=docker-etcd-c-01""
    }
}



","{
  ""userQuery1"": ""The user wants to create three AWS instances in the 'us-west-2' region, specifically in the 'us-west-2a', 'us-west-2b', and 'us-west-2c' availability zones. The instances are of type 'm3.medium' and are associated with the 'registry-profile' IAM instance profile. The instances are named 'docker-etcd-a-01', 'docker-etcd-b-01', and 'docker-etcd-c-01' respectively."",
  ""userQuery2"": ""The user wants to assign specific private IP addresses to each of the instances. The IP addresses are '10.42.2.50' for 'docker-etcd-a-01', '10.42.2.100' for 'docker-etcd-b-01', and '10.42.2.150' for 'docker-etcd-c-01'. The instances are also associated with specific subnets: '"
25,dominis,mikado,terraform/wp,"variable ""vpc_id"" {
  type = ""string""
}

variable ""availability_zones"" {
  type = ""list""
}

variable ""public_subnets"" {
  type = ""list""
}

variable ""private_subnets"" {
  type = ""list""
}

variable ""prod_instance_type"" {
  type    = ""string""
  default = ""t2.micro""
}

variable ""test_instance_type"" {
  type    = ""string""
  default = ""t2.micro""
}

variable ""prod_rds_instance_type"" {
  type    = ""string""
  default = ""db.t2.micro""
}

variable ""test_rds_instance_type"" {
  type    = ""string""
  default = ""db.t2.micro""
}

variable ""create_test_db"" {
  type    = ""string""
  default = true
}

variable ""create_prod_db"" {
  type    = ""string""
  default = true
}

variable ""domain"" {
  type = ""string""
}

variable ""db_pass"" {
  type    = ""string""
  default = ""sup3r-s3cr3t-p4ss""
}

variable ""internal_sg"" {}

variable ""user_data"" {
  type    = ""string""
  default = """"
}

variable ""asg_number_of_instances"" {
  type    = ""string""
  default = ""1""
}

variable ""asg_minimum_number_of_instances"" {
  type    = ""string""
  default = ""1""
}

variable ""asg_maximum_number_of_instances"" {
  type    = ""string""
  default = ""10""
}

variable ""health_check"" {
  type    = ""string""
  default = ""TCP:80""
}

variable ""no_cdn"" {
  type        = ""string""
  description = ""true/false if you want to use a cdn""
  default     = true
}


data ""aws_ami"" ""prod"" {
  filter {
    name   = ""state""
    values = [""available""]
  }

  filter {
    name   = ""name""
    values = [""${var.domain}*""]
  }

  filter {
    name   = ""tag:Production""
    values = [""True""]
  }

  most_recent = true
}

data ""aws_ami"" ""test"" {
  filter {
    name   = ""state""
    values = [""available""]
  }

  filter {
    name   = ""name""
    values = [""${var.domain}*""]
  }

  most_recent = true
}


resource ""aws_security_group"" ""rds"" {
  name   = ""${replace(var.domain, ""."", ""-"")}-internal-mysql""
  vpc_id = ""${var.vpc_id}""

  ingress {
    from_port = 3306
    to_port   = 3306
    protocol  = ""tcp""
    self      = true
  }

  egress {
    from_port = 3306
    to_port   = 3306
    protocol  = ""tcp""
    self      = true
  }

  tags {
    Name        = ""${replace(var.domain, ""."", ""-"")}-internal-mysql""
    Environment = ""prod""
    Role        = ""${var.domain}""
    Mikado      = ""True""
  }

  lifecycle {
    create_before_destroy = true
  }
}


module ""wp-prod-asg"" {
  source                      = ""../asg""
  name                        = ""${replace(var.domain, ""."", ""-"")}""
  vpc_id                      = ""${var.vpc_id}""
  availability_zones          = ""${var.availability_zones}""
  public_subnets              = ""${var.public_subnets}""
  private_subnets             = ""${var.public_subnets}""
  ami_id                      = ""${data.aws_ami.prod.id}""
  instance_type               = ""${var.prod_instance_type}""
  maximum_number_of_instances = ""${var.asg_maximum_number_of_instances}""
  number_of_instances         = ""${var.asg_number_of_instances}""
  minimum_number_of_instances = ""${var.asg_minimum_number_of_instances}""
  rolling_update_batch_size   = ""1""
  elb_instance_port           = ""80""
  internal_sg                 = ""${var.internal_sg}""
  health_check                = ""${var.health_check}""
  user_data                   = ""${var.user_data}""
  elb_publicly_available      = ""${var.no_cdn}""
}

module ""wp-test-asg"" {
  source                      = ""../asg""
  name                        = ""test-${replace(var.domain, ""."", ""-"")}""
  vpc_id                      = ""${var.vpc_id}""
  availability_zones          = ""${var.availability_zones}""
  public_subnets              = ""${var.public_subnets}""
  private_subnets             = ""${var.public_subnets}""
  ami_id                      = ""${data.aws_ami.test.id}""
  instance_type               = ""${var.test_instance_type}""
  maximum_number_of_instances = ""2""
  number_of_instances         = ""1""
  minimum_number_of_instances = ""1""
  rolling_update_batch_size   = ""1""
  elb_instance_port           = ""80""
  internal_sg                 = ""${var.internal_sg}""
  user_data                   = ""${var.user_data}""
  env                         = ""test""
  health_check                = ""${var.health_check}""
}

output ""prod-elb_public_sg_id"" {
  value = ""${module.wp-prod-asg.elb_public_sg_id}""
}

output ""test-elb_public_sg_id"" {
  value = ""${module.wp-test-asg.elb_public_sg_id}""
}


resource ""aws_db_instance"" ""wp-prod"" {
  identifier                 = ""${replace(var.domain, ""."", ""-"")}""
  count                      = ""${var.create_prod_db}""
  allocated_storage          = ""10""
  engine                     = ""mysql""
  engine_version             = ""5.7.11""
  instance_class             = ""${var.prod_rds_instance_type}""
  name                       = ""${replace(var.domain, ""/[^a-z0-9]+/"", """")}""
  username                   = ""${replace(var.domain, ""/[^a-z0-9]+/"", """")}""
  password                   = ""${var.db_pass}""
  backup_retention_period    = ""30""
  backup_window              = ""04:00-04:30""
  maintenance_window         = ""sun:04:30-sun:05:30""
  auto_minor_version_upgrade = true
  vpc_security_group_ids     = [""${aws_security_group.rds.id}"", ""${var.internal_sg}""]
  db_subnet_group_name       = ""${aws_db_subnet_group.wp.name}""
  parameter_group_name       = ""default.mysql5.7""
  multi_az                   = true
  storage_type               = ""gp2""

  tags {
    Name        = ""${replace(var.domain, ""."", """")}""
    Environment = ""prod""
    Role        = ""${var.domain}""
    Mikado      = ""True""
  }
}

resource ""aws_db_subnet_group"" ""wp"" {
  name        = ""${replace(var.domain, ""."", """")}""
  description = ""wp rds""
  subnet_ids  = [""${var.private_subnets}""]
}

resource ""aws_db_instance"" ""wp-test"" {
  apply_immediately          = true
  count                      = ""${var.create_test_db}""
  identifier                 = ""test-${replace(var.domain, ""."", ""-"")}""
  allocated_storage          = ""5""
  engine                     = ""mysql""
  engine_version             = ""5.7.11""
  instance_class             = ""${var.test_rds_instance_type}""
  name                       = ""test${replace(var.domain, ""/[^a-z0-9]+/"", """")}""
  username                   = ""${replace(var.domain, ""/[^a-z0-9]+/"", """")}""
  password                   = ""${var.db_pass}""
  backup_retention_period    = ""30""
  backup_window              = ""04:00-04:30""
  maintenance_window         = ""sun:04:30-sun:05:30""
  auto_minor_version_upgrade = true
  vpc_security_group_ids     = [""${aws_security_group.rds.id}"", ""${var.internal_sg}""]
  db_subnet_group_name       = ""${aws_db_subnet_group.wp.name}""
  parameter_group_name       = ""default.mysql5.7""
  multi_az                   = true
  storage_type               = ""gp2""

  tags {
    Name        = ""test-${replace(var.domain, ""."", """")}""
    Environment = ""test""
    Role        = ""test.${var.domain}""
    Mikado      = ""True""
  }
}


resource ""aws_route53_zone"" ""domain"" {
  name = ""${var.domain}""

  tags {
    Mikado = ""True""
  }
}

resource ""aws_route53_record"" ""apex"" {
  zone_id = ""${aws_route53_zone.domain.zone_id}""
  name    = ""${var.domain}""
  type    = ""A""
  count   = ""${var.no_cdn}""

  alias {
    name                   = ""${module.wp-prod-asg.elb_dns_name}""
    zone_id                = ""${module.wp-prod-asg.elb_zone_id}""
    evaluate_target_health = true
  }
}

resource ""aws_route53_record"" ""www"" {
  zone_id = ""${aws_route53_zone.domain.zone_id}""
  name    = ""www.${var.domain}""
  type    = ""CNAME""
  ttl     = ""300""
  records = [""${var.domain}""]
  count   = ""${var.no_cdn}""
}

resource ""aws_route53_record"" ""origin"" {
  zone_id = ""${aws_route53_zone.domain.zone_id}""
  name    = ""origin.${var.domain}""
  type    = ""A""

  alias {
    name                   = ""${module.wp-prod-asg.elb_dns_name}""
    zone_id                = ""${module.wp-prod-asg.elb_zone_id}""
    evaluate_target_health = true
  }
}

resource ""aws_route53_record"" ""test"" {
  zone_id = ""${aws_route53_zone.domain.zone_id}""
  name    = ""test.${var.domain}""
  type    = ""A""

  alias {
    name                   = ""${module.wp-test-asg.elb_dns_name}""
    zone_id                = ""${module.wp-test-asg.elb_zone_id}""
    evaluate_target_health = true
  }
}

##############
# Internal DNS
##############
resource ""aws_route53_zone"" ""int"" {
  name   = ""int.${var.domain}""
  vpc_id = ""${var.vpc_id}""

  tags {
    Mikado = ""True""
  }
}

resource ""aws_route53_record"" ""int-ns"" {
  zone_id = ""${aws_route53_zone.domain.zone_id}""
  name    = ""int.${var.domain}""
  type    = ""NS""
  ttl     = ""30""

  records = [
    ""${aws_route53_zone.int.name_servers.0}"",
    ""${aws_route53_zone.int.name_servers.1}"",
    ""${aws_route53_zone.int.name_servers.2}"",
    ""${aws_route53_zone.int.name_servers.3}"",
  ]
}

resource ""aws_route53_record"" ""prod-rds"" {
  zone_id = ""${aws_route53_zone.int.zone_id}""
  name    = ""prod.db.int.${var.domain}""
  type    = ""A""
  count   = ""${var.create_prod_db}""

  alias {
    name                   = ""${aws_db_instance.wp-prod.address}""
    zone_id                = ""${aws_db_instance.wp-prod.hosted_zone_id}""
    evaluate_target_health = true
  }
}

resource ""aws_route53_record"" ""test-rds"" {
  zone_id = ""${aws_route53_zone.int.zone_id}""
  name    = ""test.db.int.${var.domain}""
  type    = ""A""

  count = ""${var.create_test_db}""

  alias {
    name                   = ""${aws_db_instance.wp-test.address}""
    zone_id                = ""${aws_db_instance.wp-test.hosted_zone_id}""
    evaluate_target_health = true
  }
}

##########
# Outputs
##########
output ""nameservers"" {
  value = ""${join("", "", aws_route53_zone.domain.name_servers)}""
}

output ""route53_zone_id"" {
  value = ""${aws_route53_zone.domain.zone_id}""
}


","{
  ""userQuery1"": ""The user needs to create a Virtual Private Cloud (VPC) in AWS with specific ID, and within this VPC, they want to set up different availability zones and subnets, both public and private."",
  ""userQuery2"": ""The user intends to set up two types of instances (production and test) for their application, with specific instance types. They also want to create two types of databases (production and test) with specific instance types. The user wants to control whether these databases are created or not."",
  ""userQuery3"": ""The user wants to set up a domain with a specific name and a password for the database. They also want to control the number of instances in the auto-scaling group, with a minimum and maximum limit."",
  ""userQuery4"": ""The user wants to set up a security group for their database and two auto-scaling groups for their application, one for production and one for testing. They"
26,wtsi-hgi,hgi-systems,terraform/modules/studentportal/studentportal-v2,"variable ""env"" {}
variable ""region"" {}
variable ""setup"" {}

variable ""core_context"" {
  type    = ""map""
  default = {}
}

variable ""count"" {}
variable ""flavour"" {}
variable ""domain"" {}

variable ""image"" {
  type = ""map""
}

variable ""network_name"" {
  default = ""main""
}

variable ""keypair_name"" {
  default = ""mercury""
}

variable ""ssh_gateway"" {
  type    = ""map""
  default = {}
}

variable ""extra_ansible_groups"" {
  type    = ""list""
  default = []
}

locals {
  ansible_groups = []

  hostname_format = ""studentportal-%02d""
}

module ""hgi-openstack-instance"" {
  source          = ""../../hgi-openstack-instance/v1""
  env             = ""${var.env}""
  region          = ""${var.region}""
  setup           = ""${var.setup}""
  core_context    = ""${var.core_context}""
  count           = ""${var.count}""
  floating_ip_p   = true
  name_format     = ""${local.hostname_format}""
  domain          = ""${var.domain}""
  flavour         = ""${var.flavour}""
  hostname_format = ""${local.hostname_format}""
  ssh_gateway     = ""${var.ssh_gateway}""
  keypair_name    = ""${var.keypair_name}""
  network_name    = ""${var.network_name}""
  image           = ""${var.image}""

  security_group_names = [
    ""ping"",
    ""ssh"",
    ""http"",
    ""http-cogs"",
  ]

  ansible_groups = ""${distinct(concat(local.ansible_groups, var.extra_ansible_groups))}""
}

output ""hgi_instances"" {
  value = ""${module.hgi-openstack-instance.hgi_instance}""
}


","{
  ""userQuery1"": ""The user wants to create an instance in OpenStack, a cloud computing platform. They want to specify the environment, region, and setup for this instance."",
  ""userQuery2"": ""The user wants to customize the instance with a specific count, flavor, domain, and image. They also want to name the network and keypair associated with the instance."",
  ""userQuery3"": ""The user wants to enable a floating IP for the instance and specify a format for the hostname. They also want to set up a SSH gateway for secure access."",
  ""userQuery4"": ""The user wants to apply certain security group names to the instance, including 'ping', 'ssh', 'http', and 'http-cogs'."",
  ""userQuery5"": ""The user wants to add extra Ansible groups to the instance, which are used for managing configurations and automating tasks."",
  ""userQuery6"": ""The user wants to output the"
27,lander2k2,tectonic-installer,modules/tectonic,"variable ""container_images"" {
  description = ""Container images to use. Leave blank for defaults.""
  type        = ""map""
}

variable ""container_base_images"" {
  description = ""Container base images to use. Leave blank for defaults.""
  type        = ""map""
}

variable ""versions"" {
  description = ""Versions of the components to use. Leave blank for defaults.""
  type        = ""map""
}

variable ""platform"" {
  description = ""Platform on which Tectonic is being installed. Example: bare-metal or aws.""
  type        = ""string""
}

variable ""ingress_kind"" {
  description = ""Type of Ingress mapping to use. Example: HostPort or NodePort.""
  type        = ""string""
}

variable ""license_path"" {
  description = ""Path on disk to your Tectonic license. Obtain this from your Tectonic Account: https://account.coreos.com.""
  type        = ""string""
  default     = ""/Users/coreos/Desktop/tectonic-license.txt""
}

variable ""pull_secret_path"" {
  type        = ""string""
  description = ""Path on disk to your Tectonic pull secret. Obtain this from your Tectonic Account: https://account.coreos.com.""
  default     = ""/Users/coreos/Desktop/config.json""
}

variable ""ca_generated"" {
  description = ""Define whether the CA has been generated or user-provided.""
  type        = ""string""
}

variable ""identity_client_ca_cert"" {
  description = ""A PEM-encoded CA bundle, used to verify identity server.""
  type        = ""string""
}

variable ""identity_server_ca_cert"" {
  description = ""A PEM-encoded CA certificate, used to authenticate identity client.""
  type        = ""string""
}

variable ""base_address"" {
  description = ""Base address used to access the Tectonic Console, without protocol nor trailing forward slash (may contain a port). Example: console.example.com:30000.""
  type        = ""string""
}

variable ""admin_email"" {
  description = ""E-mail address used to log in to the Tectonic Console.""
  type        = ""string""
  default     = ""admin@example.com""
}

variable ""update_server"" {
  description = ""Server contacted to request Tectonic software updates. Leave blank for defaults.""
  type        = ""string""
}

variable ""update_channel"" {
  description = ""Release channel used to request Tectonic software updates. Leave blank for defaults. Example: Tectonic-1.5""
  type        = ""string""
}

variable ""update_app_id"" {
  description = ""Application identifier used to request Tectonic software updates. Leave blank for defaults.""
  type        = ""string""
}

variable ""ingress_ca_cert_pem"" {
  type = ""string""
}

variable ""ingress_cert_pem"" {
  type = ""string""
}

variable ""ingress_key_pem"" {
  type = ""string""
}

variable ""identity_server_cert_pem"" {
  type = ""string""
}

variable ""identity_server_key_pem"" {
  type = ""string""
}

variable ""identity_client_cert_pem"" {
  type = ""string""
}

variable ""identity_client_key_pem"" {
  type = ""string""
}


# Unique Cluster ID (uuid)
resource ""random_id"" ""cluster_id"" {
  byte_length = 16
}

# Kubernetes Manifests (resources/generated/manifests/)
resource ""template_dir"" ""tectonic"" {
  source_dir      = ""${path.module}/resources/manifests""
  destination_dir = ""./generated/tectonic""

  vars {
    addon_resizer_image                        = ""${var.container_images[""addon_resizer""]}""
    kube_core_operator_image                   = ""${var.container_images[""kube_core_operator""]}""
    kubernetes_addon_operator_image            = ""${var.container_images[""kubernetes_addon_operator""]}""
    tectonic_channel_operator_image            = ""${var.container_images[""tectonic_channel_operator""]}""
    tectonic_prometheus_operator_image         = ""${var.container_images[""tectonic_prometheus_operator""]}""
    tectonic_cluo_operator_image               = ""${var.container_images[""tectonic_cluo_operator""]}""
    tectonic_alm_operator_image                = ""${var.container_images[""tectonic_alm_operator""]}""
    tectonic_ingress_controller_operator_image = ""${var.container_images[""tectonic_ingress_controller_operator""]}""
    tectonic_utility_operator_image            = ""${var.container_images[""tectonic_utility_operator""]}""

    tectonic_monitoring_auth_base_image = ""${var.container_base_images[""tectonic_monitoring_auth""]}""
    config_reload_base_image            = ""${var.container_base_images[""config_reload""]}""
    addon_resizer_base_image            = ""${var.container_base_images[""addon_resizer""]}""
    kube_state_metrics_base_image       = ""${var.container_base_images[""kube_state_metrics""]}""
    prometheus_operator_base_image      = ""${var.container_base_images[""prometheus_operator""]}""
    prometheus_config_reload_base_image = ""${var.container_base_images[""prometheus_config_reload""]}""
    prometheus_base_image               = ""${var.container_base_images[""prometheus""]}""
    alertmanager_base_image             = ""${var.container_base_images[""alertmanager""]}""
    node_exporter_base_image            = ""${var.container_base_images[""node_exporter""]}""
    grafana_base_image                  = ""${var.container_base_images[""grafana""]}""
    grafana_watcher_base_image          = ""${var.container_base_images[""grafana_watcher""]}""
    kube_rbac_proxy_base_image          = ""${var.container_base_images[""kube_rbac_proxy""]}""

    monitoring_version             = ""${var.versions[""monitoring""]}""
    tectonic_version               = ""${var.versions[""tectonic""]}""
    tectonic_cluo_operator_version = ""${var.versions[""cluo""]}""
    tectonic_alm_operator_version  = ""${var.versions[""alm""]}""

    license     = ""${base64encode(file(var.license_path))}""
    pull_secret = ""${base64encode(file(var.pull_secret_path))}""

    update_server  = ""${var.update_server}""
    update_channel = ""${var.update_channel}""
    update_app_id  = ""${var.update_app_id}""

    admin_email = ""${lower(var.admin_email)}""

    base_address = ""${var.base_address}""

    ingress_ca_cert  = ""${base64encode(var.ingress_ca_cert_pem)}""
    ingress_tls_cert = ""${base64encode(var.ingress_cert_pem)}""
    ingress_tls_key  = ""${base64encode(var.ingress_key_pem)}""

    identity_server_tls_cert = ""${base64encode(var.identity_server_cert_pem)}""
    identity_server_tls_key  = ""${base64encode(var.identity_server_key_pem)}""
    identity_server_ca_cert  = ""${base64encode(var.identity_server_ca_cert)}""
    identity_client_tls_cert = ""${base64encode(var.identity_client_cert_pem)}""
    identity_client_tls_key  = ""${base64encode(var.identity_client_key_pem)}""
    identity_client_ca_cert  = ""${base64encode(var.identity_client_ca_cert)}""

    platform = ""${var.platform}""
  }
}

# tectonic.sh (resources/generated/tectonic.sh)
data ""template_file"" ""tectonic"" {
  template = ""${file(""${path.module}/resources/tectonic.sh"")}""

  vars {
    ingress_kind = ""${var.ingress_kind}""
  }
}

resource ""local_file"" ""tectonic"" {
  content  = ""${data.template_file.tectonic.rendered}""
  filename = ""./generated/tectonic.sh""
}

# tectonic.sh (resources/generated/tectonic-wrapper.sh)
data ""template_file"" ""tectonic_wrapper"" {
  template = ""${file(""${path.module}/resources/tectonic-wrapper.sh"")}""

  vars {
    hyperkube_image = ""${var.container_images[""hyperkube""]}""
  }
}

resource ""local_file"" ""tectonic_wrapper"" {
  content  = ""${data.template_file.tectonic_wrapper.rendered}""
  filename = ""./generated/tectonic-wrapper.sh""
}

# tectonic.service (available as output variable)
data ""template_file"" ""tectonic_service"" {
  template = ""${file(""${path.module}/resources/tectonic.service"")}""
}

data ""ignition_systemd_unit"" ""tectonic_service"" {
  name    = ""tectonic.service""
  enabled = false
  content = ""${data.template_file.tectonic_service.rendered}""
}

# tectonic.path (available as output variable)
data ""template_file"" ""tectonic_path"" {
  template = ""${file(""${path.module}/resources/tectonic.path"")}""
}

data ""ignition_systemd_unit"" ""tectonic_path"" {
  name    = ""tectonic.path""
  enabled = true
  content = ""${data.template_file.tectonic_path.rendered}""
}


# Cryptographically-secure ramdon strings used by various components.

resource ""random_id"" ""admin_user_id"" {
  byte_length = 16
}

resource ""random_id"" ""kubectl_secret"" {
  byte_length = 16
}

resource ""random_id"" ""console_secret"" {
  byte_length = 16
}

resource ""random_id"" ""tectonic_monitoring_auth_cookie_secret"" {
  byte_length = 16
}


# This output is meant to be used to inject a dependency on the generated
# assets. As of Terraform v0.9, it is difficult to make a module depend on
# another module (no depends_on, no triggers), or to make a data source
# depend on a module (no depends_on, no triggers, generally no dummy variable).
#
# For instance, using the 'archive_file' data source against the generated
# assets, which is a common use-case, is tricky. There is no mechanism for
# defining explicit dependencies and the only available variables are for the
# source, destination and archive type, leaving little opportunities for us to
# inject a dependency. Thanks to the property described below, this output can
# be used as part of the output filename, in order to enforce the creation of
# the archive after the assets have been properly generated.
#
# Both localfile and template_dir providers compute their IDs by hashing
# the content of the resources on disk. Because this output is computed from the
# combination of all the resources' IDs, it can't be guessed and can only be
# interpolated once the assets have all been created.
output ""id"" {
  value = ""${sha1(""${template_dir.tectonic.id} ${local_file.tectonic.id}"")}""
}

output ""systemd_service_rendered"" {
  value = ""${data.template_file.tectonic_service.rendered}""
}

output ""systemd_service_id"" {
  value = ""${data.ignition_systemd_unit.tectonic_service.id}""
}

output ""systemd_path_unit_rendered"" {
  value = ""${data.template_file.tectonic_path.rendered}""
}

output ""systemd_path_unit_id"" {
  value = ""${data.ignition_systemd_unit.tectonic_path.id}""
}

output ""cluster_id"" {
  value = ""${format(
    ""%s-%s-%s-%s-%s"",
    substr(random_id.cluster_id.hex, 0, 8),
    substr(random_id.cluster_id.hex, 8, 4),
    substr(random_id.cluster_id.hex, 12, 4),
    substr(random_id.cluster_id.hex, 16, 4),
    substr(random_id.cluster_id.hex, 20, 12)
  )}""
}


","{
  ""userQuery1"": ""The user needs to deploy a Tectonic platform on a specific platform (like bare-metal or AWS). They want to specify the container images, base images, and versions of the components to use, but also want the option to leave these blank for defaults."",
  ""userQuery2"": ""The user wants to specify the type of Ingress mapping to use, the path to their Tectonic license and pull secret, and whether the CA has been generated or user-provided. They also want to specify the base address to access the Tectonic Console, the email address to log in to the Tectonic Console, and the server, channel, and application ID for Tectonic software updates."",
  ""userQuery3"": ""The user wants to generate a unique cluster ID and Kubernetes manifests. They also want to create a tectonic.sh file and a tectonic-wrapper.sh file. They want to specify the Ingress CA certificate,"
28,estroz,tectonic-installer,modules/azure/vnet,"variable ""tectonic_azure_external_vnet_id"" {
  type    = ""string""
  default = """"
}

variable ""tectonic_azure_vnet_cidr_block"" {
  type    = ""string""
  default = ""10.0.0.0/16""
}

variable ""tectonic_cluster_name"" {
  type = ""string""
}

variable ""resource_group_name"" {
  type = ""string""
}

variable ""vnet_cidr_block"" {
  type = ""string""
}

variable ""location"" {
  type = ""string""
}

variable ""external_vnet_name"" {
  type    = ""string""
  default = """"
}

variable ""external_master_subnet_id"" {
  type    = ""string""
  default = """"
}

variable ""external_worker_subnet_id"" {
  type    = ""string""
  default = """"
}

variable ""etcd_cidr"" {
  type    = ""string""
  default = """"
}

variable ""etcd_count"" {
  type    = ""string""
  default = """"
}

variable ""master_cidr"" {
  type    = ""string""
  default = """"
}

variable ""worker_cidr"" {
  type    = ""string""
  default = """"
}

variable ""ssh_network_internal"" {
  type    = ""string""
  default = """"
}

variable ""ssh_network_external"" {
  type    = ""string""
  default = """"
}

variable ""external_resource_group"" {
  type = ""string""
}

variable ""external_nsg_etcd"" {
  type    = ""string""
  default = """"
}

variable ""external_nsg_api"" {
  type    = ""string""
  default = """"
}

variable ""external_nsg_master"" {
  type    = ""string""
  default = """"
}

variable ""external_nsg_worker"" {
  type    = ""string""
  default = """"
}


resource ""azurerm_virtual_network"" ""tectonic_vnet"" {
  count               = ""${var.external_vnet_name == """" ? 1 :0 }""
  name                = ""${var.tectonic_cluster_name}""
  resource_group_name = ""${var.resource_group_name}""
  address_space       = [""${var.vnet_cidr_block}""]
  location            = ""${var.location}""
}

resource ""azurerm_subnet"" ""master_subnet"" {
  count                     = ""${var.external_vnet_name == """" ? 1 : 0}""
  name                      = ""${var.tectonic_cluster_name}_master_subnet""
  resource_group_name       = ""${var.resource_group_name}""
  virtual_network_name      = ""${var.external_vnet_name == """" ? join("""",azurerm_virtual_network.tectonic_vnet.*.name) : var.external_vnet_name }""
  address_prefix            = ""${cidrsubnet(var.vnet_cidr_block, 4, 0)}""
  network_security_group_id = ""${azurerm_network_security_group.master.id}""
}

resource ""azurerm_subnet"" ""worker_subnet"" {
  count                     = ""${var.external_vnet_name == """" ? 1 : 0}""
  name                      = ""${var.tectonic_cluster_name}_worker_subnet""
  resource_group_name       = ""${var.resource_group_name}""
  virtual_network_name      = ""${var.external_vnet_name == """" ? join("""",azurerm_virtual_network.tectonic_vnet.*.name) : var.external_vnet_name }""
  address_prefix            = ""${cidrsubnet(var.vnet_cidr_block, 4, 1)}""
  network_security_group_id = ""${azurerm_network_security_group.worker.id}""
}


resource ""azurerm_network_security_group"" ""cluster_default"" {
  name                = ""${var.tectonic_cluster_name}""
  location            = ""${var.location}""
  resource_group_name = ""${var.resource_group_name}""

  # TODO: enable all inbound traffic to make debugging easier
  security_rule {
    name                       = ""cluster_default_ingress""
    priority                   = 4000
    direction                  = ""Inbound""
    access                     = ""Allow""
    protocol                   = ""*""
    source_port_range          = ""*""
    destination_port_range     = ""*""
    source_address_prefix      = ""*""
    destination_address_prefix = ""*""
  }

  # Allow horizontal traffic in the vnet
  security_rule {
    name                       = ""cluster_default_internal""
    priority                   = 4050
    direction                  = ""Inbound""
    access                     = ""Allow""
    protocol                   = ""*""
    source_port_range          = ""*""
    destination_port_range     = ""*""
    source_address_prefix      = ""VirtualNetwork""
    destination_address_prefix = ""VirtualNetwork""
  }

  # Allow internet outbound for all machines
  security_rule {
    name                       = ""cluster_default_egress""
    priority                   = 4051
    direction                  = ""Outbound""
    access                     = ""Allow""
    protocol                   = ""*""
    source_port_range          = ""*""
    destination_port_range     = ""*""
    source_address_prefix      = ""*""
    destination_address_prefix = ""*""
  }
}


resource ""azurerm_network_security_group"" ""etcd"" {
  count               = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                = ""${var.tectonic_cluster_name}-etcd""
  location            = ""${var.location}""
  resource_group_name = ""${var.resource_group_name}""
}

resource ""azurerm_network_security_rule"" ""etcd_egress"" {
  count                       = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-etcd_egress""
  priority                    = 2000
  direction                   = ""Outbound""
  access                      = ""Allow""
  protocol                    = ""*""
  source_port_range           = ""*""
  destination_port_range      = ""*""
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}

resource ""azurerm_network_security_rule"" ""etcd_ingress_ssh"" {
  count                       = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-etcd_ingress_ssh""
  priority                    = 400
  direction                   = ""Inbound""
  access                      = ""Allow""
  protocol                    = ""tcp""
  source_port_range           = ""*""
  destination_port_range      = ""22""
  source_address_prefix       = ""${var.ssh_network_internal}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}

# TODO: Add external SSH rule
resource ""azurerm_network_security_rule"" ""etcd_ingress_ssh_admin"" {
  count                       = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-etcd_ingress_ssh_admin""
  priority                    = 405
  direction                   = ""Inbound""
  access                      = ""Allow""
  protocol                    = ""tcp""
  source_port_range           = ""*""
  destination_port_range      = ""22""
  source_address_prefix       = ""${var.ssh_network_external}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}

resource ""azurerm_network_security_rule"" ""etcd_ingress_ssh_self"" {
  count                  = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-etcd_ingress_ssh_self""
  priority               = 410
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""22""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}

resource ""azurerm_network_security_rule"" ""etcd_ingress_ssh_from_master"" {
  count                  = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-etcd_ingress_services_from_console""
  priority               = 415
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""22""

  # TODO: Need to allow traffic from master
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}

resource ""azurerm_network_security_rule"" ""etcd_ingress_client_self"" {
  count                  = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-etcd_ingress_client_self""
  priority               = 420
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""2379""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}

resource ""azurerm_network_security_rule"" ""etcd_ingress_client_master"" {
  count                  = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-etcd_ingress_client_master""
  priority               = 425
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""2379""

  # TODO: Need to allow traffic from master
  source_address_prefix       = ""*""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}

resource ""azurerm_network_security_rule"" ""etcd_ingress_client_worker"" {
  count                  = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-etcd_ingress_client_worker""
  priority               = 430
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""2379""

  # TODO: Need to allow traffic from workers
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}

resource ""azurerm_network_security_rule"" ""etcd_ingress_peer"" {
  count                  = ""${var.external_nsg_etcd == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-etcd_ingress_peer""
  priority               = 435
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""2380""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.etcd.name}""
}


resource ""azurerm_network_interface"" ""etcd_nic"" {
  count                     = ""${var.etcd_count}""
  name                      = ""${var.tectonic_cluster_name}-etcd-nic-${count.index}""
  location                  = ""${var.location}""
  network_security_group_id = ""${azurerm_network_security_group.etcd_group.id}""
  resource_group_name       = ""${var.resource_group_name}""

  ip_configuration {
    name                                    = ""tectonic_etcd_configuration""
    subnet_id                               = ""${var.external_vnet_name == """" ?  join("" "", azurerm_subnet.master_subnet.*.id) : var.external_master_subnet_id }""
    private_ip_address_allocation           = ""dynamic""
    load_balancer_backend_address_pools_ids = [""${azurerm_lb_backend_address_pool.etcd-lb.id}""]
  }
}

resource ""azurerm_network_security_group"" ""etcd_group"" {
  name                = ""${var.tectonic_cluster_name}-etcd""
  location            = ""${var.location}""
  resource_group_name = ""${var.resource_group_name}""

  security_rule {
    name                       = ""ssh""
    source_port_range          = ""*""
    destination_port_range     = 22
    protocol                   = ""Tcp""
    destination_address_prefix = ""0.0.0.0/0""
    source_address_prefix      = ""VirtualNetwork""
    access                     = ""Allow""
    priority                   = ""100""
    direction                  = ""Inbound""
  }

  security_rule {
    name                       = ""etcd-client-perr""
    source_port_range          = ""*""
    destination_port_range     = ""2379-2380""
    protocol                   = ""Tcp""
    destination_address_prefix = ""0.0.0.0/0""
    source_address_prefix      = ""VirtualNetwork""
    access                     = ""Allow""
    priority                   = ""101""
    direction                  = ""Inbound""
  }

  security_rule {
    name                       = ""all-in""
    source_port_range          = ""*""
    destination_port_range     = ""*""
    protocol                   = ""*""
    destination_address_prefix = ""0.0.0.0/0""
    source_address_prefix      = ""0.0.0.0/0""
    access                     = ""Allow""
    priority                   = ""103""
    direction                  = ""Inbound""
  }

  security_rule {
    name                       = ""all-out""
    source_port_range          = ""*""
    destination_port_range     = ""*""
    protocol                   = ""*""
    destination_address_prefix = ""Internet""
    source_address_prefix      = ""0.0.0.0/0""
    access                     = ""Allow""
    priority                   = ""104""
    direction                  = ""Outbound""
  }
}

resource ""azurerm_lb"" ""tectonic_etcd_lb"" {
  name                = ""${var.tectonic_cluster_name}-etcd-lb""
  location            = ""${var.location}""
  resource_group_name = ""${var.resource_group_name}""

  frontend_ip_configuration {
    name = ""default""

    public_ip_address_id          = ""${azurerm_public_ip.etcd_publicip.id}""
    private_ip_address_allocation = ""dynamic""
  }
}

resource ""azurerm_public_ip"" ""etcd_publicip"" {
  name                         = ""${var.tectonic_cluster_name}_etcd_publicip""
  location                     = ""${var.location}""
  resource_group_name          = ""${var.resource_group_name}""
  public_ip_address_allocation = ""static""
  domain_name_label            = ""${var.tectonic_cluster_name}-etcd""
}

resource ""azurerm_lb_rule"" ""etcd-lb"" {
  name                           = ""${var.tectonic_cluster_name}-etcd-lb-rule-client""
  resource_group_name            = ""${var.resource_group_name}""
  loadbalancer_id                = ""${azurerm_lb.tectonic_etcd_lb.id}""
  backend_address_pool_id        = ""${azurerm_lb_backend_address_pool.etcd-lb.id}""
  probe_id                       = ""${azurerm_lb_probe.etcd-lb.id}""
  protocol                       = ""tcp""
  frontend_port                  = 2379
  backend_port                   = 2379
  frontend_ip_configuration_name = ""default""
}

resource ""azurerm_lb_probe"" ""etcd-lb"" {
  name                = ""${var.tectonic_cluster_name}-etcd-lb-probe""
  loadbalancer_id     = ""${azurerm_lb.tectonic_etcd_lb.id}""
  resource_group_name = ""${var.resource_group_name}""
  protocol            = ""Tcp""
  port                = 2379
}

resource ""azurerm_lb_backend_address_pool"" ""etcd-lb"" {
  name                = ""${var.tectonic_cluster_name}-etcd-lb-pool""
  resource_group_name = ""${var.resource_group_name}""
  loadbalancer_id     = ""${azurerm_lb.tectonic_etcd_lb.id}""
}


resource ""azurerm_network_security_rule"" ""alb_probe"" {
  count                       = ""${var.external_nsg_api == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-alb_probe""
  priority                    = 295
  direction                   = ""Inbound""
  access                      = ""Allow""
  protocol                    = ""tcp""
  source_port_range           = ""*""
  destination_port_range      = ""*""
  source_address_prefix       = ""AzureLoadBalancer""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.api.name}""
}

resource ""azurerm_network_security_group"" ""api"" {
  count               = ""${var.external_nsg_api == """" ? 1 : 0}""
  name                = ""${var.tectonic_cluster_name}-api""
  location            = ""${var.location}""
  resource_group_name = ""${var.resource_group_name}""
}

resource ""azurerm_network_security_rule"" ""api_egress"" {
  count                       = ""${var.external_nsg_api == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-api_egress""
  priority                    = 1990
  direction                   = ""Outbound""
  access                      = ""Allow""
  protocol                    = ""*""
  source_port_range           = ""*""
  destination_port_range      = ""*""
  source_address_prefix       = ""*""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.api.name}""
}

resource ""azurerm_network_security_rule"" ""api_ingress_https"" {
  count                       = ""${var.external_nsg_api == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-api_ingress_https""
  priority                    = 300
  direction                   = ""Inbound""
  access                      = ""Allow""
  protocol                    = ""tcp""
  source_port_range           = ""*""
  destination_port_range      = ""443""
  source_address_prefix       = ""*""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.api.name}""
}

resource ""azurerm_network_security_group"" ""console"" {
  count               = ""${var.external_nsg_api == """" ? 1 : 0}""
  name                = ""${var.tectonic_cluster_name}-console""
  location            = ""${var.location}""
  resource_group_name = ""${var.resource_group_name}""
}

resource ""azurerm_network_security_rule"" ""console_egress"" {
  count                       = ""${var.external_nsg_api == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-console_egress""
  priority                    = 1995
  direction                   = ""Outbound""
  access                      = ""Allow""
  protocol                    = ""*""
  source_port_range           = ""*""
  destination_port_range      = ""*""
  source_address_prefix       = ""*""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.console.name}""
}

resource ""azurerm_network_security_rule"" ""console_ingress_https"" {
  count                       = ""${var.external_nsg_api == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-console_ingress_https""
  priority                    = 305
  direction                   = ""Inbound""
  access                      = ""Allow""
  protocol                    = ""tcp""
  source_port_range           = ""*""
  destination_port_range      = ""443""
  source_address_prefix       = ""*""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.console.name}""
}

resource ""azurerm_network_security_rule"" ""console_ingress_http"" {
  count                       = ""${var.external_nsg_api == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-console_ingress_http""
  priority                    = 310
  direction                   = ""Inbound""
  access                      = ""Allow""
  protocol                    = ""tcp""
  source_port_range           = ""*""
  destination_port_range      = ""80""
  source_address_prefix       = ""*""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.console.name}""
}


resource ""azurerm_network_security_group"" ""master"" {
  count               = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                = ""${var.tectonic_cluster_name}-master""
  location            = ""${var.location}""
  resource_group_name = ""${var.resource_group_name}""
}

resource ""azurerm_network_security_rule"" ""master_egress"" {
  count                       = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-master_egress""
  priority                    = 2005
  direction                   = ""Outbound""
  access                      = ""Allow""
  protocol                    = ""*""
  source_port_range           = ""*""
  destination_port_range      = ""*""
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_ssh"" {
  count                       = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-master_ingress_ssh""
  priority                    = 500
  direction                   = ""Inbound""
  access                      = ""Allow""
  protocol                    = ""tcp""
  source_port_range           = ""*""
  destination_port_range      = ""22""
  source_address_prefix       = ""${var.ssh_network_internal}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

# TODO: Add external SSH rule
resource ""azurerm_network_security_rule"" ""master_ingress_ssh_admin"" {
  count                       = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                        = ""${var.tectonic_cluster_name}-master_ingress_ssh_admin""
  priority                    = 505
  direction                   = ""Inbound""
  access                      = ""Allow""
  protocol                    = ""tcp""
  source_port_range           = ""*""
  destination_port_range      = ""22""
  source_address_prefix       = ""${var.ssh_network_external}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_flannel"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_flannel""
  priority               = 510
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""udp""
  source_port_range      = ""*""
  destination_port_range = ""4789""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_flannel_from_worker"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_flannel_from_worker""
  priority               = 515
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""udp""
  source_port_range      = ""*""
  destination_port_range = ""4789""

  # TODO: Need to allow traffic from worker
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

# TODO: Add rule(s) for Tectonic ingress

resource ""azurerm_network_security_rule"" ""master_ingress_node_exporter"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_node_exporter""
  priority               = 520
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""9100""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_node_exporter_from_worker"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_node_exporter_from_worker""
  priority               = 525
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""9100""

  # TODO: Need to allow traffic from worker
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_services"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_services""
  priority               = 530
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""30000-32767""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""VirtualNetwork""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_services_from_console"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_services_from_console""
  priority               = 535
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""30000-32767""

  # TODO: Need to allow traffic from console
  source_address_prefix       = ""*""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_etcd_lb"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_etcd""
  priority               = 540
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""2379""

  source_address_prefix       = ""*""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_etcd_self"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_etcd_self""
  priority               = 545
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""2379-2380""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_bootstrap_etcd"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_bootstrap_etcd""
  priority               = 550
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""12379-12380""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_kubelet_insecure"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_kubelet_insecure""
  priority               = 555
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""10250""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_kubelet_insecure_from_worker"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_kubelet_insecure_from_worker""
  priority               = 560
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""10250""

  # TODO: Need to allow traffic from worker
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_network_security_rule"" ""master_ingress_kubelet_secure"" {
  count                  = ""${var.external_nsg_master == """" ? 1 : 0}""
  name                   = ""${var.tectonic_cluster_name}-master_ingress_kubelet_secure""
  priority               = 565
  direction              = ""Inbound""
  access                 = ""Allow""
  protocol               = ""tcp""
  source_port_range      = ""*""
  destination_port_range = ""10255""

  # TODO: Need to allow traffic from self
  source_address_prefix       = ""${var.vnet_cidr_block}""
  destination_address_prefix  = ""*""
  resource_group_name         = ""${var.external_resource_group == """" ? var.resource_group_name : var.external_resource_group}""
  network_security_group_name = ""${azurerm_network_security_group.master.name}""
}

resource ""azurerm_net",
"ork_sec""","{
  ""userQuery1"": ""The user wants to create a virtual network in Azure with a specific CIDR block and location. The network's name and resource group name are also specified."",
  ""userQuery2"": ""The user wants to create two subnets within the virtual network, one for master nodes and one for worker nodes. Each subnet should be associated with a specific network security group."",
  ""userQuery3"": ""The user wants to create several network security groups with specific rules for inbound and outbound traffic. These groups are associated with different components of the network, such as the API, console, master nodes, and etcd nodes."",
  ""userQuery4"": ""The user wants to create a load balancer for the etcd nodes, with a specific backend address pool and probe configuration. The load balancer should be associated with a public IP address."",
  ""userQuery5"": ""The user wants to create a network interface for each etcd node, which should",,,,
29,atsaki,Apollo,terraform/digitalocean,"provider ""digitalocean"" {
  token = ""${var.do_token}""
}



variable ""key_file"" {
  description = ""The ssh public key for using with the cloud provider.""
  default = """"
}

variable ""do_token"" {
  description = ""The Digital Ocean token.""
  default = """"
}

variable ""region"" {
  description = ""The Digital Ocean region to create resources in.""
  default = ""lon1""
}

variable ""masters"" {
  description = ""The number of masters.""
  default = ""3""
}

variable ""slaves"" {
  description = ""The number of slaves.""
  default = ""1""
}

variable ""instance_type"" {
  default = {
    master = ""512mb""
    slave  = ""512mb""
  }
}

variable ""atlas_artifact"" {
  default = {
    master = ""capgemini/apollo-ubuntu-14.04-amd64""
    slave  = ""capgemini/apollo-ubuntu-14.04-amd64""
  }
}

variable ""atlas_artifact_version"" {
  default = {
    master = ""1""
    slave  = ""1""
  }
}


/* Create a new SSH key */
resource ""digitalocean_ssh_key"" ""default"" {
    name = ""Apollo""
    public_key = ""${file(var.key_file)}""
}

/* Base packer build we use for provisioning master instances */
resource ""atlas_artifact"" ""mesos-master"" {
  name    = ""${var.atlas_artifact.master}""
  type    = ""digitalocean.image""
  version = ""${var.atlas_artifact_version.master}""
}

/* Mesos master instances */
resource ""digitalocean_droplet"" ""mesos-master"" {
  image              = ""${atlas_artifact.mesos-master.id}""
  region             = ""${var.region}""
  count              = ""${var.masters}""
  name               = ""apollo-mesos-master-${count.index}""
  size               = ""${var.instance_type.master}""
  depends_on         = [""digitalocean_ssh_key.default""]
  private_networking = true
  user_data          = ""{role: mesos_masters}""
  ssh_keys = [
    ""${digitalocean_ssh_key.default.id}""
  ]
}


/* Base packer build we use for provisioning master instances */
resource ""atlas_artifact"" ""mesos-slave"" {
  name    = ""${var.atlas_artifact.slave}""
  type    = ""digitalocean.image""
  version = ""${var.atlas_artifact_version.slave}""
}

/* Mesos slave instances */
resource ""digitalocean_droplet"" ""mesos-slave"" {
  image              = ""${atlas_artifact.mesos-slave.id}""
  region             = ""${var.region}""
  count              = ""${var.slaves}""
  name               = ""apollo-mesos-slave-${count.index}""
  size               = ""${var.instance_type.slave}""
  depends_on         = [""digitalocean_droplet.mesos-master""]
  private_networking = true
  user_data          = ""{role: mesos_slaves}""
  ssh_keys = [
    ""${digitalocean_ssh_key.default.id}""
  ]
}


output ""master.1.ip"" {
  value = ""${digitalocean_droplet.mesos-master.0.ipv4_address}""
}
output ""master.2.ip"" {
  value = ""${digitalocean_droplet.mesos-master.1.ipv4_address}""
}
output ""master.3.ip"" {
  value = ""${digitalocean_droplet.mesos-master.2.ipv4_address}""
}
output ""master_ips"" {
   value = ""${join("","", digitalocean_droplet.mesos-master.*.ipv4_address)}""
}
output ""slave_ips"" {
   value = ""${join("","", digitalocean_droplet.mesos-slave.*.ipv4_address)}""
}


","{
  ""userQuery1"": ""The user wants to create a set of virtual machines on Digital Ocean. They want to specify the number of 'master' and 'slave' machines, the region where these machines will be hosted, and the type of instance for each machine. They also want to use a specific SSH key for these machines, and they want to provide a token for authenticating with Digital Ocean."",
  ""userQuery2"": ""The user wants to use specific images for the 'master' and 'slave' machines. These images are specified by the 'atlas_artifact' and 'atlas_artifact_version' variables. The user wants to ensure that the 'slave' machines are only created after the 'master' machines."",
  ""userQuery3"": ""The user wants to retrieve the IP addresses of the 'master' and 'slave' machines after they have been created. They want these IP addresses to be outputted in a specific format.""
}"
30,terraform-google-modules,docs-examples,health_check_http2_full,"resource ""google_compute_health_check"" ""http2-health-check"" {
  name        = ""http2-health-check-${local.name_suffix}""
  description = ""Health check via http2""

  timeout_sec         = 1
  check_interval_sec  = 1
  healthy_threshold   = 4
  unhealthy_threshold = 5

  http2_health_check {
    port_name          = ""health-check-port""
    port_specification = ""USE_NAMED_PORT""
    host               = ""1.2.3.4""
    request_path       = ""/mypath""
    proxy_header       = ""NONE""
    response           = ""I AM HEALTHY""
  }
}


# This file has some scaffolding to make sure that names are unique and that
# a region and zone are selected when you try to create your Terraform resources.

locals {
  name_suffix = ""${random_pet.suffix.id}""
}

resource ""random_pet"" ""suffix"" {
  length = 2
}

provider ""google"" {
  region = ""us-central1""
  zone   = ""us-central1-c""
}


","{
  ""userQuery1"": ""The user wants to create a health check for a Google Compute Engine instance using HTTP2 protocol. The health check is named 'http2-health-check' followed by a unique suffix. The health check is set to timeout after 1 second, check every 1 second, and requires 4 successful checks to be considered healthy and 5 failed checks to be considered unhealthy. The health check is set to use a named port 'health-check-port' and the host is '1.2.3.4'. The request path for the health check is '/mypath' and it does not use a proxy header. The expected response from the health check is 'I AM HEALTHY'."",
  ""userQuery2"": ""The user wants to generate a unique suffix for the health check name using a random pet name with a length of 2."",
  ""userQuery3"": ""The user wants to use the Google Cloud provider and set the region and zone"
31,GoogleCloudPlatform,training-data-analyst,courses/ahybrid/v1.0/AHYBRID021/terraform/modules/iam,"terraform {
  required_version = "">= 0.12.23""
  required_providers {
    aws = {
      source = ""hashicorp/aws""
    }
  }
}

# Create Anthos Multi-Cloud API role
# https://cloud.google.com/anthos/clusters/docs/multi-cloud/aws/how-to/create-aws-iam-roles

data ""aws_iam_policy_document"" ""api_assume_role_policy_document"" {
  statement {
    effect = ""Allow""
    principals {
      type        = ""Federated""
      identifiers = [""accounts.google.com""]
    }
    actions = [""sts:AssumeRoleWithWebIdentity""]
    condition {
      test     = ""StringEquals""
      variable = ""accounts.google.com:sub""
      values = [
        ""service-${var.gcp_project_number}@gcp-sa-gkemulticloud.iam.gserviceaccount.com""
      ]
    }
  }
}
resource ""aws_iam_role"" ""api_role"" {
  name = ""${var.anthos_prefix}-anthos-api-role""

  description        = ""IAM role for OnePlatform service backend""
  assume_role_policy = data.aws_iam_policy_document.api_assume_role_policy_document.json

}

data ""aws_iam_policy_document"" ""api_policy_document"" {
  statement {
    effect = ""Allow""
    actions = [
      ""ec2:AuthorizeSecurityGroupEgress"",
      ""ec2:AuthorizeSecurityGroupIngress"",
      ""ec2:CreateLaunchTemplate"",
      ""ec2:CreateNetworkInterface"",
      ""ec2:CreateSecurityGroup"",
      ""ec2:CreateTags"",
      ""ec2:CreateVolume"",
      ""ec2:DeleteLaunchTemplate"",
      ""ec2:DeleteNetworkInterface"",
      ""ec2:DeleteSecurityGroup"",
      ""ec2:DeleteTags"",
      ""ec2:DeleteVolume"",
      ""ec2:DescribeAccountAttributes"",
      ""ec2:DescribeInstances"",
      ""ec2:DescribeInternetGateways"",
      ""ec2:DescribeKeyPairs"",
      ""ec2:DescribeLaunchTemplates"",
      ""ec2:DescribeNetworkInterfaces"",
      ""ec2:DescribeSecurityGroupRules"",
      ""ec2:DescribeSecurityGroups"",
      ""ec2:DescribeSubnets"",
      ""ec2:DescribeVpcs"",
      ""ec2:GetConsoleOutput"",
      ""ec2:ModifyNetworkInterfaceAttribute"",
      ""ec2:ModifyInstanceAttribute"",
      ""ec2:RevokeSecurityGroupEgress"",
      ""ec2:RevokeSecurityGroupIngress"",
      ""ec2:RunInstances"",
      ""iam:AWSServiceName"",
      ""iam:CreateServiceLinkedRole"",
      ""iam:PassRole"",
      ""autoscaling:CreateAutoScalingGroup"",
      ""autoscaling:CreateOrUpdateTags"",
      ""autoscaling:DeleteAutoScalingGroup"",
      ""autoscaling:DeleteTags"",
      ""autoscaling:DescribeAutoScalingGroups"",
      ""autoscaling:DisableMetricsCollection"",
      ""autoscaling:EnableMetricsCollection"",
      ""autoscaling:TerminateInstanceInAutoScalingGroup"",
      ""autoscaling:UpdateAutoScalingGroup"",
      ""elasticloadbalancing:AddTags"",
      ""elasticloadbalancing:CreateListener"",
      ""elasticloadbalancing:CreateLoadBalancer"",
      ""elasticloadbalancing:CreateTargetGroup"",
      ""elasticloadbalancing:DeleteListener"",
      ""elasticloadbalancing:DeleteLoadBalancer"",
      ""elasticloadbalancing:DeleteTargetGroup"",
      ""elasticloadbalancing:DescribeListeners"",
      ""elasticloadbalancing:DescribeLoadBalancers"",
      ""elasticloadbalancing:DescribeTargetGroups"",
      ""elasticloadbalancing:DescribeTargetHealth"",
      ""elasticloadbalancing:ModifyTargetGroupAttributes"",
      ""elasticloadbalancing:RemoveTags"",
      ""kms:DescribeKey"",
      ""kms:Encrypt"",
      ""kms:GenerateDataKeyWithoutPlaintext""
    ]
    resources = [""*""]
  }
}
resource ""aws_iam_policy"" ""api_policy"" {
  name   = ""${var.anthos_prefix}-anthos-api-policy""
  path   = ""/""
  policy = data.aws_iam_policy_document.api_policy_document.json
}
# Step 3 in doc
resource ""aws_iam_role_policy_attachment"" ""api_role_policy_attachment"" {
  role       = aws_iam_role.api_role.name
  policy_arn = aws_iam_policy.api_policy.arn
}


# Create the control plane role
# https://cloud.google.com/anthos/clusters/docs/multi-cloud/aws/how-to/create-aws-iam-roles#create_the_control_plane_role

data ""aws_iam_policy_document"" ""cp_assume_role_policy_document"" {
  statement {
    effect = ""Allow""
    principals {
      type        = ""Service""
      identifiers = [""ec2.amazonaws.com""]
    }
    actions = [""sts:AssumeRole""]
  }
}
resource ""aws_iam_role"" ""cp_role"" {
  name               = ""${var.anthos_prefix}-anthos-cp-role""
  description        = ""IAM role for the control plane""
  assume_role_policy = data.aws_iam_policy_document.cp_assume_role_policy_document.json

}

data ""aws_iam_policy_document"" ""cp_policy_document"" {
  statement {
    effect = ""Allow""
    actions = [
      ""ec2:AttachNetworkInterface"",
      ""ec2:AttachVolume"",
      ""ec2:AuthorizeSecurityGroupIngress"",
      ""ec2:CreateRoute"",
      ""ec2:CreateSecurityGroup"",
      ""ec2:CreateSnapshot"",
      ""ec2:CreateTags"",
      ""ec2:CreateVolume"",
      ""ec2:DeleteRoute"",
      ""ec2:DeleteSecurityGroup"",
      ""ec2:DeleteSnapshot"",
      ""ec2:DeleteTags"",
      ""ec2:DeleteVolume"",
      ""ec2:DescribeAccountAttributes"",
      ""ec2:DescribeAvailabilityZones"",
      ""ec2:DescribeDhcpOptions"",
      ""ec2:DescribeInstances"",
      ""ec2:DescribeInstanceTypes"",
      ""ec2:DescribeInternetGateways"",
      ""ec2:DescribeLaunchTemplateVersions"",
      ""ec2:DescribeRegions"",
      ""ec2:DescribeRouteTables"",
      ""ec2:DescribeSecurityGroups"",
      ""ec2:DescribeSnapshots"",
      ""ec2:DescribeSubnets"",
      ""ec2:DescribeTags"",
      ""ec2:DescribeVolumes"",
      ""ec2:DescribeVolumesModifications"",
      ""ec2:DescribeVpcs"",
      ""ec2:DetachVolume"",
      ""ec2:ModifyInstanceAttribute"",
      ""ec2:ModifyVolume"",
      ""ec2:RevokeSecurityGroupIngress"",
      ""autoscaling:DescribeAutoScalingGroups"",
      ""autoscaling:DescribeAutoScalingInstances"",
      ""autoscaling:DescribeLaunchConfigurations"",
      ""autoscaling:DescribeTags"",
      ""autoscaling:SetDesiredCapacity"",
      ""autoscaling:TerminateInstanceInAutoScalingGroup"",
      ""elasticloadbalancing:AddTags"",
      ""elasticloadbalancing:ApplySecurityGroupsToLoadBalancer"",
      ""elasticloadbalancing:AttachLoadBalancerToSubnets"",
      ""elasticloadbalancing:ConfigureHealthCheck"",
      ""elasticloadbalancing:CreateListener"",
      ""elasticloadbalancing:CreateLoadBalancer"",
      ""elasticloadbalancing:CreateLoadBalancerListeners"",
      ""elasticloadbalancing:CreateLoadBalancerPolicy"",
      ""elasticloadbalancing:CreateTargetGroup"",
      ""elasticloadbalancing:DeleteListener"",
      ""elasticloadbalancing:DeleteLoadBalancer"",
      ""elasticloadbalancing:DeleteLoadBalancerListeners"",
      ""elasticloadbalancing:DeleteTargetGroup"",
      ""elasticloadbalancing:DeregisterInstancesFromLoadBalancer"",
      ""elasticloadbalancing:DeregisterTargets"",
      ""elasticloadbalancing:DescribeListeners"",
      ""elasticloadbalancing:DescribeLoadBalancerAttributes"",
      ""elasticloadbalancing:DescribeLoadBalancerPolicies"",
      ""elasticloadbalancing:DescribeLoadBalancers"",
      ""elasticloadbalancing:DescribeTargetGroups"",
      ""elasticloadbalancing:DescribeTargetHealth"",
      ""elasticloadbalancing:DetachLoadBalancerFromSubnets"",
      ""elasticloadbalancing:ModifyListener"",
      ""elasticloadbalancing:ModifyLoadBalancerAttributes"",
      ""elasticloadbalancing:ModifyTargetGroup"",
      ""elasticloadbalancing:RegisterInstancesWithLoadBalancer"",
      ""elasticloadbalancing:RegisterTargets"",
      ""elasticloadbalancing:SetLoadBalancerPoliciesForBackendServer"",
      ""elasticloadbalancing:SetLoadBalancerPoliciesOfListener"",
      ""elasticfilesystem:CreateAccessPoint"",
      ""elasticfilesystem:DeleteAccessPoint"",
      ""elasticfilesystem:DescribeAccessPoints"",
      ""elasticfilesystem:DescribeFileSystems"",
      ""elasticfilesystem:DescribeMountTargets"",
      ""kms:CreateGrant"",
      ""kms:Decrypt"",
      ""kms:Encrypt"",
      ""kms:GrantIsForAWSResource""
    ]
    resources = [""*""]
  }
  statement {
    effect = ""Allow""
    actions = [
      ""kms:Encrypt"",
      ""kms:Decrypt""
    ]
    resources = [var.db_kms_arn]
  }
}
resource ""aws_iam_policy"" ""cp_policy"" {
  name   = ""${var.anthos_prefix}-anthos-cp-policy""
  path   = ""/""
  policy = data.aws_iam_policy_document.cp_policy_document.json
}


resource ""aws_iam_role_policy_attachment"" ""cp_role_policy_attachment"" {
  role       = aws_iam_role.cp_role.name
  policy_arn = aws_iam_policy.cp_policy.arn
}
# Step 4 & 5 in doc
resource ""aws_iam_instance_profile"" ""cp_instance_profile"" {
  name = ""${var.anthos_prefix}-anthos-cp-instance-profile""
  role = aws_iam_role.cp_role.id
}

# Create the node pool role
# https://cloud.google.com/anthos/clusters/docs/multi-cloud/aws/how-to/create-aws-iam-roles#create_a_node_pool_iam_role

data ""aws_iam_policy_document"" ""np_assume_role_policy_document"" {
  statement {
    effect = ""Allow""
    principals {
      type        = ""Service""
      identifiers = [""ec2.amazonaws.com""]
    }
    actions = [""sts:AssumeRole""]
  }
}
resource ""aws_iam_role"" ""np_role"" {
  name               = ""${var.anthos_prefix}-anthos-np-role""
  description        = ""IAM role for the node pool""
  assume_role_policy = data.aws_iam_policy_document.np_assume_role_policy_document.json

}

data ""aws_iam_policy_document"" ""np_policy_document"" {
  statement {
    effect = ""Allow""
    actions = [
      ""autoscaling:DescribeAutoScalingGroups"",
      ""ec2:AttachNetworkInterface"",
      ""ec2:DescribeInstances"",
      ""ec2:DescribeTags"",
    ]
    resources = [""*""]
  }
  statement {
    effect = ""Allow""
    actions = [
      ""kms:Encrypt"",
      ""kms:Decrypt""
    ]
    resources = [var.db_kms_arn]
  }
}
resource ""aws_iam_policy"" ""np_policy"" {
  name   = ""${var.anthos_prefix}-anthos-np-policy""
  path   = ""/""
  policy = data.aws_iam_policy_document.np_policy_document.json
}

resource ""aws_iam_role_policy_attachment"" ""np_role_policy_attachment"" {
  role       = aws_iam_role.np_role.name
  policy_arn = aws_iam_policy.np_policy.arn
}

resource ""aws_iam_instance_profile"" ""np_instance_profile"" {
  name = ""${var.anthos_prefix}-anthos-np-instance-profile""
  role = aws_iam_role.np_role.id
}



variable ""gcp_project_number"" {
  description = ""GCP project Number of project to host cluster""
  type        = string
}

variable ""anthos_prefix"" {
  description = ""Prefix to apply to Anthos AWS Policy & Network names""
  type        = string
}

variable ""db_kms_arn"" {
  description = ""DB KMS ARN""
  type        = string
}

output ""api_role_arn"" {
  description = ""ARN of the actuated IAM role resource""
  value       = aws_iam_role.api_role.arn
}

output ""cp_instance_profile_id"" {
  description = ""IAM instance profile of controlplane""
  value       = aws_iam_instance_profile.cp_instance_profile.id
}

output ""np_instance_profile_id"" {
  description = ""IAM instance profile of nodepool""
  value       = aws_iam_instance_profile.np_instance_profile.id
}

","{
  ""userQuery1"": ""The user wants to set up an AWS IAM role for the Anthos Multi-Cloud API. This role should allow a Google Cloud service account to assume the role, with the service account being identified by a specific Google Cloud project number."",
  ""userQuery2"": ""The user wants to create an IAM role for the control plane of an Anthos cluster on AWS. This role should have permissions to manage various AWS resources, such as EC2 instances, Auto Scaling groups, and Elastic Load Balancing. The role should also be able to encrypt and decrypt data using a specific KMS key."",
  ""userQuery3"": ""The user wants to create an IAM role for the node pool of an Anthos cluster on AWS. This role should have permissions to describe Auto Scaling groups and EC2 instances, and attach network interfaces. The role should also be able to encrypt and decrypt data using a specific KMS key.""
}"
32,sl1pm4t,terraform-provider-kubernetes,_examples/wordpress-mysql-gce-pv,"variable ""gcp_region"" {}
variable ""gcp_zone"" {}

provider ""google"" {
  region = ""${var.gcp_region}""
}

resource ""google_compute_disk"" ""mysql"" {
  name  = ""wordpress-mysql""
  type  = ""pd-ssd""
  zone  = ""${var.gcp_zone}""
  size = 20
}

resource ""kubernetes_persistent_volume"" ""mysql"" {
  metadata {
    name = ""mysql-pv""
  }
  spec {
    capacity {
      storage = ""20Gi""
    }
    access_modes = [""ReadWriteOnce""]
    persistent_volume_source {
      gce_persistent_disk {
        pd_name = ""${google_compute_disk.mysql.name}""
        fs_type = ""ext4""
      }
    }
  }
}

resource ""google_compute_disk"" ""wordpress"" {
  name  = ""wordpress-frontend""
  type  = ""pd-ssd""
  zone  = ""${var.gcp_zone}""
  size = 20
}

resource ""kubernetes_persistent_volume"" ""wordpress"" {
  metadata {
    name = ""wordpress-pv""
  }
  spec {
    capacity {
      storage = ""20Gi""
    }
    access_modes = [""ReadWriteOnce""]
    persistent_volume_source {
      gce_persistent_disk {
        pd_name = ""${google_compute_disk.wordpress.name}""
        fs_type = ""ext4""
      }
    }
  }
}



variable ""mysql_password"" {}
variable ""mysql_version"" {
  default = ""5.6""
}

resource ""kubernetes_service"" ""mysql"" {
  metadata {
    name = ""wordpress-mysql""
    labels {
      app = ""wordpress""
    }
  }
  spec {
    port {
      port = 3306
      target_port = 3306
    }
    selector {
      app = ""wordpress""
      tier = ""${kubernetes_replication_controller.mysql.spec.0.selector.tier}""
    }
    cluster_ip = ""None""
  }
}

resource ""kubernetes_persistent_volume_claim"" ""mysql"" {
  metadata {
    name = ""mysql-pv-claim""
    labels {
      app = ""wordpress""
    }
  }
  spec {
    access_modes = [""ReadWriteOnce""]
    resources {
      requests {
        storage = ""20Gi""
      }
    }
    volume_name = ""${kubernetes_persistent_volume.mysql.metadata.0.name}""
  }
}

resource ""kubernetes_secret"" ""mysql"" {
  metadata {
    name = ""mysql-pass""
  }

  data {
    password = ""${var.mysql_password}""
  }
}

resource ""kubernetes_replication_controller"" ""mysql"" {
  metadata {
    name = ""wordpress-mysql""
    labels {
      app = ""wordpress""
    }
  }
  spec {
    selector {
      app = ""wordpress""
      tier = ""mysql""
    }
    template {
      container {
        image = ""mysql:${var.mysql_version}""
        name  = ""mysql""

        env {
          name = ""MYSQL_ROOT_PASSWORD""
          value_from {
            secret_key_ref {
              name = ""${kubernetes_secret.mysql.metadata.0.name}""
              key = ""password""
            }
          }
        }

        port {
          container_port = 3306
          name = ""mysql""
        }

        volume_mount {
          name = ""mysql-persistent-storage""
          mount_path = ""/var/lib/mysql""
        }
      }

      volume {
        name = ""mysql-persistent-storage""
        persistent_volume_claim {
          claim_name = ""${kubernetes_persistent_volume_claim.mysql.metadata.0.name}""
        }
      }
    }
  }
}


variable ""wordpress_version"" {
  default = ""4.7.3""
}

resource ""kubernetes_service"" ""wordpress"" {
  metadata {
    name = ""wordpress""
    labels {
      app = ""wordpress""
    }
  }
  spec {
    port {
      port = 80
      target_port = 80
    }
    selector {
      app = ""wordpress""
      tier = ""${kubernetes_replication_controller.wordpress.spec.0.selector.tier}""
    }
    type = ""LoadBalancer""
  }
}

output ""lb_ip"" {
  value = ""${kubernetes_service.wordpress.load_balancer_ingress.0.ip}""
}

resource ""kubernetes_persistent_volume_claim"" ""wordpress"" {
  metadata {
    name = ""wp-pv-claim""
    labels {
      app = ""wordpress""
    }
  }
  spec {
    access_modes = [""ReadWriteOnce""]
    resources {
      requests {
        storage = ""20Gi""
      }
    }
    volume_name = ""${kubernetes_persistent_volume.wordpress.metadata.0.name}""
  }
}

resource ""kubernetes_replication_controller"" ""wordpress"" {
  metadata {
    name = ""wordpress""
    labels {
      app = ""wordpress""
    }
  }
  spec {
    selector {
      app = ""wordpress""
      tier = ""frontend""
    }
    template {
      container {
        image = ""wordpress:${var.wordpress_version}-apache""
        name  = ""wordpress""

        env {
          name = ""WORDPRESS_DB_HOST""
          value = ""wordpress-mysql""
        }
        env {
          name = ""WORDPRESS_DB_PASSWORD""
          value_from {
            secret_key_ref {
              name = ""${kubernetes_secret.mysql.metadata.0.name}""
              key = ""password""
            }
          }
        }

        port {
          container_port = 80
          name = ""wordpress""
        }

        volume_mount {
          name = ""wordpress-persistent-storage""
          mount_path = ""/var/www/html""
        }
      }

      volume {
        name = ""wordpress-persistent-storage""
        persistent_volume_claim {
          claim_name = ""${kubernetes_persistent_volume_claim.wordpress.metadata.0.name}""
        }
      }
    }
  }
}


","{
  ""userQuery1"": ""The user wants to set up a Google Cloud Platform (GCP) environment with specific regions and zones. They want to use this environment to host their applications."",
  ""userQuery2"": ""The user intends to create two persistent storage volumes in the GCP environment. One is for a MySQL database and the other is for a WordPress application. Both volumes should be of type 'pd-ssd' and have a size of 20GB."",
  ""userQuery3"": ""The user wants to deploy a MySQL database and a WordPress application on a Kubernetes cluster. The MySQL database should be accessible only within the cluster, while the WordPress application should be accessible from outside the cluster. The MySQL database should use the persistent volume created for it, and the WordPress application should use its own persistent volume. The user also wants to specify the versions of MySQL and WordPress to be used."",
  ""userQuery4"": ""The user wants to secure the MySQL database by"
33,terraform-google-modules,docs-examples,healthcare_fhir_store_basic,"resource ""google_healthcare_fhir_store"" ""default"" {
  name    = ""example-fhir-store-${local.name_suffix}""
  dataset = google_healthcare_dataset.dataset.id
  version = ""R4""
  complex_data_type_reference_parsing = ""DISABLED""

  enable_update_create           = false
  disable_referential_integrity  = false
  disable_resource_versioning    = false
  enable_history_import          = false
  default_search_handling_strict = false

  notification_config {
    pubsub_topic = google_pubsub_topic.topic.id
  }

  labels = {
    label1 = ""labelvalue1""
  }
}

resource ""google_pubsub_topic"" ""topic"" {
  name     = ""fhir-notifications-${local.name_suffix}""
}

resource ""google_healthcare_dataset"" ""dataset"" {
  name     = ""example-dataset-${local.name_suffix}""
  location = ""us-central1""
}


# This file has some scaffolding to make sure that names are unique and that
# a region and zone are selected when you try to create your Terraform resources.

locals {
  name_suffix = ""${random_pet.suffix.id}""
}

resource ""random_pet"" ""suffix"" {
  length = 2
}

provider ""google"" {
  region = ""us-central1""
  zone   = ""us-central1-c""
}


","{
  ""userQuery1"": ""The user wants to create a Google Healthcare FHIR store with a unique name, which is a combination of 'example-fhir-store-' and a randomly generated suffix. The FHIR store is associated with a specific dataset and uses the R4 version of the FHIR standard. The user has disabled complex data type reference parsing and update-create functionality, but has not disabled referential integrity, resource versioning, history import, or strict default search handling. The user also wants to set up a notification configuration with a Pub/Sub topic, and assign a label to the FHIR store."",
  ""userQuery2"": ""The user wants to create a Google Pub/Sub topic with a unique name, which is a combination of 'fhir-notifications-' and a randomly generated suffix."",
  ""userQuery3"": ""The user wants to create a Google Healthcare dataset with a unique name, which is a combination of 'example-dataset-' and a randomly generated suffix."
34,bsiegel,tectonic-installer,modules/azure/etcd,"// Location is the Azure Location (East US, West US, etc)
variable ""location"" {
  type = ""string""
}

variable ""resource_group_name"" {
  type = ""string""
}

variable ""cluster_id"" {
  type = ""string""
}

// VM Size name
variable ""vm_size"" {
  type = ""string""
}

// Storage account type
variable ""storage_type"" {
  type = ""string""
}

variable ""storage_id"" {
  type = ""string""
}

// Count of etcd nodes to be created.
variable ""etcd_count"" {
  type = ""string""
}

// The base DNS domain of the cluster.
// Example: `azure.dev.coreos.systems`
variable ""base_domain"" {
  type = ""string""
}

// The name of the cluster.
variable ""cluster_name"" {
  type = ""string""
}

variable ""public_ssh_key"" {
  type = ""string""
}

variable ""network_interface_ids"" {
  type = ""list""
}

variable ""versions"" {
  description = ""(internal) Versions of the components to use""
  type        = ""map""
}

variable ""cl_channel"" {
  type = ""string""
}

variable ""const_internal_node_names"" {
  type        = ""list""
  default     = [""etcd-0"", ""etcd-1"", ""etcd-2"", ""etcd-3"", ""etcd-4""]
  description = ""(internal) The list of hostnames assigned to etcd member nodes.""
}

variable ""tls_enabled"" {
  default = false
}

variable ""tls_ca_crt_pem"" {
  default = """"
}

variable ""tls_client_key_pem"" {
  default = """"
}

variable ""tls_client_crt_pem"" {
  default = """"
}

variable ""tls_server_key_pem"" {
  default = """"
}

variable ""tls_server_crt_pem"" {
  default = """"
}

variable ""tls_peer_key_pem"" {
  default = """"
}

variable ""tls_peer_crt_pem"" {
  default = """"
}

variable ""container_image"" {
  type = ""string""
}

variable ""extra_tags"" {
  type = ""map""
}


data ""ignition_config"" ""etcd"" {
  count = ""${var.etcd_count}""

  systemd = [
    ""${data.ignition_systemd_unit.locksmithd.*.id[count.index]}"",
    ""${data.ignition_systemd_unit.etcd3.*.id[count.index]}"",
  ]

  users = [
    ""${data.ignition_user.core.id}"",
  ]

  files = [
    ""${data.ignition_file.etcd_ca.id}"",
    ""${data.ignition_file.etcd_server_crt.id}"",
    ""${data.ignition_file.etcd_server_key.id}"",
    ""${data.ignition_file.etcd_client_crt.id}"",
    ""${data.ignition_file.etcd_client_key.id}"",
    ""${data.ignition_file.etcd_peer_crt.id}"",
    ""${data.ignition_file.etcd_peer_key.id}"",
  ]
}

data ""ignition_file"" ""etcd_ca"" {
  count = ""${var.etcd_count > 0 ? 1 : 0}""

  path       = ""/etc/ssl/etcd/ca.crt""
  mode       = 0644
  uid        = 232
  gid        = 232
  filesystem = ""root""

  content {
    content = ""${var.tls_ca_crt_pem}""
  }
}

data ""ignition_file"" ""etcd_client_key"" {
  path       = ""/etc/ssl/etcd/client.key""
  mode       = 0400
  uid        = 0
  gid        = 0
  filesystem = ""root""

  content {
    content = ""${var.tls_client_key_pem}""
  }
}

data ""ignition_file"" ""etcd_client_crt"" {
  path       = ""/etc/ssl/etcd/client.crt""
  mode       = 0400
  uid        = 0
  gid        = 0
  filesystem = ""root""

  content {
    content = ""${var.tls_client_crt_pem}""
  }
}

data ""ignition_file"" ""etcd_server_key"" {
  count = ""${var.etcd_count > 0 ? 1 : 0}""

  path       = ""/etc/ssl/etcd/server.key""
  mode       = 0400
  uid        = 232
  gid        = 232
  filesystem = ""root""

  content {
    content = ""${var.tls_server_key_pem}""
  }
}

data ""ignition_file"" ""etcd_server_crt"" {
  count = ""${var.etcd_count > 0 ? 1 : 0}""

  path       = ""/etc/ssl/etcd/server.crt""
  mode       = 0400
  uid        = 232
  gid        = 232
  filesystem = ""root""

  content {
    content = ""${var.tls_server_crt_pem}""
  }
}

data ""ignition_file"" ""etcd_peer_key"" {
  count = ""${var.etcd_count > 0 ? 1 : 0}""

  path       = ""/etc/ssl/etcd/peer.key""
  mode       = 0400
  uid        = 232
  gid        = 232
  filesystem = ""root""

  content {
    content = ""${var.tls_peer_key_pem}""
  }
}

data ""ignition_file"" ""etcd_peer_crt"" {
  count = ""${var.etcd_count > 0 ? 1 : 0}""

  path       = ""/etc/ssl/etcd/peer.crt""
  mode       = 0400
  uid        = 232
  gid        = 232
  filesystem = ""root""

  content {
    content = ""${var.tls_peer_crt_pem}""
  }
}

data ""ignition_user"" ""core"" {
  count = ""${var.etcd_count > 0 ? 1 : 0}""

  name = ""core""

  ssh_authorized_keys = [
    ""${file(var.public_ssh_key)}"",
  ]
}

data ""ignition_systemd_unit"" ""locksmithd"" {
  count = ""${var.etcd_count}""

  name   = ""locksmithd.service""
  enable = true

  dropin = [
    {
      name = ""40-etcd-lock.conf""

      content = <<EOF
[Service]
Environment=REBOOT_STRATEGY=etcd-lock
${var.tls_enabled ? ""Environment=\""LOCKSMITHD_ETCD_CAFILE=/etc/ssl/etcd/ca.crt\"""" : """"}
${var.tls_enabled ? ""Environment=\""LOCKSMITHD_ETCD_KEYFILE=/etc/ssl/etcd/client.key\"""" : """"}
${var.tls_enabled ? ""Environment=\""LOCKSMITHD_ETCD_CERTFILE=/etc/ssl/etcd/client.crt\"""" : """"}
Environment=""LOCKSMITHD_ENDPOINT=${var.tls_enabled ? ""https"" : ""http""}://etcd-${count.index}:2379""
EOF
    },
  ]
}

data ""ignition_systemd_unit"" ""etcd3"" {
  count = ""${var.etcd_count}""

  name   = ""etcd-member.service""
  enable = true

  dropin = [
    {
      name = ""40-etcd-cluster.conf""

      content = <<EOF
[Unit]
Requires=coreos-metadata.service
After=coreos-metadata.service

[Service]
Environment=""ETCD_IMAGE=${var.container_image}""
EnvironmentFile=/run/metadata/coreos
Environment=""RKT_RUN_ARGS=--volume etcd-ssl,kind=host,source=/etc/ssl/etcd \
  --mount volume=etcd-ssl,target=/etc/ssl/etcd""
ExecStart=
ExecStart=/usr/lib/coreos/etcd-wrapper \
  --name=${element(split("";"", var.base_domain == """" ? 
          join("";"", slice(formatlist(""${var.cluster_name}-%s"", var.const_internal_node_names), 0, var.etcd_count)) : 
          join("";"", formatlist(""%s.${var.base_domain}"", slice(formatlist(""${var.cluster_name}-%s"", var.const_internal_node_names), 0, var.etcd_count)))), count.index)} \
  --advertise-client-urls=${var.tls_enabled ? ""https"" : ""http""}://$${COREOS_AZURE_IPV4_DYNAMIC}:2379 \
  ${var.tls_enabled
      ? ""--cert-file=/etc/ssl/etcd/server.crt --key-file=/etc/ssl/etcd/server.key --peer-cert-file=/etc/ssl/etcd/peer.crt --peer-key-file=/etc/ssl/etcd/peer.key --peer-trusted-ca-file=/etc/ssl/etcd/ca.crt --peer-client-cert-auth=true""
      : """"} \
  --initial-advertise-peer-urls=${var.tls_enabled ? ""https"" : ""http""}://$${COREOS_AZURE_IPV4_DYNAMIC}:2380 \
  --listen-client-urls=${var.tls_enabled ? ""https"" : ""http""}://0.0.0.0:2379 \
  --listen-peer-urls=${var.tls_enabled ? ""https"" : ""http""}://0.0.0.0:2380 \
  --initial-cluster=${
    join("","",
      formatlist(""%s=${var.tls_enabled ? ""https"" : ""http""}://%s:2380"", 
        split("";"", var.base_domain == """" ? 
          join("";"", slice(formatlist(""${var.cluster_name}-%s"", var.const_internal_node_names), 0, var.etcd_count)) : 
          join("";"", formatlist(""%s.${var.base_domain}"", slice(formatlist(""${var.cluster_name}-%s"", var.const_internal_node_names), 0, var.etcd_count)))), 
        split("";"", var.base_domain == """" ? 
          join("";"", slice(formatlist(""${var.cluster_name}-%s"", var.const_internal_node_names), 0, var.etcd_count)) : 
          join("";"", formatlist(""%s.${var.base_domain}"", slice(formatlist(""${var.cluster_name}-%s"", var.const_internal_node_names), 0, var.etcd_count))))
    ))
  }
EOF

      // The abomination of an expression above will go away once we refactor ignition rendering into it's own module.
    },
  ]
}


resource ""azurerm_availability_set"" ""etcd"" {
  count               = ""${var.etcd_count > 0 ? 1 : 0}""
  name                = ""${var.cluster_name}-etcd""
  location            = ""${var.location}""
  resource_group_name = ""${var.resource_group_name}""
  managed             = true

  tags = ""${merge(map(
    ""Name"", ""${var.cluster_name}-etcd"",
    ""tectonicClusterID"", ""${var.cluster_id}""),
    var.extra_tags)}""
}

resource ""azurerm_virtual_machine"" ""etcd_node"" {
  count                 = ""${var.etcd_count}""
  name                  = ""${var.cluster_name}-etcd-${count.index}""
  location              = ""${var.location}""
  resource_group_name   = ""${var.resource_group_name}""
  network_interface_ids = [""${var.network_interface_ids[count.index]}""]
  vm_size               = ""${var.vm_size}""
  availability_set_id   = ""${azurerm_availability_set.etcd.id}""

  delete_os_disk_on_termination = true

  storage_image_reference {
    publisher = ""CoreOS""
    offer     = ""CoreOS""
    sku       = ""${var.cl_channel}""
    version   = ""latest""
  }

  storage_os_disk {
    name              = ""etcd-${count.index}-os-${var.storage_id}""
    managed_disk_type = ""${var.storage_type}""
    create_option     = ""FromImage""
    caching           = ""ReadWrite""
    os_type           = ""linux""
  }

  os_profile {
    computer_name  = ""${var.cluster_name}-etcd-${count.index}""
    admin_username = ""core""
    admin_password = """"
    custom_data    = ""${base64encode(""${data.ignition_config.etcd.*.rendered[count.index]}"")}""
  }

  os_profile_linux_config {
    disable_password_authentication = true

    ssh_keys {
      path     = ""/home/core/.ssh/authorized_keys""
      key_data = ""${file(var.public_ssh_key)}""
    }
  }

  tags = ""${merge(map(
    ""Name"", ""${var.cluster_name}-etcd-${count.index}"",
    ""tectonicClusterID"", ""${var.cluster_id}""),
    var.extra_tags)}""
}


output ""node_names"" {
  value = [""${compact(split("";"", var.base_domain == """" ?
    join("";"", slice(formatlist(""${var.cluster_name}-%s"", var.const_internal_node_names), 0, var.etcd_count)) : 
    join("";"", formatlist(""%s.${var.base_domain}"", slice(formatlist(""${var.cluster_name}-%s"", var.const_internal_node_names), 0, var.etcd_count)))))
  }""]
}


","{
  ""userQuery1"": ""The user wants to create a set of virtual machines in Azure to form an etcd cluster. The number of nodes in the cluster, the location of the Azure resources, the name of the resource group, the cluster ID, the VM size, the storage type, the storage ID, the base DNS domain of the cluster, the cluster name, the public SSH key, the network interface IDs, the versions of the components to use, the Container Linux channel to use, the list of hostnames assigned to etcd member nodes, whether TLS is enabled, the TLS CA certificate, the TLS client key, the TLS client certificate, the TLS server key, the TLS server certificate, the TLS peer key, the TLS peer certificate, the container image, and any extra tags are all configurable by the user."",
  ""userQuery2"": ""The user wants to configure the etcd nodes to use a specific container image and to be part of an availability set in"
35,zembutsu,sakura-terraform,4-dns,"#resource ""sakuracloud_dns"" ""toaru"" {
#    zone = ""toaru.org""
#}

resource ""sakuracloud_dns_record"" ""dev01"" {
    #dns_id = ""${sakuracloud_dns.toaru.id}""
    dns_id = ""<ID_HERE>""
    name = ""dev01""
    type = ""A""
    value = ""<IP_ADDRESS>""
}


","{
""userQuery1"": ""The user needs to manage a DNS zone for the domain 'toaru.org' on Sakura Cloud."",
""userQuery2"": ""The user intends to create a DNS record of type 'A' for the subdomain 'dev01.toaru.org'."",
""userQuery3"": ""The user wants to assign a specific IP address to the 'dev01.toaru.org' subdomain.""
}"
36,GoogleCloudPlatform,public-datasets-pipelines,datasets/new_york/infra,"/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


provider ""google"" {
  project                     = var.project_id
  impersonate_service_account = var.impersonating_acct
  region                      = var.region
}

data ""google_client_openid_userinfo"" ""me"" {}

output ""impersonating-account"" {
  value = data.google_client_openid_userinfo.me.email
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


variable ""project_id"" {}
variable ""bucket_name_prefix"" {}
variable ""impersonating_acct"" {}
variable ""region"" {}
variable ""env"" {}



/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


resource ""google_bigquery_dataset"" ""new_york"" {
  dataset_id  = ""new_york""
  project     = var.project_id
  description = ""new_york""
}

output ""bigquery_dataset-new_york-dataset_id"" {
  value = google_bigquery_dataset.new_york.dataset_id
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


resource ""google_bigquery_table"" ""new_york_new_york"" {
  project     = var.project_id
  dataset_id  = ""new_york""
  table_id    = ""new_york""
  description = ""New York Pipelines""
  depends_on = [
    google_bigquery_dataset.new_york
  ]
}

output ""bigquery_table-new_york_new_york-table_id"" {
  value = google_bigquery_table.new_york_new_york.table_id
}

output ""bigquery_table-new_york_new_york-id"" {
  value = google_bigquery_table.new_york_new_york.id
}


","{
  ""userQuery1"": ""The user wants to set up a Google Cloud provider with a specific project ID, service account to impersonate, and region. The user also wants to retrieve the email of the impersonated account."",
  ""userQuery2"": ""The user needs to create a Google BigQuery dataset named 'new_york' in the specified project. The user also wants to output the dataset ID of the created dataset."",
  ""userQuery3"": ""The user intends to create a Google BigQuery table named 'new_york' in the 'new_york' dataset. The creation of this table depends on the creation of the 'new_york' dataset. The user also wants to output the table ID and the ID of the created table.""
}"
37,jerrywardlow,devops-playground,terraform-docker-airpair,"/* Skipping these for git reasons and using environment variables

variable ""access_key"" {
    description = ""AWS access key""
}

variable ""secret_key"" {
    description = ""AWS secret access key""
}
*/

variable ""region"" {
    description = ""AWS region""
    default     = ""us-west-2""
}

variable ""vpc_cidr"" {
    description = ""/16 CIDR for VPC""
    default     = ""10.128.0.0/16""
}

variable ""public_subnet_cidr"" {
    description = ""CIDR for public subnet""
    default     = ""10.128.0.0/24""
}

variable ""private_subnet_cidr"" {
    description = ""CIDR for private subnet""
    default     = ""10.128.1.0/24""
}

variable ""amis"" {
    description = ""Ubuntu base AMI by region""
    default = {
        us-east-1 = ""ami-81365496""
        us-west-1 = ""ami-05105d65""
        us-west-2 = ""ami-9ece19fe""
    }
}


provider ""aws"" {
    region = ""${var.region}""
}

resource ""aws_vpc"" ""default"" {
    cidr_block = ""${var.vpc_cidr}""
    enable_dns_hostnames = true
    tags {
        Name = ""airpair-example""
    }
}


# Gateway for public subnet 
resource ""aws_internet_gateway"" ""default"" {
    vpc_id = ""${aws_vpc.default.id}""
}

# Public subnet
resource ""aws_subnet"" ""public"" {
    vpc_id = ""${aws_vpc.default.id}""
    cidr_block = ""${var.public_subnet_cidr}""
    availability_zone = ""us-west-2a""
    map_public_ip_on_launch = true
    depends_on = [""aws_internet_gateway.default""]
    tags {
        Name = ""public""
    }
}

# Routing table for public subnet
resource ""aws_route_table"" ""public"" {
    vpc_id = ""${aws_vpc.default.id}""
    route {
        cidr_block = ""0.0.0.0/0""
        gateway_id = ""${aws_internet_gateway.default.id}""
    }
}

# Associate routing table to public subnet
resource ""aws_route_table_association"" ""public"" {
    subnet_id = ""${aws_subnet.public.id}""
    route_table_id = ""${aws_route_table.public.id}""
}


# Private subnet
resource ""aws_subnet"" ""private"" {
    vpc_id = ""${aws_vpc.default.id}""
    cidr_block = ""${var.private_subnet_cidr}""
    availability_zone = ""us-west-2a""
    map_public_ip_on_launch = false
    depends_on = [""aws_instance.nat""]
    tags {
        Name = ""private""
    }
}

# Routing table for private subnet
resource ""aws_route_table"" ""private"" {
    vpc_id = ""${aws_vpc.default.id}""
    route {
        cidr_block = ""0.0.0.0/0""
        instance_id = ""${aws_instance.nat.id}""
    }
}

# Associate routing table to public subnet
resource ""aws_route_table_association"" ""private"" {
    subnet_id = ""${aws_subnet.private.id}""
    route_table_id = ""${aws_route_table.private.id}""
}


# Default security group
resource ""aws_security_group"" ""default"" {
    name = ""default-airpair-example""
    description = ""Default security group allowing in and outbound traffic from all instances in VPC""
    vpc_id = ""${aws_vpc.default.id}""

    ingress {
        from_port = ""0""
        to_port = ""0""
        protocol = ""-1""
        self = true
    }

    egress {
        from_port = ""0""
        to_port = ""0""
        protocol = ""-1""
        self = true
    }

    tags {
        Name = ""airpair-example-default-vpc""
    }
}

# Security group for NAT server
resource ""aws_security_group"" ""nat"" {
    name = ""nat-airpair-example""
    description = ""Security group for NAT instances allowing SSH, VPN and outbound HTTP""
    vpc_id = ""${aws_vpc.default.id}""

    ingress {
        from_port = 22
        to_port = 22
        protocol = ""tcp""
        cidr_blocks = [""0.0.0.0/0""]
    }

    ingress {
        from_port = 1194
        to_port = 1194
        protocol = ""udp""
        cidr_blocks = [""0.0.0.0/0""]
    }

    egress {
        from_port = 80
        to_port = 80
        protocol = ""tcp""
        cidr_blocks = [""0.0.0.0/0""]
    }

    egress {
        from_port = 443
        to_port = 443
        protocol = ""tcp""
        cidr_blocks = [""0.0.0.0/0""]
    }

    tags {
        Name = ""nat-airpair-example""
    }
}

# Security group for web
resource ""aws_security_group"" ""web"" {
    name = ""web-airpair-example""
    description = ""Security group allowing web traffic""
    vpc_id = ""${aws_vpc.default.id}""

    ingress {
        from_port = 80
        to_port = 80
        protocol = ""tcp""
        cidr_blocks = [""0.0.0.0/0""]
    }

    ingress {
        from_port = 443
        to_port = 443
        protocol = ""tcp""
        cidr_blocks = [""0.0.0.0/0""]
    }

    tags {
        Name = ""web-airpair-example""
    }
}


resource ""aws_key_pair"" ""deployer"" {
    key_name = ""deployer-key""
    public_key = ""${file(""ssh/insecure-deployer.pub"")}""
}


# NAT/VPN server
resource ""aws_instance"" ""nat"" {
    ami = ""${lookup(var.amis, var.region)}""
    instance_type = ""t2.micro""
    subnet_id = ""${aws_subnet.public.id}""
    security_groups = [""${aws_security_group.default.id}"", ""${aws_security_group.nat.id}""]
    key_name = ""${aws_key_pair.deployer.key_name}""
    source_dest_check = false
    tags = {
        Name = ""airpair-example-nat""
    }
    connection {
        user = ""ubuntu""
        key_file = ""ssh/insecure-deployer""
    }
    provisioner ""remote-exec"" {
        inline = [
            ""sudo iptables -t nat -A POSTROUTING -j MASQUERADE"",
            ""echo 1 | sudo tee /proc/sys/net/ipv4/conf/all/forwarding > /dev/null"",
            ""curl -sSL https://get.docker.com/ | sudo sh"",
            ""usermod -G docker ubuntu"",
            ""sudo mkdir -p /etc/openvpn"",
            ""sudo docker run --name ovpn-data -v /etc/openvpn busybox"",
            ""sudo docker run --volumes-from ovpn-data --rm gosuri/openvpn ovpn_genconfig -p ${var.vpc_cidr} -u udp://${aws_instance.nat.public_ip}""
        ]
    }
}


# App servers
resource ""aws_instance"" ""app"" {
    count = 2
    ami = ""${lookup(var.amis, var.region)}""
    instance_type = ""t2.micro""
    subnet_id = ""${aws_subnet.private.id}""
    security_groups = [""${aws_security_group.default.id}""]
    key_name = ""${aws_key_pair.deployer.key_name}""
    source_dest_check = false
    user_data = ""${file(""cloud-config/app.yml"")}""
    tags = {
        Name = ""airpair-example-app-${count.index}""
    }
}

# Load balancer
resource ""aws_elb"" ""app"" {
    name = ""airpair-example-elb""
    subnets = [""${aws_subnet.public.id}""]
    security_groups = [""${aws_security_group.default.id}"", ""${aws_security_group.web.id}""]
    listener {
        instance_port = 80
        instance_protocol = ""http""
        lb_port = 80
        lb_protocol = ""http""
    }
    instances = [""${aws_instance.app.*.id}""]
}


output ""app.0.ip"" {
    value = ""${aws_instance.app.0.private_ip}""
}

output ""app.1.ip"" {
    value = ""${aws_instance.app.1.private_ip}""
}

output ""nat.ip"" {
    value = ""${aws_instance.nat.public_ip}""
}

output ""elb.hostname"" {
    value = ""${aws_elb.app.dns_name}""
}


","{
""userQuery1"": ""The user needs to set up an AWS environment in a specific region, with a default region of 'us-west-2'. They also need to specify the CIDR blocks for the VPC and the public and private subnets."",
""userQuery2"": ""The user intends to create a VPC with DNS hostnames enabled, an internet gateway, and two subnets: one public and one private. The public subnet should have a map of public IP on launch, while the private subnet should not. The public subnet depends on the internet gateway, and the private subnet depends on a NAT instance."",
""userQuery3"": ""The user wants to set up routing tables for both the public and private subnets. The public subnet's routing table should route all traffic to the internet gateway, while the private subnet's routing table should route all traffic to the NAT instance."",
""userQuery4"": ""The user needs to create three security groups: a default one allowing in and outbound traffic"
38,terraform-google-modules,terraform-google-network,test/setup,"/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">=0.13.0""

  required_providers {
    google = {
      version = "">= 3.49""
    }
    google-beta = {
      version = "">= 3.49""
    }
  }
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
variable ""org_id"" {
  description = ""The numeric organization id""
}

variable ""folder_id"" {
  description = ""The folder to deploy in""
}

variable ""billing_account"" {
  description = ""The billing account id associated with the project, e.g. XXXXXX-YYYYYY-ZZZZZZ""
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ""project"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 14.0""

  name              = ""ci-network""
  random_project_id = ""true""
  org_id            = var.org_id
  folder_id         = var.folder_id
  billing_account   = var.billing_account

  activate_apis = [
    ""cloudresourcemanager.googleapis.com"",
    ""compute.googleapis.com"",
    ""serviceusage.googleapis.com"",
    ""vpcaccess.googleapis.com"",
    ""dns.googleapis.com"",
    ""networksecurity.googleapis.com"",
    ""iam.googleapis.com"",
  ]
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

locals {
  int_required_roles = [
    ""roles/compute.networkAdmin"",
    ""roles/compute.securityAdmin"",
    ""roles/iam.serviceAccountUser"",
    ""roles/vpcaccess.admin"",
    ""roles/serviceusage.serviceUsageAdmin"",
    ""roles/dns.admin"",
    ""roles/resourcemanager.tagAdmin"",
    ""roles/iam.serviceAccountAdmin"",
  ]
}

resource ""google_service_account"" ""int_test"" {
  project      = module.project.project_id
  account_id   = ""ci-network""
  display_name = ""ci-network""
}

resource ""google_project_iam_member"" ""int_test"" {
  count = length(local.int_required_roles)

  project = module.project.project_id
  role    = local.int_required_roles[count.index]
  member  = ""serviceAccount:${google_service_account.int_test.email}""
}

resource ""google_service_account_key"" ""int_test"" {
  service_account_id = google_service_account.int_test.id
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""project_id"" {
  value = module.project.project_id
}

output ""sa_key"" {
  value     = google_service_account_key.int_test.private_key
  sensitive = true
}


","{
  ""userQuery1"": ""The user needs to specify the version of Terraform and the Google providers to be used. The Terraform version should be 0.13.0 or later, and the Google and Google-beta providers should be version 3.49 or later."",
  ""userQuery2"": ""The user needs to provide three variables: 'org_id' which is the numeric organization id, 'folder_id' which is the folder to deploy in, and 'billing_account' which is the billing account id associated with the project."",
  ""userQuery3"": ""The user intends to create a new Google Cloud project with a random project id, using the 'project-factory' module. The project name should be 'ci-network'. The project should be associated with the provided organization id, folder id, and billing account. The project should have several APIs activated, including 'cloudresourcemanager.googleapis.com', 'compute.googleapis.com', 'serviceusage.googleapis.com', '"
39,ahromis,ddc-terraform,,"# Configure the AWS Provider
provider ""aws"" {
    access_key = ""${var.access_key}""
    secret_key = ""${var.secret_key}""
    region = ""${var.region}""
}



variable ""access_key"" {
  description = ""AWS access key.""
}

variable ""secret_key"" {
  description = ""AWS secret key.""
}

variable ""allowed_network"" {
  description = ""The CIDR of network that is allowed to ssh to the servers""
}

variable ""key_name"" {
  description = ""Name of the keypair to use in EC2.""
}

variable ""zone_name"" {
  description = ""Name of your DNS hosted zone, this can be a subdomain as well""
}

variable ""manager_type"" {
  description = ""UCP manager instance type""
}

variable ""manager_count"" {
  description = ""Number of UCP manager nodes (3,5,7)""
  default     = ""3""
}

variable ""worker_type"" {
  description = ""UCP worker instance type""
}

variable ""worker_count"" {
  description = ""Number of UCP worker nodes""
  default     = ""3""
}

variable ""ucp_dns"" {
  description = ""UCP DNS name""
}

variable ""dtr_dns"" {
  description = ""UCP DNS name""
}

variable ""env_name"" {
  type        = ""string""
  description = ""Environment name""
}

variable ""region"" {
  type        = ""string""
  description = ""The AWS region to create things in.""
  default     = ""us-west-2""
}

variable ""vpc_cidr"" {
  type        = ""string""
  description = ""CIDR for VPC""
  default     = ""192.168.0.0/16""
}

variable ""public_cidrs"" {
  type        = ""map""
  description = ""CIDR for public subnets""
  default     = {
    ""0"" = ""192.168.10.0/24""
    ""1"" = ""192.168.20.0/24""
    ""2"" = ""192.168.30.0/24""
  }
}

# Note: This mapping has to be updated manually, terraform didn't allow interpolated variables here

variable ""availability_zones"" {
  type        = ""map""
  description = ""AWS availability zones""
  default     = {
    ""0"" = ""us-west-2a""
    ""1"" = ""us-west-2b""
    ""2"" = ""us-west-2c""
  }
}

variable ""ubuntu_amis"" {
  description = ""Ubuntu 14.04 AMIs""
  default = {
    us-east-1 = ""ami-8e0b9499""
    us-west-2 = ""ami-70b67d10""
    us-west-1 = ""ami-547b3834""
  }
}


resource ""aws_vpc"" ""default"" {
  cidr_block = ""${var.vpc_cidr}""
  enable_dns_hostnames = true
  tags {
    Name = ""${var.env_name}-vpc""
  }
}

resource ""aws_internet_gateway"" ""default"" {
  vpc_id = ""${aws_vpc.default.id}""
}

resource ""aws_subnet"" ""public"" {
  depends_on = [""aws_internet_gateway.default""]
  count = 3
  vpc_id = ""${aws_vpc.default.id}""
  cidr_block = ""${lookup(var.public_cidrs, count.index%3)}""
  availability_zone = ""${lookup(var.availability_zones, count.index%3)}""
  map_public_ip_on_launch = true
  tags {
    Name = ""${var.env_name}-public-subnet-${count.index}""
  }
}

resource ""aws_route_table"" ""public"" {
  vpc_id = ""${aws_vpc.default.id}""
  route {
    cidr_block = ""0.0.0.0/0""
    gateway_id = ""${aws_internet_gateway.default.id}""
  }
}

resource ""aws_route_table_association"" ""public"" {
  count = 3
  subnet_id = ""${element(aws_subnet.public.*.id, count.index%3)}""
  route_table_id = ""${element(aws_route_table.public.*.id, count.index%3)}""
}


resource ""aws_security_group"" ""ucp"" {
    name = ""${var.env_name}-ucp""
    description = ""UCP traffic""
    vpc_id = ""${aws_vpc.default.id}""

  ingress {
    from_port = 22
    to_port = 22
    protocol = ""tcp""
    cidr_blocks = [""${var.allowed_network}""]
  }
  ingress {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    self = true
  }
  ingress {
    from_port = 80
    to_port = 80
    protocol = ""tcp""
    security_groups = [""${aws_security_group.elb.id}""]
  }
  ingress {
    from_port = 443
    to_port = 443
    protocol = ""tcp""
    security_groups = [""${aws_security_group.elb.id}""]
  }
  egress {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}

resource ""aws_security_group"" ""dtr"" {
    name = ""${var.env_name}-dtr""
    description = ""DTR traffic""
    vpc_id = ""${aws_vpc.default.id}""

  ingress {
    from_port = 22
    to_port = 22
    protocol = ""tcp""
    cidr_blocks = [""${var.allowed_network}""]
  }
  ingress {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    self = true
  }
  egress {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}

resource ""aws_security_group"" ""elb"" {
    name = ""${var.env_name}-elb""
    description = ""ELB traffic""
    vpc_id = ""${aws_vpc.default.id}""

  ingress {
    from_port = 80
    to_port = 80
    protocol = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }
  ingress {
    from_port = 443
    to_port = 443
    protocol = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }
  egress {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}




resource ""aws_iam_instance_profile"" ""default"" {
    name = ""${var.env_name}-default""
    roles = [""${aws_iam_role.default.name}""]
}

resource ""aws_iam_role_policy"" ""default"" {
    name = ""${var.env_name}-default-policy""
    role = ""${aws_iam_role.default.id}""
    policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Statement"": [
    {
      ""Effect"": ""Allow"",
      ""Action"": ""ec2:DescribeTags"",
      ""Resource"": ""*""
    },
      {
        ""Effect"": ""Allow"",
        ""Action"": [
          ""s3:ListBucket"",
          ""s3:GetBucketLocation"",
          ""s3:ListBucketMultipartUploads""
        ],
        ""Resource"": ""arn:aws:s3:::${aws_s3_bucket.dtr-bucket.id}""
      },
      {
        ""Effect"": ""Allow"",
        ""Action"": [
          ""s3:PutObject"",
          ""s3:GetObject"",
          ""s3:DeleteObject"",
          ""s3:ListMultipartUploadParts"",
          ""s3:AbortMultipartUpload""
        ],
        ""Resource"": ""arn:aws:s3:::${aws_s3_bucket.dtr-bucket.id}/*""
      }
  ]
}
EOF
}

resource ""aws_iam_role"" ""default"" {
    name = ""${var.env_name}-default-role""
    assume_role_policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Statement"": [
    {
      ""Action"": ""sts:AssumeRole"",
      ""Principal"": {
        ""Service"": ""ec2.amazonaws.com""
      },
      ""Effect"": ""Allow"",
      ""Sid"": """"
    }
  ]
}
EOF
}


resource ""aws_instance"" ""ucp-manager"" {
  connection {
    user = ""${var.ec2_user}""
    key_file = ""${var.key_path}""
  }
  ami = ""${lookup(var.ubuntu_amis, var.region)}""
  instance_type = ""${var.manager_type}""
  iam_instance_profile = ""${aws_iam_instance_profile.default.id}""
  count = ""${var.manager_count}""
  key_name = ""${var.key_name}""
  user_data = ""${file(""./files/userdata.sh"")}""
  vpc_security_group_ids = [
    ""${aws_security_group.ucp.id}"",
  ]
  subnet_id = ""${element(aws_subnet.public.*.id, count.index)}""
  tags = {
    Name = ""${var.env_name}-ucp-manager${count.index}""
    role = ""ucp-manager""
    environment = ""${var.env_name}""
  }
  root_block_device {
    volume_type           = ""gp2""
    volume_size           = 8
    delete_on_termination = true
  }
  ebs_block_device {
    device_name           = ""/dev/sdb""
    snapshot_id           = """"
    volume_type           = ""gp2""
    volume_size           = 20
    delete_on_termination = true
  }
}

output ""ucp-manager-ip"" {
    value = ""${join("","", aws_instance.ucp-manager.*.public_ip)}""
}

resource ""aws_instance"" ""ucp-worker"" {
  connection {
    user = ""${var.ec2_user}""
    key_file = ""${var.key_path}""
  }
  ami = ""${lookup(var.ubuntu_amis, var.region)}""
  instance_type = ""${var.worker_type}""
  iam_instance_profile = ""${aws_iam_instance_profile.default.id}""
  count = ""${var.worker_count}""
  key_name = ""${var.key_name}""
  user_data = ""${file(""./files/userdata.sh"")}""
  vpc_security_group_ids = [
    ""${aws_security_group.ucp.id}"",
  ]
  subnet_id = ""${element(aws_subnet.public.*.id, count.index)}""
  tags = {
    Name = ""${var.env_name}-ucp-worker${count.index}""
    role = ""ucp-worker""
    environment = ""${var.env_name}""
  }
  root_block_device {
    volume_type           = ""gp2""
    volume_size           = 8
    delete_on_termination = true
  }
  ebs_block_device {
    device_name           = ""/dev/sdb""
    snapshot_id           = """"
    volume_type           = ""gp2""
    volume_size           = 20
    delete_on_termination = true
  }
}

output ""ucp-worker-ip"" {
    value = ""${join("","", aws_instance.ucp-worker.*.public_ip)}""
}


resource ""aws_elb"" ""ucp"" {
    name = ""${var.env_name}-ucp""
    subnets = [""${aws_subnet.public.*.id}""]
    security_groups = [
        ""${aws_security_group.elb.id}"",
    ]

    listener {
        instance_port = 80
        instance_protocol = ""http""
        lb_port = 80
        lb_protocol = ""http""
    }

    listener {
        instance_port = 443
        instance_protocol = ""tcp""
        lb_port = 443
        lb_protocol = ""tcp""
    }

    health_check {
        healthy_threshold = 2
        unhealthy_threshold = 2
        timeout = 3
        target = ""TCP:443""
        interval = 15
    }

    instances = [""${aws_instance.ucp-manager.*.id}""]
    cross_zone_load_balancing = true

    tags {
        Name = ""${var.env_name}-ucp""
    }
}

resource ""aws_elb"" ""dtr"" {
    name = ""${var.env_name}-dtr""
    subnets = [""${aws_subnet.public.*.id}""]
    security_groups = [
        ""${aws_security_group.elb.id}"",
    ]

    listener {
        instance_port = 80
        instance_protocol = ""http""
        lb_port = 80
        lb_protocol = ""http""
    }

    listener {
        instance_port = 443
        instance_protocol = ""tcp""
        lb_port = 443
        lb_protocol = ""tcp""
    }

    health_check {
        healthy_threshold = 2
        unhealthy_threshold = 2
        timeout = 3
        target = ""TCP:443""
        interval = 15
    }

    instances = [""${aws_instance.ucp-worker.*.id}""]
    cross_zone_load_balancing = true

    tags {
        Name = ""${var.env_name}-dtr""
    }
}


resource ""aws_s3_bucket"" ""dtr-bucket"" {
    bucket = ""${var.env_name}-dtr-bucket""
    acl = ""private""
    tags {
        Name = ""${var.env_name}-dtr-bucket""
        Environment = ""${var.env_name}""
    }
}

output ""s3_bucket"" {
    value = ""${aws_s3_bucket.dtr-bucket.id}""
}


resource ""aws_route53_zone"" ""ddc"" {
  name = ""${var.zone_name}""
  tags {
    Environment = ""${var.env_name}""
  }
}

resource ""aws_route53_record"" ""ddc-ns"" {
    zone_id = ""${aws_route53_zone.ddc.zone_id}""
    name = ""${var.zone_name}""
    type = ""NS""
    ttl = ""30""
    records = [
        ""${aws_route53_zone.ddc.name_servers.0}"",
        ""${aws_route53_zone.ddc.name_servers.1}"",
        ""${aws_route53_zone.ddc.name_servers.2}"",
        ""${aws_route53_zone.ddc.name_servers.3}""
    ]
}

resource ""aws_route53_record"" ""ucp"" {
  zone_id = ""${aws_route53_zone.ddc.zone_id}""
  name = ""${var.ucp_dns}""
  type = ""CNAME""
  ttl = ""300""
  records = [""${aws_elb.ucp.dns_name}""]
}

resource ""aws_route53_record"" ""dtr"" {
  zone_id = ""${aws_route53_zone.ddc.zone_id}""
  name = ""${var.dtr_dns}""
  type = ""CNAME""
  ttl = ""300""
  records = [""${aws_elb.dtr.dns_name}""]
}

resource ""aws_route53_record"" ""ucp-manager"" {
  count = ""${var.manager_count}""
  zone_id = ""${aws_route53_zone.ddc.zone_id}""
  name = ""ucp-manager${count.index}.${var.zone_name}""
  type = ""A""
  ttl = ""300""
  records = [""${element(aws_instance.ucp-manager.*.public_ip, count.index)}""]
}

resource ""aws_route53_record"" ""ucp-worker"" {
  count = ""${var.worker_count}""
  zone_id = ""${aws_route53_zone.ddc.zone_id}""
  name = ""ucp-worker${count.index}.${var.zone_name}""
  type = ""A""
  ttl = ""300""
  records = [""${element(aws_instance.ucp-worker.*.public_ip, count.index)}""]
}

output ""ucp_manager_host_dns"" {
  value = ""${join("","", aws_route53_record.ucp-manager.*.name)}""
}

output ""ucp_worker_host_dns"" {
  value = ""${join("","", aws_route53_record.ucp-worker.*.name)}""
}

output ""ucp_dns"" {
  value = ""${var.ucp_dns}""
}

output ""dtr_dns"" {
  value = ""${var.dtr_dns}""
}


","{
  ""userQuery1"": ""The user wants to set up an AWS environment with a specific access key, secret key, and region. The user also wants to specify the CIDR of the network that is allowed to SSH to the servers, the name of the keypair to use in EC2, and the name of the DNS hosted zone."",
  ""userQuery2"": ""The user intends to create a VPC with a specific CIDR block and DNS hostnames enabled. They also want to create an internet gateway attached to this VPC, and three public subnets within this VPC, each with a specific CIDR block and availability zone. The user also wants to create a route table associated with these subnets, and a security group for UCP, DTR, and ELB traffic."",
  ""userQuery3"": ""The user wants to create an IAM instance profile, role, and policy with specific permissions. They also want to create UCP manager and worker instances"
40,terraform-google-modules,terraform-google-vm,test/fixtures/mig/healthcheck,"/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">=0.12.6""
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""project_id"" {
  description = ""The GCP project to use for integration tests""
}

variable ""service_account"" {
  default = null
  type = object({
    email  = string
    scopes = list(string)
  })
  description = ""Service account to attach to the instance. See https://www.terraform.io/docs/providers/google/r/compute_instance_template#service_account.""
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ""mig_healthcheck"" {
  source          = ""../../../../examples/mig/healthcheck""
  project_id      = var.project_id
  service_account = var.service_account
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""project_id"" {
  description = ""The GCP project to use for integration tests""
  value       = var.project_id
}

output ""region"" {
  description = ""The GCP region to create and test resources in""
  value       = module.mig_healthcheck.region
}





","{
  ""userQuery1"": ""What is the minimum version of Terraform required to run this configuration?"",
  ""userQuery2"": ""What is the Google Cloud Platform (GCP) project ID to be used for integration tests?"",
  ""userQuery3"": ""What is the service account to be attached to the instance? What are its email and scopes?"",
  ""userQuery4"": ""What is the source of the 'mig_healthcheck' module and what are its project ID and service account?"",
  ""userQuery5"": ""What is the GCP project ID to be used for integration tests, as an output?"",
  ""userQuery6"": ""What is the GCP region to create and test resources in, as an output?""
}"
41,terraform-google-modules,terraform-google-lb-http,modules/dynamic_backends,"/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">= 1.3""
  required_providers {

    google = {
      source  = ""hashicorp/google""
      version = "">= 4.50, < 6""
    }
    google-beta = {
      source  = ""hashicorp/google-beta""
      version = "">= 4.50, < 6""
    }
    random = {
      source  = ""hashicorp/random""
      version = "">= 2.1""
    }
  }

  provider_meta ""google"" {
    module_name = ""blueprints/terraform/terraform-google-lb-http:dynamic_backends/v10.0.0""
  }

  provider_meta ""google-beta"" {
    module_name = ""blueprints/terraform/terraform-google-lb-http:dynamic_backends/v10.0.0""
  }

}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""project"" {
  description = ""The project to deploy to, if not set the default provider project is used.""
  type        = string
}

variable ""name"" {
  description = ""Name for the forwarding rule and prefix for supporting resources""
  type        = string
}

variable ""create_address"" {
  type        = bool
  description = ""Create a new global IPv4 address""
  default     = true
}

variable ""address"" {
  type        = string
  description = ""Existing IPv4 address to use (the actual IP address value)""
  default     = null
}

variable ""enable_ipv6"" {
  type        = bool
  description = ""Enable IPv6 address on the CDN load-balancer""
  default     = false
}

variable ""create_ipv6_address"" {
  type        = bool
  description = ""Allocate a new IPv6 address. Conflicts with \""ipv6_address\"" - if both specified, \""create_ipv6_address\"" takes precedence.""
  default     = false
}

variable ""ipv6_address"" {
  type        = string
  description = ""An existing IPv6 address to use (the actual IP address value)""
  default     = null
}

variable ""firewall_networks"" {
  description = ""Names of the networks to create firewall rules in""
  type        = list(string)
  default     = [""default""]
}

variable ""firewall_projects"" {
  description = ""Names of the projects to create firewall rules in""
  type        = list(string)
  default     = [""default""]
}

variable ""target_tags"" {
  description = ""List of target tags for health check firewall rule. Exactly one of target_tags or target_service_accounts should be specified.""
  type        = list(string)
  default     = []
}

variable ""target_service_accounts"" {
  description = ""List of target service accounts for health check firewall rule. Exactly one of target_tags or target_service_accounts should be specified.""
  type        = list(string)
  default     = []
}

variable ""backends"" {
  description = ""Map backend indices to list of backend maps.""
  type = map(object({
    port                    = optional(number)
    project                 = optional(string)
    protocol                = optional(string)
    port_name               = optional(string)
    description             = optional(string)
    enable_cdn              = optional(bool)
    compression_mode        = optional(string)
    security_policy         = optional(string, null)
    edge_security_policy    = optional(string, null)
    custom_request_headers  = optional(list(string))
    custom_response_headers = optional(list(string))

    timeout_sec                     = optional(number)
    connection_draining_timeout_sec = optional(number)
    session_affinity                = optional(string)
    affinity_cookie_ttl_sec         = optional(number)
    locality_lb_policy              = optional(string)

    health_check = object({
      host                = optional(string)
      request_path        = optional(string)
      request             = optional(string)
      response            = optional(string)
      port                = optional(number)
      port_name           = optional(string)
      proxy_header        = optional(string)
      port_specification  = optional(string)
      protocol            = optional(string)
      check_interval_sec  = optional(number)
      timeout_sec         = optional(number)
      healthy_threshold   = optional(number)
      unhealthy_threshold = optional(number)
      logging             = optional(bool)
    })

    log_config = object({
      enable      = optional(bool)
      sample_rate = optional(number)
    })

    groups = list(object({
      group = string

      balancing_mode               = optional(string)
      capacity_scaler              = optional(number)
      description                  = optional(string)
      max_connections              = optional(number)
      max_connections_per_instance = optional(number)
      max_connections_per_endpoint = optional(number)
      max_rate                     = optional(number)
      max_rate_per_instance        = optional(number)
      max_rate_per_endpoint        = optional(number)
      max_utilization              = optional(number)
    }))
    iap_config = object({
      enable               = bool
      oauth2_client_id     = optional(string)
      oauth2_client_secret = optional(string)
    })
    cdn_policy = optional(object({
      cache_mode                   = optional(string)
      signed_url_cache_max_age_sec = optional(string)
      default_ttl                  = optional(number)
      max_ttl                      = optional(number)
      client_ttl                   = optional(number)
      negative_caching             = optional(bool)
      negative_caching_policy = optional(object({
        code = optional(number)
        ttl  = optional(number)
      }))
      serve_while_stale = optional(number)
      cache_key_policy = optional(object({
        include_host           = optional(bool)
        include_protocol       = optional(bool)
        include_query_string   = optional(bool)
        query_string_blacklist = optional(list(string))
        query_string_whitelist = optional(list(string))
        include_http_headers   = optional(list(string))
        include_named_cookies  = optional(list(string))
      }))
      bypass_cache_on_request_headers = optional(list(string))
    }))
    outlier_detection = optional(object({
      base_ejection_time = optional(object({
        seconds = number
        nanos   = optional(number)
      }))
      consecutive_errors                    = optional(number)
      consecutive_gateway_failure           = optional(number)
      enforcing_consecutive_errors          = optional(number)
      enforcing_consecutive_gateway_failure = optional(number)
      enforcing_success_rate                = optional(number)
      interval = optional(object({
        seconds = number
        nanos   = optional(number)
      }))
      max_ejection_percent        = optional(number)
      success_rate_minimum_hosts  = optional(number)
      success_rate_request_volume = optional(number)
      success_rate_stdev_factor   = optional(number)
    }))
  }))
}

variable ""create_url_map"" {
  description = ""Set to `false` if url_map variable is provided.""
  type        = bool
  default     = true
}

variable ""url_map"" {
  description = ""The url_map resource to use. Default is to send all traffic to first backend.""
  type        = string
  default     = null
}

variable ""http_forward"" {
  description = ""Set to `false` to disable HTTP port 80 forward""
  type        = bool
  default     = true
}

variable ""ssl"" {
  description = ""Set to `true` to enable SSL support. If `true` then at least one of these are required: 1) `ssl_certificates` OR 2) `create_ssl_certificate` set to `true` and `private_key/certificate` OR  3) `managed_ssl_certificate_domains`, OR 4) `certificate_map`""
  type        = bool
  default     = false
}

variable ""create_ssl_certificate"" {
  description = ""If `true`, Create certificate using `private_key/certificate`""
  type        = bool
  default     = false
}

variable ""ssl_certificates"" {
  description = ""SSL cert self_link list. Requires `ssl` to be set to `true`""
  type        = list(string)
  default     = []
}

variable ""private_key"" {
  description = ""Content of the private SSL key. Requires `ssl` to be set to `true` and `create_ssl_certificate` set to `true`""
  type        = string
  default     = null
}

variable ""certificate"" {
  description = ""Content of the SSL certificate. Requires `ssl` to be set to `true` and `create_ssl_certificate` set to `true`""
  type        = string
  default     = null
}

variable ""managed_ssl_certificate_domains"" {
  description = ""Create Google-managed SSL certificates for specified domains. Requires `ssl` to be set to `true`""
  type        = list(string)
  default     = []
}

variable ""certificate_map"" {
  description = ""Certificate Map ID in format projects/{project}/locations/global/certificateMaps/{name}. Identifies a certificate map associated with the given target proxy.  Requires `ssl` to be set to `true`""
  type        = string
  default     = null
}

variable ""ssl_policy"" {
  type        = string
  description = ""Selfink to SSL Policy""
  default     = null
}

variable ""quic"" {
  type        = bool
  description = ""Specifies the QUIC override policy for this resource. Set true to enable HTTP/3 and Google QUIC support, false to disable both. Defaults to null which enables support for HTTP/3 only.""
  default     = null
}

variable ""edge_security_policy"" {
  description = ""The resource URL for the edge security policy to associate with the backend service""
  type        = string
  default     = null
}

variable ""security_policy"" {
  description = ""The resource URL for the security policy to associate with the backend service""
  type        = string
  default     = null
}

variable ""https_redirect"" {
  description = ""Set to `true` to enable https redirect on the lb.""
  type        = bool
  default     = false
}

variable ""random_certificate_suffix"" {
  description = ""Bool to enable/disable random certificate name generation. Set and keep this to true if you need to change the SSL cert.""
  type        = bool
  default     = false
}

variable ""labels"" {
  description = ""The labels to attach to resources created by this module""
  type        = map(string)
  default     = {}
}

variable ""load_balancing_scheme"" {
  description = ""Load balancing scheme type (EXTERNAL for classic external load balancer, EXTERNAL_MANAGED for Envoy-based load balancer, and INTERNAL_SELF_MANAGED for traffic director)""
  type        = string
  default     = ""EXTERNAL""
}

variable ""network"" {
  description = ""Network for INTERNAL_SELF_MANAGED load balancing scheme""
  type        = string
  default     = ""default""
}

variable ""server_tls_policy"" {
  description = ""The resource URL for the server TLS policy to associate with the https proxy service""
  type        = string
  default     = null
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


locals {
  address      = var.create_address ? join("""", google_compute_global_address.default.*.address) : var.address
  ipv6_address = var.create_ipv6_address ? join("""", google_compute_global_address.default_ipv6.*.address) : var.ipv6_address

  url_map             = var.create_url_map ? join("""", google_compute_url_map.default.*.self_link) : var.url_map
  create_http_forward = var.http_forward || var.https_redirect

  health_checked_backends = { for backend_index, backend_value in var.backends : backend_index => backend_value if backend_value[""health_check""] != null }

  is_internal      = var.load_balancing_scheme == ""INTERNAL_SELF_MANAGED""
  internal_network = local.is_internal ? var.network : null
}

### IPv4 block ###
resource ""google_compute_global_forwarding_rule"" ""http"" {
  provider              = google-beta
  project               = var.project
  count                 = local.create_http_forward ? 1 : 0
  name                  = var.name
  target                = google_compute_target_http_proxy.default[0].self_link
  ip_address            = local.address
  port_range            = ""80""
  labels                = var.labels
  load_balancing_scheme = var.load_balancing_scheme
  network               = local.internal_network
}

resource ""google_compute_global_forwarding_rule"" ""https"" {
  provider              = google-beta
  project               = var.project
  count                 = var.ssl ? 1 : 0
  name                  = ""${var.name}-https""
  target                = google_compute_target_https_proxy.default[0].self_link
  ip_address            = local.address
  port_range            = ""443""
  labels                = var.labels
  load_balancing_scheme = var.load_balancing_scheme
  network               = local.internal_network
}

resource ""google_compute_global_address"" ""default"" {
  provider   = google-beta
  count      = local.is_internal ? 0 : var.create_address ? 1 : 0
  project    = var.project
  name       = ""${var.name}-address""
  ip_version = ""IPV4""
  labels     = var.labels
}
### IPv4 block ###

### IPv6 block ###
resource ""google_compute_global_forwarding_rule"" ""http_ipv6"" {
  provider              = google-beta
  project               = var.project
  count                 = (var.enable_ipv6 && local.create_http_forward) ? 1 : 0
  name                  = ""${var.name}-ipv6-http""
  target                = google_compute_target_http_proxy.default[0].self_link
  ip_address            = local.ipv6_address
  port_range            = ""80""
  labels                = var.labels
  load_balancing_scheme = var.load_balancing_scheme
  network               = local.internal_network
}

resource ""google_compute_global_forwarding_rule"" ""https_ipv6"" {
  provider              = google-beta
  project               = var.project
  count                 = var.enable_ipv6 && var.ssl ? 1 : 0
  name                  = ""${var.name}-ipv6-https""
  target                = google_compute_target_https_proxy.default[0].self_link
  ip_address            = local.ipv6_address
  port_range            = ""443""
  labels                = var.labels
  load_balancing_scheme = var.load_balancing_scheme
  network               = local.internal_network
}

resource ""google_compute_global_address"" ""default_ipv6"" {
  provider   = google-beta
  count      = local.is_internal ? 0 : (var.enable_ipv6 && var.create_ipv6_address) ? 1 : 0
  project    = var.project
  name       = ""${var.name}-ipv6-address""
  ip_version = ""IPV6""
  labels     = var.labels
}
### IPv6 block ###

# HTTP proxy when http forwarding is true
resource ""google_compute_target_http_proxy"" ""default"" {
  project = var.project
  count   = local.create_http_forward ? 1 : 0
  name    = ""${var.name}-http-proxy""
  url_map = var.https_redirect == false ? local.url_map : join("""", google_compute_url_map.https_redirect.*.self_link)
}

# HTTPS proxy when ssl is true
resource ""google_compute_target_https_proxy"" ""default"" {
  project = var.project
  count   = var.ssl ? 1 : 0
  name    = ""${var.name}-https-proxy""
  url_map = local.url_map

  ssl_certificates  = compact(concat(var.ssl_certificates, google_compute_ssl_certificate.default.*.self_link, google_compute_managed_ssl_certificate.default.*.self_link, ), )
  certificate_map   = var.certificate_map != null ? ""//certificatemanager.googleapis.com/${var.certificate_map}"" : null
  ssl_policy        = var.ssl_policy
  quic_override     = var.quic == null ? ""NONE"" : var.quic ? ""ENABLE"" : ""DISABLE""
  server_tls_policy = var.server_tls_policy
}

resource ""google_compute_ssl_certificate"" ""default"" {
  project     = var.project
  count       = var.ssl && var.create_ssl_certificate ? 1 : 0
  name_prefix = ""${var.name}-certificate-""
  private_key = var.private_key
  certificate = var.certificate

  lifecycle {
    create_before_destroy = true
  }
}

resource ""random_id"" ""certificate"" {
  count       = var.random_certificate_suffix == true ? 1 : 0
  byte_length = 4
  prefix      = ""${var.name}-cert-""

  keepers = {
    domains = join("","", var.managed_ssl_certificate_domains)
  }
}

resource ""google_compute_managed_ssl_certificate"" ""default"" {
  provider = google-beta
  project  = var.project
  count    = var.ssl && length(var.managed_ssl_certificate_domains) > 0 ? 1 : 0
  name     = var.random_certificate_suffix == true ? random_id.certificate[0].hex : ""${var.name}-cert""

  lifecycle {
    create_before_destroy = true
  }

  managed {
    domains = var.managed_ssl_certificate_domains
  }
}

resource ""google_compute_url_map"" ""default"" {
  provider        = google-beta
  project         = var.project
  count           = var.create_url_map ? 1 : 0
  name            = ""${var.name}-url-map""
  default_service = google_compute_backend_service.default[keys(var.backends)[0]].self_link
}

resource ""google_compute_url_map"" ""https_redirect"" {
  project = var.project
  count   = var.https_redirect ? 1 : 0
  name    = ""${var.name}-https-redirect""
  default_url_redirect {
    https_redirect         = true
    redirect_response_code = ""MOVED_PERMANENTLY_DEFAULT""
    strip_query            = false
  }
}

resource ""google_compute_backend_service"" ""default"" {
  provider = google-beta
  for_each = var.backends

  project = coalesce(each.value[""project""], var.project)
  name    = ""${var.name}-backend-${each.key}""

  load_balancing_scheme = var.load_balancing_scheme

  port_name = lookup(each.value, ""port_name"", ""http"")
  protocol  = lookup(each.value, ""protocol"", ""HTTP"")

  timeout_sec                     = lookup(each.value, ""timeout_sec"", null)
  description                     = lookup(each.value, ""description"", null)
  connection_draining_timeout_sec = lookup(each.value, ""connection_draining_timeout_sec"", null)
  enable_cdn                      = lookup(each.value, ""enable_cdn"", false)
  compression_mode                = lookup(each.value, ""compression_mode"", ""DISABLED"")
  custom_request_headers          = lookup(each.value, ""custom_request_headers"", [])
  custom_response_headers         = lookup(each.value, ""custom_response_headers"", [])
  session_affinity                = lookup(each.value, ""session_affinity"", null)
  affinity_cookie_ttl_sec         = lookup(each.value, ""affinity_cookie_ttl_sec"", null)
  locality_lb_policy              = lookup(each.value, ""locality_lb_policy"", null)

  health_checks = lookup(each.value, ""health_check"", null) == null ? null : [google_compute_health_check.default[each.key].self_link]

  # To achieve a null backend edge_security_policy, set each.value.edge_security_policy to """" (empty string), otherwise, it fallsback to var.edge_security_policy.
  edge_security_policy = lookup(each.value, ""edge_security_policy"") == """" ? null : (lookup(each.value, ""edge_security_policy"") == null ? var.edge_security_policy : each.value.edge_security_policy)

  # To achieve a null backend security_policy, set each.value.security_policy to """" (empty string), otherwise, it fallsback to var.security_policy.
  security_policy = lookup(each.value, ""security_policy"") == """" ? null : (lookup(each.value, ""security_policy"") == null ? var.security_policy : each.value.security_policy)

  dynamic ""backend"" {
    for_each = toset(each.value[""groups""])
    content {
      description = lookup(backend.value, ""description"", null)
      group       = lookup(backend.value, ""group"")

      balancing_mode               = lookup(backend.value, ""balancing_mode"")
      capacity_scaler              = lookup(backend.value, ""capacity_scaler"")
      max_connections              = lookup(backend.value, ""max_connections"")
      max_connections_per_instance = lookup(backend.value, ""max_connections_per_instance"")
      max_connections_per_endpoint = lookup(backend.value, ""max_connections_per_endpoint"")
      max_rate                     = lookup(backend.value, ""max_rate"")
      max_rate_per_instance        = lookup(backend.value, ""max_rate_per_instance"")
      max_rate_per_endpoint        = lookup(backend.value, ""max_rate_per_endpoint"")
      max_utilization              = lookup(backend.value, ""max_utilization"")
    }
  }

  dynamic ""log_config"" {
    for_each = lookup(lookup(each.value, ""log_config"", {}), ""enable"", true) ? [1] : []
    content {
      enable      = lookup(lookup(each.value, ""log_config"", {}), ""enable"", true)
      sample_rate = lookup(lookup(each.value, ""log_config"", {}), ""sample_rate"", ""1.0"")
    }
  }

  dynamic ""iap"" {
    for_each = lookup(lookup(each.value, ""iap_config"", {}), ""enable"", false) ? [1] : []
    content {
      oauth2_client_id     = lookup(lookup(each.value, ""iap_config"", {}), ""oauth2_client_id"", """")
      oauth2_client_secret = lookup(lookup(each.value, ""iap_config"", {}), ""oauth2_client_secret"", """")
    }
  }

  dynamic ""cdn_policy"" {
    for_each = each.value.enable_cdn ? [1] : []
    content {
      cache_mode                   = each.value.cdn_policy.cache_mode
      signed_url_cache_max_age_sec = each.value.cdn_policy.signed_url_cache_max_age_sec
      default_ttl                  = each.value.cdn_policy.default_ttl
      max_ttl                      = each.value.cdn_policy.max_ttl
      client_ttl                   = each.value.cdn_policy.client_ttl
      negative_caching             = each.value.cdn_policy.negative_caching
      serve_while_stale            = each.value.cdn_policy.serve_while_stale

      dynamic ""negative_caching_policy"" {
        for_each = each.value.cdn_policy.negative_caching_policy != null ? [1] : []
        content {
          code = each.value.cdn_policy.negative_caching_policy.code
          ttl  = each.value.cdn_policy.negative_caching_policy.ttl
        }
      }

      dynamic ""cache_key_policy"" {
        for_each = each.value.cdn_policy.cache_key_policy != null ? [1] : []
        content {
          include_host           = each.value.cdn_policy.cache_key_policy.include_host
          include_protocol       = each.value.cdn_policy.cache_key_policy.include_protocol
          include_query_string   = each.value.cdn_policy.cache_key_policy.include_query_string
          query_string_blacklist = each.value.cdn_policy.cache_key_policy.query_string_blacklist
          query_string_whitelist = each.value.cdn_policy.cache_key_policy.query_string_whitelist
          include_http_headers   = each.value.cdn_policy.cache_key_policy.include_http_headers
          include_named_cookies  = each.value.cdn_policy.cache_key_policy.include_named_cookies
        }
      }

      dynamic ""bypass_cache_on_request_headers"" {
        for_each = toset(each.value.cdn_policy.bypass_cache_on_request_headers) != null ? each.value.cdn_policy.bypass_cache_on_request_headers : []
        content {
          header_name = bypass_cache_on_request_headers.value
        }
      }
    }
  }

  dynamic ""outlier_detection"" {
    for_each = each.value.outlier_detection != null && (var.load_balancing_scheme == ""INTERNAL_SELF_MANAGED"" || var.load_balancing_scheme == ""EXTERNAL_MANAGED"") ? [1] : []
    content {
      consecutive_errors                    = each.value.outlier_detection.consecutive_errors
      consecutive_gateway_failure           = each.value.outlier_detection.consecutive_gateway_failure
      enforcing_consecutive_errors          = each.value.outlier_detection.enforcing_consecutive_errors
      enforcing_consecutive_gateway_failure = each.value.outlier_detection.enforcing_consecutive_gateway_failure
      enforcing_success_rate                = each.value.outlier_detection.enforcing_success_rate
      max_ejection_percent                  = each.value.outlier_detection.max_ejection_percent
      success_rate_minimum_hosts            = each.value.outlier_detection.success_rate_minimum_hosts
      success_rate_request_volume           = each.value.outlier_detection.success_rate_request_volume
      success_rate_stdev_factor             = each.value.outlier_detection.success_rate_stdev_factor

      dynamic ""base_ejection_time"" {
        for_each = each.value.outlier_detection.base_ejection_time != null ? [1] : []
        content {
          seconds = each.value.outlier_detection.base_ejection_time.seconds
          nanos   = each.value.outlier_detection.base_ejection_time.nanos
        }
      }

      dynamic ""interval"" {
        for_each = each.value.outlier_detection.interval != null ? [1] : []
        content {
          seconds = each.value.outlier_detection.interval.seconds
          nanos   = each.value.outlier_detection.interval.nanos
        }
      }
    }
  }

  depends_on = [
    google_compute_health_check.default
  ]

  lifecycle {
    ignore_changes = [backend]
  }
}

resource ""google_compute_health_check"" ""default"" {
  provider = google-beta
  for_each = local.health_checked_backends
  project  = coalesce(each.value[""project""], var.project)
  name     = ""${var.name}-hc-${each.key}""

  check_interval_sec  = lookup(each.value[""health_check""], ""check_interval_sec"", 5)
  timeout_sec         = lookup(each.value[""health_check""], ""timeout_sec"", 5)
  healthy_threshold   = lookup(each.value[""health_check""], ""healthy_threshold"", 2)
  unhealthy_threshold = lookup(each.value[""health_check""], ""unhealthy_threshold"", 2)

  log_config {
    enable = lookup(each.value[""health_check""], ""logging"", false)
  }

  dynamic ""http_health_check"" {
    for_each = coalesce(lookup(each.value[""health_check""], ""protocol"", null), each.value[""protocol""]) == ""HTTP"" ? [
      {
        host               = lookup(each.value[""health_check""], ""host"", null)
        request_path       = lookup(each.value[""health_check""], ""request_path"", null)
        response           = lookup(each.value[""health_check""], ""response"", null)
        port               = lookup(each.value[""health_check""], ""port"", null)
        port_name          = lookup(each.value[""health_check""], ""port_name"", null)
        proxy_header       = lookup(each.value[""health_check""], ""proxy_header"", null)
        port_specification = lookup(each.value[""health_check""], ""port_specification"", null)
      }
    ] : []

    content {
      host               = lookup(http_health_check.value, ""host"", null)
      request_path       = lookup(http_health_check.value, ""request_path"", null)
      response           = lookup(http_health_check.value, ""response"", null)
      port               = lookup(http_health_check.value, ""port"", null)
      port_name          = lookup(http_health_check.value, ""port_name"", null)
      proxy_header       = lookup(http_health_check.value, ""proxy_header"", null)
      port_specification = lookup(http_health_check.value, ""port_specification"", null)
    }
  }

  dynamic ""https_health_check"" {
    for_each = coalesce(lookup(each.value[""health_check""], ""protocol"", null), each.value[""protocol""]) == ""HTTPS"" ? [
      {
        host               = lookup(each.value[""health_check""], ""host"", null)
        request_path       = lookup(each.value[""health_check""], ""request_path"", null)
        response           = lookup(each.value[""health_check""], ""response"", null)
        port               = lookup(each.value[""health_check""], ""port"", null)
        port_name          = lookup(each.value[""health_check""], ""port_name"", null)
        proxy_header       = lookup(each.value[""health_check""], ""proxy_header"", null)
        port_specification = lookup(each.value[""health_check""], ""port_specification"", null)
      }
    ] : []

    content {
      host               = lookup(https_health_check.value, ""host"", null)
      request_path       = lookup(https_health_check.value, ""request_path"", null)
      response           = lookup(https_health_check.value, ""response"", null)
      port               = lookup(https_health_check.value, ""port"", null)
      port_name          = lookup(https_health_check.value, ""port_name"", null)
      proxy_header       = lookup(https_health_check.value, ""proxy_header"", null)
      port_specification = lookup(https_health_check.value, ""port_specification"", null)
    }
  }

  dynamic ""http2_health_check"" {
    for_each = coalesce(lookup(each.value[""health_check""], ""protocol"", null), each.value[""protocol""]) == ""HTTP2"" ? [
      {
        host               = lookup(each.value[""health_check""], ""host"", null)
        request_path       = lookup(each.value[""health_check""], ""request_path"", null)
        response           = lookup(each.value[""health_check""], ""response"", null)
        port               = lookup(each.value[""health_check""], ""port"", null)
        port_name          = lookup(each.value[""health_check""], ""port_name"", null)
        proxy_header       = lookup(each.value[""health_check""], ""proxy_header"", null)
        port_specification = lookup(each.value[""health_check""], ""port_specification"", null)
      }
    ] : []

    content {
      host               = lookup(http2_health_check.value, ""host"", null)
      request_path       = lookup(http2_health_check.value, ""request_path"", null)
      response           = lookup(http2_health_check.value, ""response"", null)
      port               = lookup(http2_health_check.value, ""port"", null)
      port_name          = lookup(http2_health_check.value, ""port_name"", null)
      proxy_header       = lookup(http2_health_check.value, ""proxy_header"", null)
      port_specification = lookup(http2_health_check.value, ""port_specification"", null)
    }
  }

  dynamic ""tcp_health_check"" {
    for_each = coalesce(lookup(each.value[""health_check""], ""protocol"", null), each.value[""protocol""]) == ""TCP"" ? [
      {
        request            = lookup(each.value[""health_check""], ""request"", null)
        response           = lookup(each.value[""health_check""], ""response"", null)
        port               = lookup(each.value[""health_check""], ""port"", null)
        port_name          = lookup(each.value[""health_check""], ""port_name"", null)
        proxy_header       = lookup(each.value[""health_check""], ""proxy_header"", null)
        port_specification = lookup(each.value[""health_check""], ""port_specification"", null)
      }
    ] : []

    content {
      request            = lookup(tcp_health_check.value, ""request"", null)
      response           = lookup(tcp_health_check.value, ""response"", null)
      port               = lookup(tcp_health_check.value, ""port"", null)
      port_name          = lookup(tcp_health_check.value, ""port_name"", null)
      proxy_header       = lookup(tcp_health_check.value, ""proxy_header"", null)
      port_specification = lookup(tcp_health_check.value, ""port_specification"", null)
    }
  }
}

resource ""google_compute_firewall"" ""default-hc"" {
  count   = length(var.firewall_networks)
  project = length(var.firewall_networks) == 1 && var.firewall_projects[0] == ""default"" ? var.project : var.firewall_projects[count.index]
  name    = ""${var.name}-hc-${count.index}""
  network = var.firewall_networks[count.index]
  source_ranges = [
    ""130.211.0.0/22"",
    ""35.191.0.0/16""
  ]
  target_tags             = length(var.target_tags) > 0 ? var.target_tags : null
  target_service_accounts = length(var.target_service_accounts) > 0 ? var.target_service_accounts : null

  dynamic ""allow"" {
    for_each = local.health_checked_backends
    content {
      protocol = ""tcp""
      ports    = [allow.value[""health_check""].port]
    }
  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * di",
"tribute""","{
  ""userQuery1"": ""I need to set up a load balancer for my project. The load balancer should support both IPv4 and IPv6 addresses. I want to have the option to create a new global IPv4 and IPv6 address or use an existing one. The load balancer should also support HTTP and HTTPS protocols, with the ability to enable or disable HTTP port 80 forwarding. I also want to have the option to enable SSL support and create a new SSL certificate or use an existing one."",
  ""userQuery2"": ""I want to set up health checks for my load balancer. The health checks should support HTTP, HTTPS, HTTP2, and TCP protocols. I want to be able to specify the check interval, timeout, healthy threshold, and unhealthy threshold for the health checks. I also want to have the option to enable logging for the health checks."",
  ""userQuery3"": ""I want to set up firewall rules for my load balancer",,,,
42,CloudVLab,terraform-lab-foundation,solutions/ide_web/stable,"provider ""google"" {
  project = var.gcp_project_id
  region  = var.gcp_region
  zone    = var.gcp_zone
}

provider ""google-beta"" {
  project = var.gcp_project_id
  region  = var.gcp_region
  zone    = var.gcp_zone
}


## --------------------------------------------------------------
## Mandatory variable definitions
## --------------------------------------------------------------

variable ""gcp_project_id"" {
  type        = string
  description = ""The GCP project ID to create resources in.""
}

# Default value passed in
variable ""gcp_region"" {
  type        = string
  description = ""Region to create resources in.""
}

# Default value passed in
variable ""gcp_zone"" {
  type        = string
  description = ""Zone to create resources in.""
}

## --------------------------------------------------------------
## Output variable definitions - Override from Custom Properties 
## --------------------------------------------------------------
## Ensure these values are defined in Qwiklabs.yaml
# with the same name for any lab that uses this script.
variable ""gcp_username"" {
  type        = string
  description = ""Name of Qwiklabs user""
  default     = ""tester""
}

## --------------------------------------------------------------
## Custom variable definitions - Override from Custom Properties
## --------------------------------------------------------------

variable ""vpcConnectorMachineType"" {
  type        = string
  description = ""VPC Access Connector Machine Type""
  # Note: valid options: f1-micro, e2-micro, e2-standard-4
  default     = ""e2-micro""
}

# Custom properties with defaults 
variable ""gcrRegion"" {
  type        = string 
  description = ""Region to create resources in.""
  default     = ""us-central1"" 
}

# Custom properties with defaults 
variable ""gceInstanceName"" {
  type        = string 
  description = ""Name of virtual machine.""
  default     = ""cloudlearningservices"" 
}

# Custom properties with defaults 
variable ""gceInstanceZone"" {
  type        = string 
  description = ""Zone to create resources in.""
  default     = ""us-central1-f"" 
}

# Custom properties with defaults 
variable ""gceInstanceTags"" {
  type        = list(string)
  description = ""GCE virtual machine tags""
  default     = [""lab-vm""]
}

variable ""gceMachineImage"" {
  type        = string
  description = ""GCE virtual machine image family""
  default     = ""ide-codeserver""
}

# Custom properties with defaults 
variable ""gceMachineType"" {
  type        = string 
  description = ""Machine type to use for GCE""
  default     = ""e2-standard-2"" 
}

# Custom properties with defaults 
variable ""gceDiskSize"" {
  type        = number 
  description = ""Size of disk to be allocated""
  default     = 100 
}

# Custom properties with defaults 
variable ""gceInstanceNetwork"" {
  type        = string
  description = ""GCE virtual machine network""
  default     = ""default""
}

# Custom properties with defaults 
variable ""gceInstanceScope"" {
  type        = list(string)
  description = ""GCE service account scope""
  default     = [""cloud-platform""]
}


# Module: Virtual Private Cloud 
# https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_network
# https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_subnetwork

module ""la_vpc"" {
  ## NOTE: When changing the source parameter, `terraform init` is required

  ## Local Modules - working
  ## Module subdirectory needs to be defined within the TF directory
  # source = ""./basics/vpc_network/stable""

  ## REMOTE: GitHub (Public) access - working 
  source = ""github.com/CloudVLab/terraform-lab-foundation//basics/vpc_network/stable""

  # Pass values to the module
  gcp_project_id = var.gcp_project_id
  gcp_region     = var.gcp_region
  gcp_zone       = var.gcp_zone

  # Customise the GCS instance
  vpc_network             = ""dev-network""
  vpc_network_description = ""Developer network"" 
  vpc_subnet              = ""dev-subnetwork""
  vpc_region              = ""us-central1"" 
  vpc_subnet_cidr         = ""10.128.0.0/16"" 
}

# Reference:
# https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/vpc_access_connector

module ""la_serverless_vpc_access"" {
  ## NOTE: When changing the source parameter, `terraform init` is required

  ## Local Modules - working
  ## Module subdirectory needs to be defined within the TF directory
  # source = ""./basics/vpc_network/stable""

  ## REMOTE: GitHub (Public) access - working 
  source = ""github.com/CloudVLab/terraform-lab-foundation//basics/vpc_connector/stable""

  # Pass values to the module
  gcp_project_id = var.gcp_project_id
  gcp_region     = var.gcp_region
  gcp_zone       = var.gcp_zone

  # Customise the GCS instance
  sva_name                   = ""ideconn""
  sva_network                = module.la_vpc.vpc_network_name
  sva_subnet_cidr            = ""10.8.0.0/28"" 
  sva_connector_machine_type = ""f1-micro"" 

  depends_on = [ module.la_vpc ]
}

# Reference:
# https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_firewall
# https://github.com/terraform-google-modules/terraform-google-network/tree/master/modules/firewall-rules

module ""la_fw"" {
  ## NOTE: When changing the source parameter, `terraform init` is required

  ## Local Modules - working
  ## Module subdirectory needs to be defined within the TF directory
  # source = ""./basics/vpc_firewall/stable""

  ## REMOTE: GitHub (Public) access - working 
  source = ""github.com/CloudVLab/terraform-lab-foundation//basics/vpc_firewall/stable""

  # Pass values to the module
  gcp_project_id = var.gcp_project_id
  gcp_region     = var.gcp_region
  gcp_zone       = var.gcp_zone

  #fwr_network      = ""default"" 
  fwr_network      = module.la_vpc.vpc_network_name

  fwr_rules = [
  {
    fwr_name                    = ""serverless-to-vpc-connector""
    fwr_description             = ""serverless-to-vpc-connector""
    fwr_source_ranges           = [ ""107.178.230.64/26"", ""35.199.224.0/19"" ]
    fwr_destination_ranges      = null
    fwr_source_tags             = null
    fwr_source_service_accounts = null
    fwr_target_tags             = [""vpc-connector""]
    fwr_target_service_accounts = null
    fwr_priority                = ""1000""
    fwr_direction               = ""INGRESS""

    # Allow List
    allow = [{
      protocol     = ""icmp""
      ports        = null 
    },
    {
      protocol     = ""tcp""
      ports        = [ ""667"" ]
    },
    {
      protocol     = ""udp""
      ports        = [ ""665-666"" ]
    }]

    # Deny List
    deny = []

    log_config = {
      metadata = ""INCLUDE_ALL_METADATA""
    }

  },
  {
    fwr_name                    = ""vpc-connector-to-serverless""
    fwr_description             = ""vpc-connector-to-serverless""
    fwr_source_ranges           = [ ""107.178.230.64/26"", ""35.199.224.0/19"" ]
    fwr_destination_ranges      = null
    fwr_source_tags             = null
    fwr_source_service_accounts = null
    fwr_target_tags             = [""vpc-connector""]
    fwr_target_service_accounts = null
    fwr_priority                = ""1000""
    fwr_direction               = ""EGRESS""

    # Allow List
    allow = [{
      protocol     = ""icmp""
      ports        = null 
    },
    {
      protocol     = ""tcp""
      ports        = [ ""667"" ]
    },
    {
      protocol     = ""udp""
      ports        = [ ""665-666"" ]
    }]

    # Deny List
    deny = []

    log_config = {
      metadata = ""INCLUDE_ALL_METADATA""
    }
  },
  {
    fwr_name                    = ""vpc-connector-health-check""
    fwr_description             = ""vpc-connector-health-check""
    fwr_source_ranges           = [ ""130.211.0.0/22"", ""35.191.0.0/16"", ""108.170.220.0/23"" ]
    fwr_destination_ranges      = null
    fwr_source_tags             = null
    fwr_source_service_accounts = null
    fwr_target_tags             = [""vpc-connector""]
    fwr_target_service_accounts = null
    fwr_priority                = ""1000""
    fwr_direction               = ""INGRESS""

    # Allow List
    allow = [{
      protocol     = ""tcp""
      ports        = [ ""667"" ]
    }]

    # Deny List
    deny = []

    log_config = {
      metadata = ""INCLUDE_ALL_METADATA""
    }
  },
  {
    fwr_name                    = ""vpc-connector-egress""
    fwr_description             = ""vpc-connector-egress""
    fwr_source_ranges           = null 
    fwr_destination_ranges      = null
    fwr_source_tags             = [ ""vpc-connector"" ] 
    fwr_source_service_accounts = null
    fwr_target_tags             = null 
    fwr_target_service_accounts = null
    fwr_priority                = ""1000""
    fwr_direction               = ""INGRESS""

    # Allow List
    allow = [{
      protocol     = ""tcp""
      ports        = null 
    },
    {
      protocol     = ""udp""
      ports        = null 
    },
    {
      protocol     = ""icmp""
      ports        = null 
    }]

    # Deny List
    deny = []

    log_config = {
      metadata = ""INCLUDE_ALL_METADATA""
    }
  }
  ]

  depends_on = [ module.la_vpc.vpc_network_name ]
}

# https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_target_instance
data ""google_compute_image"" ""image_family"" {
  family  = var.gceMachineImage 
  project = ""qwiklabs-resources""
}

# GCE:    Virtual Machine
# Local:  modules/[channel]
# Remote: github.com://CloudVLab/terraform-lab-foundation//[module]/[channel]

# Reference:
# https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/compute_instance
#

# Module: Google Compute Engine
module ""la_gce"" {
  source = ""github.com/CloudVLab/terraform-lab-foundation//basics/gce_instance/stable""

  # Pass values to the module
  gcp_project_id = var.gcp_project_id
  gcp_region     = var.gcp_region
  gcp_zone       = var.gcp_zone
  gcp_username   = var.gcp_username

  # Customise the GCE instance
  gce_name            = var.gceInstanceName
  gce_region          = var.gcp_region
  gce_zone            = var.gceInstanceZone
  gce_machine_type    = var.gceMachineType
  gce_tags            = var.gceInstanceTags 
  gce_machine_image   = data.google_compute_image.image_family.self_link 
  gce_machine_network = module.la_vpc.vpc_subnetwork_name
  #gce_machine_network = module.la_vpc.vpc_network_name
  #gce_machine_network = default 
  gce_scopes          = [""cloud-platform""] 
  gce_disk_size       = var.gceDiskSize 
  #gce_startup_script   = ""${file(""./scripts/lab-init"")}""

  # Dependency - Serverless VPC Access connector 
  depends_on = [ module.la_serverless_vpc_access.sva_connection_name ]
}

# Reference:
# https://registry.terraform.io/providers/hashicorp/google/latest/docs/resources/cloud_run_service
#
# Enable the Cloud Run service
resource ""google_project_service"" ""run"" {
  project = var.gcp_project_id
  service = ""run.googleapis.com""

  timeouts {
    create = ""30m""
    update = ""40m""
  }

  # disable_dependent_services = true
}


resource ""google_cloud_run_service"" ""ide"" {
  name     = ""ide-service"" 
  # location = var.gcrRegion
  location = var.gcp_region

  template {
    spec {
      containers {
        image = ""gcr.io/qwiklabs-resources/ide-proxy:latest""
      }
      container_concurrency = 2
    }

    # Add support for vpc connector
    metadata {
      annotations = {
        ""autoscaling.knative.dev/maxScale"" = ""3""
        ""autoscaling.knative.dev/minScale"" = ""1""
        ""run.googleapis.com/vpc-access-egress"" = ""all""
        # ""run.googleapis.com/vpc-access-connector"" = google_vpc_access_connector.connector.name
        ""run.googleapis.com/vpc-access-connector"" = module.la_serverless_vpc_access.sva_connection_name
      }
    }
  }

  traffic {
    percent = 100
    latest_revision = true
  }

  # Dependency - Cloud Run API enabled
  depends_on = [ google_project_service.run, module.la_gce.gce_instance_name ]
}


resource ""google_cloud_run_service"" ""browser"" {
  name     = ""browser-service""
  # location = var.gcrRegion
  location = var.gcp_region

  template {
    spec {
      containers {
        image = ""gcr.io/qwiklabs-resources/web-proxy:latest""
      }
      container_concurrency = 2
    }

    # Add support for vpc connector
    metadata {
      annotations = {
        ""autoscaling.knative.dev/maxScale"" = ""3""
        ""autoscaling.knative.dev/minScale"" = ""1""
        ""run.googleapis.com/vpc-access-egress"" = ""all""
        # ""run.googleapis.com/vpc-access-connector"" = google_vpc_access_connector.connector.name
        ""run.googleapis.com/vpc-access-connector"" = module.la_serverless_vpc_access.sva_connection_name
      }
    }
  }

  traffic {
    percent = 100
    latest_revision = true
  }

  # Dependency - Cloud Run API enabled
  depends_on = [ google_project_service.run, module.la_gce.gce_instance_name ]
}

data ""google_iam_policy"" ""noauth"" {
  binding {
    role = ""roles/run.invoker""
    members = [
      ""allUsers"",
    ]
  }
}

resource ""google_cloud_run_service_iam_policy"" ""ide_noauth"" {
  location    = google_cloud_run_service.ide.location
  project     = google_cloud_run_service.ide.project
  service     = google_cloud_run_service.ide.name

  policy_data = data.google_iam_policy.noauth.policy_data
}

resource ""google_cloud_run_service_iam_policy"" ""browser_noauth"" {
  location    = google_cloud_run_service.browser.location
  project     = google_cloud_run_service.browser.project
  service     = google_cloud_run_service.browser.name

  policy_data = data.google_iam_policy.noauth.policy_data
}


## --------------------------------------------------------------
## Custom variable defintions
## --------------------------------------------------------------

output ""ideEditorService"" {
  value       = ""${google_cloud_run_service.ide.status[0].url}""
  description = ""URL of the IDE service""
}

output ""ideBrowserService"" {
  value       = ""${google_cloud_run_service.browser.status[0].url}""
  description = ""URL of the Browser service""
}

output ""ideInstanceName"" {
  value       = ""${var.gceInstanceName}""
  description = ""Name of the GCE instance""
}

output ""vpcNetworkName"" {
  value       = ""${module.la_vpc.vpc_network_name}""
  description = ""Name of the GCE instance""
}


","{
  ""userQuery1"": ""The user wants to create a Google Cloud Platform (GCP) project with specific configurations such as project ID, region, and zone. The user also wants to use both the standard and beta versions of the Google provider."",
  ""userQuery2"": ""The user wants to create a Virtual Private Cloud (VPC) with a specific network, subnet, and firewall rules. The user also wants to create a Serverless VPC Access connector for the VPC."",
  ""userQuery3"": ""The user wants to create a Google Compute Engine (GCE) instance with specific configurations such as machine type, disk size, and network. The user also wants to use a specific image for the GCE instance."",
  ""userQuery4"": ""The user wants to enable the Cloud Run service in the GCP project and create two Cloud Run services, 'ide-service' and 'browser-service', with specific configurations. The user also wants to allow all users"
43,glaucius,aws-terraform,,"### Definiao de provider
provider ""aws"" {
    region = var.AWS_REGION
}

variable ""AWS_REGION"" {
  default = ""us-east-1""
}

variable ""AWS_REGION_AZ_WEB_1"" {
  default = ""us-east-1a""
}
variable ""AWS_REGION_AZ_WEB_2"" {
  default = ""us-east-1b""
}
variable ""AWS_REGION_AZ_WEB_3"" {
  default = ""us-east-1c""
}
variable ""AWS_REGION_AZ_DB"" {
  default = ""us-east-1b""
}

variable ""PRIVATE_KEY_PATH"" {
  default = ""minha-chave-ssh""
}

variable ""PUBLIC_KEY_PATH"" {
  default = ""minha-chave-ssh.pub""
}

variable ""BUCKET_ELB"" {
  default = ""bucketelbglauciusha20192020""
}


### Criao de Internet Nat Gateway
resource ""aws_internet_gateway"" ""prod-igw"" {
  vpc_id = aws_vpc.prod-vpc.id

  tags = {
    Name = ""prod-igw""
  }
}

### Criao de rota customizadas para subnets pblicas
resource ""aws_route_table"" ""prod-public-crt"" {
    vpc_id = aws_vpc.prod-vpc.id
    route {
        cidr_block = ""0.0.0.0/0""
        gateway_id = aws_internet_gateway.prod-igw.id
    }

    tags = {
        Name = ""prod-public-crt""
    }
}

### Associar rota para subnets pblicas
resource ""aws_route_table_association"" ""prod-crta-public-subnet-1"" {
    subnet_id = aws_subnet.prod-subnet-public-1.id
    route_table_id = aws_route_table.prod-public-crt.id
}
resource ""aws_route_table_association"" ""prod-crta-public-subnet-2"" {
    subnet_id = aws_subnet.prod-subnet-public-2.id
    route_table_id = aws_route_table.prod-public-crt.id
}
resource ""aws_route_table_association"" ""prod-crta-public-subnet-3"" {
    subnet_id = aws_subnet.prod-subnet-public-3.id
    route_table_id = aws_route_table.prod-public-crt.id
}

### Criao de Elastic IP para NAT Gateway
resource ""aws_eip"" ""nat"" {
vpc      = true
    tags = {
        Name = ""prod-elastic-ip-crt""
    }
}

### Criao de NAT Gateway
resource ""aws_nat_gateway"" ""nat-gw"" {
allocation_id = aws_eip.nat.id
subnet_id = aws_subnet.prod-subnet-public-1.id
depends_on = [aws_internet_gateway.prod-igw]
    tags = {
        Name = ""prod-nat-gateway-crt""
    }
}

### Criao de rotas customizadas para subnets privadas
resource ""aws_route_table"" ""prod-private-crt"" {
    vpc_id = aws_vpc.prod-vpc.id
    route {
        cidr_block = ""0.0.0.0/0"" //associated subnet can reach everywhere
        nat_gateway_id = aws_nat_gateway.nat-gw.id
    }

    tags = {
        Name = ""prod-private-crt""
    }
}

### Associar rota para subnets privadas
resource ""aws_route_table_association"" ""private-1"" {
    subnet_id = aws_subnet.prod-subnet-private-1.id
    route_table_id = aws_route_table.prod-private-crt.id
}


### Security Groups

### SG para Webservers - subnet pblica
resource ""aws_security_group"" ""webservers"" {
  name        = ""webservers""
  description = ""Allow webservers""
    vpc_id = aws_vpc.prod-vpc.id

    egress {
        from_port = 0
        to_port = 0
        protocol = -1
        cidr_blocks = [""0.0.0.0/0""]
    }

  ingress {
    # TLS (change to whatever ports you need)
    from_port   = 22
    to_port     = 22
    protocol    = ""tcp""
    # Please restrict your ingress to only necessary IPs and ports.
    # Opening to 0.0.0.0/0 can lead to security vulnerabilities.
    cidr_blocks = [""0.0.0.0/0""]
    
  }

  ingress {
    # TLS (change to whatever ports you need)
    from_port   = 80
    to_port     = 80
    protocol    = ""tcp""
    # Please restrict your ingress to only necessary IPs and ports.
    # Opening to 0.0.0.0/0 can lead to security vulnerabilities.
    cidr_blocks = [""0.0.0.0/0""]
    
  }

  ingress {
    # TLS (change to whatever ports you need)
    from_port   = 443
    to_port     = 443
    protocol    = ""tcp""
    # Please restrict your ingress to only necessary IPs and ports.
    # Opening to 0.0.0.0/0 can lead to security vulnerabilities.
    cidr_blocks = [""0.0.0.0/0""]
    
  }


}


### SG para DBservers - Subnet privada
resource ""aws_security_group"" ""dbservers"" {
  name        = ""dbservers""
  description = ""Allow dbservers""
    vpc_id = aws_vpc.prod-vpc.id

    egress {
        from_port = 0
        to_port = 0
        protocol = -1
        cidr_blocks = [""0.0.0.0/0""]
    }

  ingress {
    # TLS (change to whatever ports you need)
    from_port   = 22
    to_port     = 22
    protocol    = ""tcp""
    # Please restrict your ingress to only necessary IPs and ports.
    # Opening to 0.0.0.0/0 can lead to security vulnerabilities.
    cidr_blocks = [""0.0.0.0/0""]
    
  }

  ingress {
    from_port = -1
    to_port = -1
    protocol = ""icmp""
    cidr_blocks = [""10.0.0.0/16""]
  }
  ingress {
    # TLS (change to whatever ports you need)
    from_port   = 3306
    to_port     = 3306
    protocol    = ""tcp""
    # Please restrict your ingress to only necessary IPs and ports.
    # Opening to 0.0.0.0/0 can lead to security vulnerabilities.
    cidr_blocks = [""10.0.0.0/16""]
    
  }

}

### Criao de VPC
resource ""aws_vpc"" ""prod-vpc"" {
  cidr_block       = ""10.0.0.0/16""
  instance_tenancy = ""default""

  tags = {
    Name = ""prod-vpc""
  }
}

### Subnet Pblica Web

resource ""aws_subnet"" ""prod-subnet-public-1"" {
  vpc_id     = aws_vpc.prod-vpc.id
  cidr_block = ""10.0.1.0/24""
    map_public_ip_on_launch = ""true"" //it makes this a public subnet
  availability_zone = var.AWS_REGION_AZ_WEB_1
  tags = {
    Name = ""prod-subnet-public-1""
  }
}

resource ""aws_subnet"" ""prod-subnet-public-2"" {
  vpc_id     = aws_vpc.prod-vpc.id
  cidr_block = ""10.0.2.0/24""
    map_public_ip_on_launch = ""true"" //it makes this a public subnet
  availability_zone = var.AWS_REGION_AZ_WEB_2
  tags = {
    Name = ""prod-subnet-public-2""
  }
}

resource ""aws_subnet"" ""prod-subnet-public-3"" {
  vpc_id     = aws_vpc.prod-vpc.id
  cidr_block = ""10.0.3.0/24""
    map_public_ip_on_launch = ""true"" //it makes this a public subnet
  availability_zone = var.AWS_REGION_AZ_WEB_3
  tags = {
    Name = ""prod-subnet-public-3""
  }
}

### Subnet Privada DB

resource ""aws_subnet"" ""prod-subnet-private-1"" {
  vpc_id     = aws_vpc.prod-vpc.id
  cidr_block = ""10.0.10.0/24""
    map_public_ip_on_launch = ""false"" //it makes this a public subnet
  availability_zone = var.AWS_REGION_AZ_DB
  tags = {
    Name = ""prod-subnet-private-1""
  }
}


### EC2 - Instances


### Criao de EC2 para DBservers
resource ""aws_instance"" ""DB01"" {
  ami           = ""ami-00068cd7555f543d5""
  instance_type = ""t2.micro""
  ### VPC
  subnet_id = aws_subnet.prod-subnet-private-1.id
  availability_zone = var.AWS_REGION_AZ_DB
  ### Atribuir Security Group
  vpc_security_group_ids = [aws_security_group.dbservers.id]
  ### Chave pblica utilizada
  key_name = aws_key_pair.minha-chave-ssh.id
  ### Script para deploy de banco de dados MariaDB/MySQL
  user_data = file(""userdatadb.sh"")
  connection {
    user = ""ec2-user""
    private_key = file(var.PRIVATE_KEY_PATH)
  }
  tags = {
    Name = ""DB01""
  }
}

### Criao de EC2 para Webservers
resource ""aws_instance"" ""WEB01"" {
  ami           = ""ami-00068cd7555f543d5""
  instance_type = ""t2.micro""
  ### VPC
  subnet_id = aws_subnet.prod-subnet-public-1.id
  availability_zone = var.AWS_REGION_AZ_WEB_1
  ### Atribuir Security Group
  vpc_security_group_ids = [aws_security_group.webservers.id]
  ### Chave pblica utilizada
  key_name = aws_key_pair.minha-chave-ssh.id
  ### Script para deploy de servidor web 
  user_data = file(""userdataweb.sh"")
  connection {
    user = ""ec2-user""
    private_key = file(var.PRIVATE_KEY_PATH)
  }
  tags = {
    Name = ""WEB01""
  }
}

### Criao de EC2 para Webservers
resource ""aws_instance"" ""WEB02"" {
  ami           = ""ami-00068cd7555f543d5""
  instance_type = ""t2.micro""
  ### VPC
  subnet_id = aws_subnet.prod-subnet-public-2.id
  availability_zone = var.AWS_REGION_AZ_WEB_2
  ### Atribuir Security Group
  vpc_security_group_ids = [aws_security_group.webservers.id]
  ### Chave pblica utilizada
  key_name = aws_key_pair.minha-chave-ssh.id
  ### Script para deploy de servidor web 
  user_data = file(""userdataweb.sh"")
  connection {
    user = ""ec2-user""
    private_key = file(var.PRIVATE_KEY_PATH)
  }
  tags = {
    Name = ""WEB02""
  }
}
resource ""aws_instance"" ""WEB03"" {
  ami           = ""ami-00068cd7555f543d5""
  instance_type = ""t2.micro""
  ### VPC
  subnet_id = aws_subnet.prod-subnet-public-3.id
  availability_zone = var.AWS_REGION_AZ_WEB_3
  ### Atribuir Security Group
  vpc_security_group_ids = [aws_security_group.webservers.id]
  ### Chave pblica utilizada
  key_name = aws_key_pair.minha-chave-ssh.id
  ### Script para deploy de servidor web 
  user_data = file(""userdataweb.sh"")
  connection {
    user = ""ec2-user""
    private_key = file(var.PRIVATE_KEY_PATH)
  }
  tags = {
    Name = ""WEB03""
  }
}

### Chave pblica que deve ser enviada para as EC2 no momento do deploy
### para criar, basta digitar no diretorio raiz :  ssh-keygen -f minha-chave-ssh 
resource ""aws_key_pair"" ""minha-chave-ssh"" {
  key_name = ""minha-chave-ssh""
  public_key = file(var.PUBLIC_KEY_PATH)
}


# Create a new load balancer
resource ""aws_elb"" ""prod-elb"" {
  name               = ""prod-elb""
  #availability_zones = [""us-east-1a"", ""us-east-1b"", ""us-east-1c""]

#  access_logs {
#    bucket        = ""glauciushabucketnewhorizon2020""
#    bucket_prefix = ""elb""
#    interval      = 60
#  }

  listener {
    instance_port     = 80
    instance_protocol = ""http""
    lb_port           = 80
    lb_protocol       = ""http""
  }

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 2
    timeout             = 3
    target              = ""HTTP:80/check.html""
    interval            = 30
  }

  instances                   = [aws_instance.WEB01.id,aws_instance.WEB02.id,aws_instance.WEB03.id]
  subnets                     = [aws_subnet.prod-subnet-public-1.id,aws_subnet.prod-subnet-public-2.id,aws_subnet.prod-subnet-public-3.id]
  cross_zone_load_balancing   = true
  idle_timeout                = 400
  connection_draining         = true
  connection_draining_timeout = 400

  tags = {
    Name = ""prod-elb""
  }
}



resource ""aws_s3_bucket"" ""b"" {
  bucket = ""glauciushabucketnewhorizon2020""
  acl    = ""private""

  tags = {
    Name        = ""glauciushabucketnewhorizon2020""
  }
}

resource ""aws_cloudwatch_dashboard"" ""main"" {
  dashboard_name = ""GlauciusHA2020""

  dashboard_body = <<EOF
 {
   ""widgets"": [
       {
          ""type"":""metric"",
          ""x"":0,
          ""y"":0,
          ""width"":12,
          ""height"":6,
          ""properties"":{
             ""metrics"":[
                [
                   ""AWS/EC2"",
                   ""CPUUtilization"",
                   ""InstanceId"",
                   ""aws_instance.WEB01.id""
                ]
             ],
             ""period"":300,
             ""stat"":""Average"",
             ""region"":""us-east-1"",
             ""title"":""EC2 Instance CPU""
          }
       },
       {
          ""type"":""text"",
          ""x"":0,
          ""y"":7,
          ""width"":3,
          ""height"":3,
          ""properties"":{
             ""markdown"":""Hello world""
          }
       }
   ]
 }
 EOF
}

","{
""userQuery1"": ""The user wants to set up a cloud infrastructure on AWS, specifically in the 'us-east-1' region. The infrastructure includes a Virtual Private Cloud (VPC) with a CIDR block of '10.0.0.0/16'. The VPC is divided into multiple subnets, each with its own CIDR block and availability zone. Some of these subnets are public, meaning they can be accessed from the internet, while others are private and can only be accessed from within the VPC."",
""userQuery2"": ""The user wants to create several EC2 instances (virtual servers) within this VPC. Some of these instances are web servers, located in the public subnets, and one is a database server, located in a private subnet. Each instance type has its own security group, which defines the rules for incoming and outgoing traffic. The instances are also associated with a specific SSH key pair for secure access."",
""userQuery3"": """
44,Ketouem,ketouem.com,terraform,"terraform {
  backend ""s3"" {
    bucket = ""ketouem-terraform-state""
    key    = ""ketouem.com/terraform.tfstate""
    region = ""eu-west-1""
  }
}


variable ""domain_name"" {
  default = ""ketouem.com""
}


terraform {
  required_version = ""~> 1.0.5""
}

provider ""aws"" {
  region = ""eu-west-1""
}

provider ""aws"" {
  region = ""us-east-1""
  alias  = ""us-east-1""
}


data ""aws_acm_certificate"" ""cert"" {
  provider    = aws.us-east-1
  domain      = var.domain_name
  statuses    = [""ISSUED""]
  types       = [""AMAZON_ISSUED""]
  most_recent = true
}

# S3
resource ""aws_s3_bucket"" ""ketouem_com"" {
  bucket        = var.domain_name
  acl           = ""private""
  force_destroy = false
}

resource ""aws_s3_bucket_public_access_block"" ""ketouem_com"" {
  bucket = aws_s3_bucket.ketouem_com.id

  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

resource ""aws_s3_bucket_policy"" ""access_from_cloudfront"" {
  bucket = aws_s3_bucket.ketouem_com.id

  policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Id"": ""AccessContentFromCloudFront"",
  ""Statement"": [
    {
      ""Sid"": ""1"",
      ""Effect"": ""Allow"",
      ""Principal"": {
        ""AWS"": ""${aws_cloudfront_origin_access_identity.origin_access_identity.iam_arn}""
      },
      ""Action"": ""s3:GetObject"",
      ""Resource"": ""${aws_s3_bucket.ketouem_com.arn}/*""
    },
    {
      ""Sid"": ""2"",
      ""Effect"": ""Allow"",
      ""Principal"": {
        ""AWS"": ""${aws_cloudfront_origin_access_identity.origin_access_identity.iam_arn}""
      },
      ""Action"": ""s3:ListBucket"",
      ""Resource"": ""${aws_s3_bucket.ketouem_com.arn}""
    }
  ]
}
EOF
}

# Cloudfront
resource ""aws_cloudfront_origin_access_identity"" ""origin_access_identity"" {
  comment = ""CloudFront access to ${aws_s3_bucket.ketouem_com.id}""
}

resource ""aws_cloudfront_distribution"" ""ketouem_com"" {
  enabled             = true
  aliases             = [var.domain_name, ""www.${var.domain_name}""]
  default_root_object = ""index.html""
  is_ipv6_enabled     = true
  price_class         = ""PriceClass_100""

  origin {
    domain_name = aws_s3_bucket.ketouem_com.bucket_regional_domain_name
    origin_id   = ""S3-${var.domain_name}""
    s3_origin_config {
      origin_access_identity = aws_cloudfront_origin_access_identity.origin_access_identity.cloudfront_access_identity_path
    }
  }

  default_cache_behavior {
    allowed_methods        = [""GET"", ""HEAD"", ""OPTIONS""]
    cached_methods         = [""GET"", ""HEAD""]
    compress               = true
    target_origin_id       = ""S3-${var.domain_name}""
    default_ttl            = 86400
    max_ttl                = 31536000
    min_ttl                = 0
    viewer_protocol_policy = ""redirect-to-https""

    forwarded_values {
      query_string = false

      cookies {
        forward = ""none""
      }
    }
  }

  restrictions {
    geo_restriction {
      restriction_type = ""none""
    }
  }

  viewer_certificate {
    # Warning: certificate must be in us-east-1
    acm_certificate_arn = data.aws_acm_certificate.cert.arn
    ssl_support_method  = ""sni-only""
  }
}

# Route53
resource ""aws_route53_zone"" ""primary"" {
  name = ""${var.domain_name}.""
}

resource ""aws_route53_record"" ""site_record"" {
  zone_id = aws_route53_zone.primary.zone_id
  name    = ""${var.domain_name}.""
  type    = ""A""

  alias {
    name                   = aws_cloudfront_distribution.ketouem_com.domain_name
    zone_id                = aws_cloudfront_distribution.ketouem_com.hosted_zone_id
    evaluate_target_health = false
  }
}

resource ""aws_route53_record"" ""site_record_www"" {
  zone_id = aws_route53_zone.primary.zone_id
  name    = ""www""
  type    = ""CNAME""
  ttl     = ""5""

  records = [var.domain_name]
}


","{
  ""userQuery1"": ""The user wants to create a private S3 bucket in AWS with the name 'ketouem.com'. The bucket should not be destroyed forcefully."",
  ""userQuery2"": ""The user wants to restrict public access to the S3 bucket. They want to block public ACLs, public policies, ignore public ACLs, and restrict public buckets."",
  ""userQuery3"": ""The user wants to allow access to the S3 bucket from CloudFront. They want to allow 'GetObject' and 'ListBucket' actions for the CloudFront origin access identity."",
  ""userQuery4"": ""The user wants to create a CloudFront distribution for the S3 bucket. The distribution should be enabled, support IPv6, and use the 'PriceClass_100' price class. The default root object should be 'index.html'."",
  ""userQuery5"": ""The user wants to set up a cache behavior for the CloudFront distribution. They want"
45,terraform-google-modules,terraform-example-shared-services,terraform_cft/00_projects,"/*
 * Copyright 2019 Google LLC. This software is provided as-is, without warranty
 * or representation for any use or purpose. Your use of it is subject to your 
 * agreement with Google.  
 */
provider ""google"" {
  version     = ""~> 2.16""
  credentials = ""${file(var.gcp_credentials_path)}""
}

terraform {
  backend ""gcs"" {
    bucket = ""MY_GCS_BUCKET""
    prefix = ""TF_STATE_PREFIX/projects""
  }
}


/*
 * Copyright 2019 Google LLC. This software is provided as-is, without warranty
 * or representation for any use or purpose. Your use of it is subject to your 
 * agreement with Google.  
 */
variable ""gcp_billing_id"" {
  description = ""The billing id to use with projects.""
}

variable ""gcp_org_id"" {
  description = ""The ID of the GCP organization where the projects will be created""
}

variable ""folder_id"" {
  description = ""The ID of the folder where the projects will be created""
}

variable ""shared_services_project"" {
  description = ""The ID of the shared services project""
  default     = ""shsvc-poc-ssv""
}

variable ""application_project"" {
  description = ""The ID of the sample application project""
  default     = ""shsvc-poc-app""
}

variable ""project_services"" {
  description = ""The GCP services required to in the projects.""
  type        = ""list""
  default = [
    ""compute.googleapis.com"",
    ""logging.googleapis.com"",
    ""dns.googleapis.com"",
    ""pubsub.googleapis.com"",
    ""iap.googleapis.com"",
    ""cloudfunctions.googleapis.com"",
  ]
}

variable ""gcp_credentials_path"" {
  description = ""Path to the json key of the service account used to run this configuration.""
}

variable ""random_suffix"" {
  description = ""Add a random suffix to some resources to make it simpler to run tests.""
  default     = true
}


/*
 * Copyright 2019 Google LLC. This software is provided as-is, without warranty
 * or representation for any use or purpose. Your use of it is subject to your 
 * agreement with Google.  
 */
module ""shared_services_project"" {
  source            = ""terraform-google-modules/project-factory/google""
  version           = ""6.1.0""
  project_id        = ""${var.shared_services_project}""
  name              = ""Shared services""
  folder_id         = ""${var.folder_id}""
  org_id            = ""${var.gcp_org_id}""
  billing_account   = ""${var.gcp_billing_id}""
  activate_apis     = ""${var.project_services}""
  random_project_id = ""${var.random_suffix}""
}

module ""application_project"" {
  source            = ""terraform-google-modules/project-factory/google""
  version           = ""6.1.0""
  project_id        = ""${var.application_project}""
  name              = ""CNZ application""
  folder_id         = ""${var.folder_id}""
  org_id            = ""${var.gcp_org_id}""
  billing_account   = ""${var.gcp_billing_id}""
  activate_apis     = ""${var.project_services}""
  random_project_id = ""${var.random_suffix}""
}


/*
 * Copyright 2019 Google LLC. This software is provided as-is, without warranty
 * or representation for any use or purpose. Your use of it is subject to your 
 * agreement with Google.  
 */
output ""shared_services_project"" {
  value = ""${module.shared_services_project.project_id}""
}

output ""application_project"" {
  value = ""${module.application_project.project_id}""
}

output ""folder_id"" {
  value = ""${var.folder_id}""
}


","{
  ""userQuery1"": ""The user needs to set up a Google Cloud Platform (GCP) provider with a specific version and credentials. The credentials are stored in a file whose path is provided by the user."",
  ""userQuery2"": ""The user intends to create two projects in GCP, a 'Shared Services' project and a 'CNZ application' project. These projects are created in a specific folder and organization, both of which are provided by the user. The billing for these projects is tied to a specific billing account, also provided by the user. The user also specifies a list of GCP services that need to be activated for these projects. The user has the option to add a random suffix to the project IDs for testing purposes."",
  ""userQuery3"": ""The user wants to store the state of the Terraform configuration in a Google Cloud Storage (GCS) bucket. The bucket name and the prefix for the state files are provided by the user.""
"
46,coreos,tectonic-installer,,"terraform {
  required_version = "">= 0.10.7""
}

provider ""archive"" {
  version = ""1.0.0""
}

provider ""external"" {
  version = ""1.0.0""
}

provider ""ignition"" {
  version = ""1.0.0""
}

provider ""local"" {
  version = ""1.0.0""
}

provider ""null"" {
  version = ""1.0.0""
}

provider ""random"" {
  version = ""1.0.0""
}

provider ""template"" {
  version = ""1.0.0""
}

provider ""tls"" {
  version = ""1.0.1""
}

locals {
  // The total amount of public CA certificates present in Tectonic.
  // That is all custom CAs + kube CA + etcd CA + ingress CA
  // This is a local constant, which needs to be dependency injected because TF cannot handle length() on computed values,
  // see https://github.com/hashicorp/terraform/issues/10857#issuecomment-268289775.
  tectonic_ca_count = ""${length(var.tectonic_custom_ca_pem_list) + 3}""

  tectonic_http_proxy_enabled = ""${length(var.tectonic_http_proxy_address) > 0}""
}

variable ""tectonic_config_version"" {
  description = <<EOF
(internal) This declares the version of the global configuration variables.
It has no impact on generated assets but declares the version contract of the configuration.
EOF

  default = ""1.0""
}

variable ""tectonic_image_re"" {
  description = <<EOF
(internal) Regular expression used to extract repo and tag components
EOF

  type    = ""string""
  default = ""/^([^/]+/[^/]+/[^/]+):(.*)$/""
}

variable ""tectonic_container_images"" {
  description = ""(internal) Container images to use""
  type        = ""map""

  default = {
    addon_resizer                = ""gcr.io/google_containers/addon-resizer:2.1""
    awscli                       = ""quay.io/coreos/awscli:025a357f05242fdad6a81e8a6b520098aa65a600""
    gcloudsdk                    = ""google/cloud-sdk:178.0.0-alpine""
    bootkube                     = ""quay.io/coreos/bootkube:v0.8.1""
    calico                       = ""quay.io/calico/node:v2.6.1""
    calico_cni                   = ""quay.io/calico/cni:v1.11.0""
    console                      = ""quay.io/coreos/tectonic-console:v6.0.5""
    error_server                 = ""quay.io/coreos/tectonic-error-server:1.1""
    etcd                         = ""quay.io/coreos/etcd:v3.1.8""
    etcd_operator                = ""quay.io/coreos/etcd-operator:v0.5.0""
    flannel                      = ""quay.io/coreos/flannel:v0.8.0-amd64""
    flannel_cni                  = ""quay.io/coreos/flannel-cni:v0.2.0""
    heapster                     = ""gcr.io/google_containers/heapster:v1.4.1""
    hyperkube                    = ""quay.io/coreos/hyperkube:v1.9.6_coreos.0""
    identity                     = ""quay.io/coreos/dex:v2.8.1""
    ingress_controller           = ""quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.9.0-beta.17""
    kenc                         = ""quay.io/coreos/kenc:0.0.2""
    kubedns                      = ""gcr.io/google_containers/k8s-dns-kube-dns-amd64:1.14.8""
    kubednsmasq                  = ""gcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64:1.14.8""
    kubedns_sidecar              = ""gcr.io/google_containers/k8s-dns-sidecar-amd64:1.14.8""
    kube_version                 = ""quay.io/coreos/kube-version:0.1.0""
    kube_version_operator        = ""quay.io/coreos/kube-version-operator:v1.9.6-kvo.4""
    node_agent                   = ""quay.io/coreos/node-agent:cd69b4a0f65b0d3a3b30edfce3bb184fd2a22c26""
    pod_checkpointer             = ""quay.io/coreos/pod-checkpointer:e22cc0e3714378de92f45326474874eb602ca0ac""
    stats_emitter                = ""quay.io/coreos/tectonic-stats:6e882361357fe4b773adbf279cddf48cb50164c1""
    stats_extender               = ""quay.io/coreos/tectonic-stats-extender:487b3da4e175da96dabfb44fba65cdb8b823db2e""
    tectonic_channel_operator    = ""quay.io/coreos/tectonic-channel-operator:0.6.4""
    tectonic_etcd_operator       = ""quay.io/coreos/tectonic-etcd-operator:v0.0.2""
    tectonic_prometheus_operator = ""quay.io/coreos/tectonic-prometheus-operator:v1.9.5""
    tectonic_cluo_operator       = ""quay.io/coreos/tectonic-cluo-operator:v0.3.2""
    tectonic_torcx               = ""quay.io/coreos/tectonic-torcx:v0.2.0""
    tectonic_alm_operator        = ""quay.io/coreos/tectonic-alm-operator:v0.4.0""
  }
}

variable ""tectonic_container_base_images"" {
  description = ""(internal) Base images of the components to use""
  type        = ""map""

  default = {
    tectonic_monitoring_auth = ""quay.io/coreos/tectonic-monitoring-auth""
    config_reload            = ""quay.io/coreos/configmap-reload""
    addon_resizer            = ""quay.io/coreos/addon-resizer""
    kube_state_metrics       = ""quay.io/coreos/kube-state-metrics""
    grafana                  = ""quay.io/coreos/monitoring-grafana""
    grafana_watcher          = ""quay.io/coreos/grafana-watcher""
    prometheus_operator      = ""quay.io/coreos/prometheus-operator""
    prometheus_config_reload = ""quay.io/coreos/prometheus-config-reloader""
    prometheus               = ""quay.io/prometheus/prometheus""
    alertmanager             = ""quay.io/prometheus/alertmanager""
    node_exporter            = ""quay.io/prometheus/node-exporter""
    kube_rbac_proxy          = ""quay.io/coreos/kube-rbac-proxy""
  }
}

variable ""tectonic_versions"" {
  description = ""(internal) Versions of the components to use""
  type        = ""map""

  default = {
    etcd          = ""3.1.8""
    kubernetes    = ""1.9.6+tectonic.1""
    monitoring    = ""1.9.5""
    tectonic      = ""1.9.6-tectonic.1""
    tectonic-etcd = ""0.0.1""
    cluo          = ""0.3.2""
    alm           = ""0.4.0""
  }
}

variable ""tectonic_service_cidr"" {
  type    = ""string""
  default = ""10.3.0.0/16""

  description = <<EOF
(optional) This declares the IP range to assign Kubernetes service cluster IPs in CIDR notation.
The maximum size of this IP range is /12
EOF
}

variable ""tectonic_cluster_cidr"" {
  type    = ""string""
  default = ""10.2.0.0/16""

  description = ""(optional) This declares the IP range to assign Kubernetes pod IPs in CIDR notation.""
}

variable ""tectonic_master_count"" {
  type    = ""string""
  default = ""1""

  description = <<EOF
The number of master nodes to be created.
This applies only to cloud platforms.
EOF
}

variable ""tectonic_worker_count"" {
  type    = ""string""
  default = ""3""

  description = <<EOF
The number of worker nodes to be created.
This applies only to cloud platforms.
EOF
}

variable ""tectonic_etcd_count"" {
  type    = ""string""
  default = ""0""

  description = <<EOF
The number of etcd nodes to be created.
If set to zero, the count of etcd nodes will be determined automatically.

Note: This is not supported on bare metal.
EOF
}

variable ""tectonic_etcd_servers"" {
  description = <<EOF
(optional) List of external etcd v3 servers to connect with (hostnames/IPs only).
Needs to be set if using an external etcd cluster.
Note: If this variable is defined, the installer will not create self-signed certs.
To provide a CA certificate to trust the etcd servers, set ""tectonic_etcd_ca_cert_path"".

Example: `[""etcd1"", ""etcd2"", ""etcd3""]`
EOF

  type    = ""list""
  default = []
}

variable ""tectonic_etcd_tls_enabled"" {
  default = true

  description = <<EOF
(optional) If set to `true`, all etcd endpoints will be configured to use the ""https"" scheme.

Note: If `tectonic_experimental` is set to `true` this variable has no effect, because the experimental self-hosted etcd always uses TLS.
EOF
}

variable ""tectonic_etcd_ca_cert_path"" {
  type    = ""string""
  default = ""/dev/null""

  description = <<EOF
(optional) The path of the file containing the CA certificate for TLS communication with etcd.

Note: This works only when used in conjunction with an external etcd cluster.
If set, the variable `tectonic_etcd_servers` must also be set.
EOF
}

variable ""tectonic_etcd_client_cert_path"" {
  type    = ""string""
  default = ""/dev/null""

  description = <<EOF
(optional) The path of the file containing the client certificate for TLS communication with etcd.

Note: This works only when used in conjunction with an external etcd cluster.
If set, the variables `tectonic_etcd_servers`, `tectonic_etcd_ca_cert_path`, and `tectonic_etcd_client_key_path` must also be set.
EOF
}

variable ""tectonic_etcd_client_key_path"" {
  type    = ""string""
  default = ""/dev/null""

  description = <<EOF
(optional) The path of the file containing the client key for TLS communication with etcd.

Note: This works only when used in conjunction with an external etcd cluster.
If set, the variables `tectonic_etcd_servers`, `tectonic_etcd_ca_cert_path`, and `tectonic_etcd_client_cert_path` must also be set.
EOF
}

variable ""tectonic_base_domain"" {
  type = ""string""

  description = <<EOF
The base DNS domain of the cluster. It must NOT contain a trailing period. Some
DNS providers will automatically add this if necessary.

Example: `openstack.dev.coreos.systems`.

Note: This field MUST be set manually prior to creating the cluster.
This applies only to cloud platforms.

[Azure-specific NOTE]
To use Azure-provided DNS, `tectonic_base_domain` should be set to `""""`
If using DNS records, ensure that `tectonic_base_domain` is set to a properly configured external DNS zone.
Instructions for configuring delegated domains for Azure DNS can be found here: https://docs.microsoft.com/en-us/azure/dns/dns-delegate-domain-azure-dns
EOF
}

variable ""tectonic_cluster_name"" {
  type = ""string""

  description = <<EOF
The name of the cluster.
If used in a cloud-environment, this will be prepended to `tectonic_base_domain` resulting in the URL to the Tectonic console.

Note: This field MUST be set manually prior to creating the cluster.
Warning: Special characters in the name like '.' may cause errors on OpenStack platforms due to resource name constraints.
EOF
}

variable ""tectonic_pull_secret_path"" {
  type    = ""string""
  default = """"

  description = <<EOF
The path the pull secret file in JSON format.
This is known to be a ""Docker pull secret"" as produced by the docker login [1] command.
A sample JSON content is shown in [2].
You can download the pull secret from your Account overview page at [3].

[1] https://docs.docker.com/engine/reference/commandline/login/

[2] https://coreos.com/os/docs/latest/registry-authentication.html#manual-registry-auth-setup

[3] https://account.coreos.com/overview

Note: This field MUST be set manually prior to creating the cluster unless `tectonic_vanilla_k8s` is set to `true`.
EOF
}

variable ""tectonic_license_path"" {
  type    = ""string""
  default = """"

  description = <<EOF
The path to the tectonic licence file.
You can download the Tectonic license file from your Account overview page at [1].

[1] https://account.coreos.com/overview

Note: This field MUST be set manually prior to creating the cluster unless `tectonic_vanilla_k8s` is set to `true`.
EOF
}

variable ""tectonic_container_linux_channel"" {
  type    = ""string""
  default = ""stable""

  description = <<EOF
(optional) The Container Linux update channel.

Examples: `stable`, `beta`, `alpha`
EOF
}

variable ""tectonic_container_linux_version"" {
  type    = ""string""
  default = ""latest""

  description = <<EOF
The Container Linux version to use. Set to `latest` to select the latest available version for the selected update channel.

Examples: `latest`, `1465.6.0`
EOF
}

variable ""tectonic_update_server"" {
  type        = ""string""
  default     = ""https://tectonic.update.core-os.net""
  description = ""(internal) The URL of the Tectonic Omaha update server""
}

variable ""tectonic_update_channel"" {
  type        = ""string""
  default     = ""tectonic-1.8-production""
  description = ""(internal) The Tectonic Omaha update channel""
}

variable ""tectonic_update_app_id"" {
  type        = ""string""
  default     = ""6bc7b986-4654-4a0f-94b3-84ce6feb1db4""
  description = ""(internal) The Tectonic Omaha update App ID""
}

variable ""tectonic_admin_email"" {
  type = ""string""

  description = <<EOF
(internal) The e-mail address used to:
1. login as the admin user to the Tectonic Console.
2. generate DNS zones for some providers.

Note: This field MUST be in all lower-case e-mail address format and set manually prior to creating the cluster.
EOF
}

variable ""tectonic_admin_password"" {
  type = ""string""

  description = <<EOF
(internal) The admin user password to login to the Tectonic Console.

Note: This field MUST be set manually prior to creating the cluster. Backslashes and double quotes must
also be escaped.
EOF
}

variable ""tectonic_ca_cert"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) The content of the PEM-encoded CA certificate, used to generate Tectonic Console's server certificate.
If left blank, a CA certificate will be automatically generated.
EOF
}

variable ""tectonic_ca_key"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) The content of the PEM-encoded CA key, used to generate Tectonic Console's server certificate.
This field is mandatory if `tectonic_ca_cert` is set.
EOF
}

variable ""tectonic_ca_key_alg"" {
  type    = ""string""
  default = ""RSA""

  description = <<EOF
(optional) The algorithm used to generate tectonic_ca_key.
The default value is currently recommended.
This field is mandatory if `tectonic_ca_cert` is set.
EOF
}

variable ""tectonic_tls_validity_period"" {
  type    = ""string""
  default = ""26280""

  description = <<EOF
Validity period of the self-signed certificates (in hours).
Default is 3 years.
This setting is ignored if user provided certificates are used.
EOF
}

variable ""tectonic_vanilla_k8s"" {
  default = false

  description = <<EOF
If set to true, a vanilla Kubernetes cluster will be deployed, omitting any Tectonic assets.
EOF
}

variable ""tectonic_stats_url"" {
  type        = ""string""
  default     = ""https://stats-collector.tectonic.com""
  description = ""(internal) The Tectonic statistics collection URL to which to report.""
}

variable ""tectonic_ddns_server"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) This only applies if you use the modules/dns/ddns module.

Specifies the RFC2136 Dynamic DNS server IP/host to register IP addresses to.
EOF
}

variable ""tectonic_ddns_key_name"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) This only applies if you use the modules/dns/ddns module.

Specifies the RFC2136 Dynamic DNS server key name.
EOF
}

variable ""tectonic_ddns_key_algorithm"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) This only applies if you use the modules/dns/ddns module.

Specifies the RFC2136 Dynamic DNS server key algorithm.
EOF
}

variable ""tectonic_ddns_key_secret"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) This only applies if you use the modules/dns/ddns module.

Specifies the RFC2136 Dynamic DNS server key secret.
EOF
}

variable ""tectonic_networking"" {
  default = ""flannel""

  description = <<EOF
(optional) Configures the network to be used in Tectonic. One of the following values can be used:

- ""flannel"": enables overlay networking only. This is implemented by flannel using VXLAN.

- ""canal"": [ALPHA] enables overlay networking including network policy. Overlay is implemented by flannel using VXLAN. Network policy is implemented by Calico.

- ""calico"": [ALPHA] enables BGP based networking. Routing and network policy is implemented by Calico. Note this has been tested on baremetal installations only.
EOF
}

variable ""tectonic_self_hosted_etcd"" {
  default = """"

  description = <<EOF
(internal) [ALPHA] If set to one of the following values, self-hosted etcd is deployed:

- ""enabled"": Deploys a self-hosted etcd cluster.

- ""pv_backup"": Deploys a self-hosted etcd cluster including backups to Persistence Volumes.
`tectonic_etcd_backup_size` and `tectonic_etcd_backup_storage_class` must be configured when using this setting.
EOF
}

variable ""tectonic_etcd_backup_size"" {
  type        = ""string""
  description = ""(optional) The size in MB of the PersistentVolume used for handling etcd backups.""
  default     = ""512""
}

variable ""tectonic_etcd_backup_storage_class"" {
  type        = ""string""
  default     = """"
  description = ""(optional) The name of an existing Kubernetes StorageClass that will be used for handling etcd backups.""
}

variable ""tectonic_bootstrap_upgrade_cl"" {
  type        = ""string""
  default     = ""true""
  description = ""(internal) Whether to trigger a ContainerLinux upgrade on node bootstrap.""
}

variable ""tectonic_kubelet_debug_config"" {
  type    = ""string""
  default = """"

  description = ""(internal) debug flags for the kubelet (used in CI only)""
}

variable ""tectonic_custom_ca_pem_list"" {
  type    = ""list""
  default = []

  description = <<EOF
(optional) A list of PEM encoded CA files that will be installed in /etc/ssl/certs on etcd, master, and worker nodes.
EOF
}

variable ""tectonic_iscsi_enabled"" {
  type        = ""string""
  default     = ""false""
  description = ""(optional) Start iscsid.service to enable iscsi volume attachment.""
}

variable ""tectonic_http_proxy_address"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) HTTP proxy address.

Example: `http://myproxy.example.com`
EOF
}

variable ""tectonic_https_proxy_address"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) HTTPS proxy address.

Example: `http://myproxy.example.com`
EOF
}

variable ""tectonic_no_proxy"" {
  type    = ""list""
  default = []

  description = <<EOF
(optional) List of local endpoints that will not use HTTP proxy.

Example: `[""127.0.0.1"",""localhost"","".example.com"",""10.3.0.1""]`
EOF
}

variable ""tectonic_ntp_servers"" {
  type    = ""list""
  default = []

  description = <<EOF
(optional) If left blank, the default Container Linux NTP servers will be used.
A list of NTP servers to be used for time synchronization on the cluster nodes.
EOF
}

variable ""tectonic_nfs_config_file"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) the path to an NFS configuration file to be placed in /etc/conf.d/nfs
file on the CL nodes.
EOF
}

# Workaround for https://github.com/hashicorp/hil/issues/50
locals {
  _tectonic_nfs_config_file = ""${var.tectonic_nfs_config_file != """" ? var.tectonic_nfs_config_file : ""/dev/null""}""
}

variable ""tectonic_proxy_exclusive_units"" {
  default = false

  description = <<EOF
(optional) When set to true, it restricts the application of proxy settings to processes started through systemd units.
Global proxy settings will not be affected in this case.
When set to false, the proxy settings will apply globally, including to all processes lauched by users.
EOF
}


","{
  ""userQuery1"": ""The user wants to set up a Kubernetes cluster using Tectonic, a CoreOS Kubernetes platform. The user wants to specify the version of Terraform to be used, the versions of various providers such as 'archive', 'external', 'ignition', 'local', 'null', 'random', 'template', and 'tls', and the versions of various container images and base images."",
  ""userQuery2"": ""The user wants to configure the networking for the Kubernetes cluster, with options for 'flannel', 'canal', or 'calico'. The user also wants to specify the number of master, worker, and etcd nodes to be created, as well as the IP ranges to assign to Kubernetes service cluster IPs and pod IPs."",
  ""userQuery3"": ""The user wants to specify the base DNS domain of the cluster, the name of the cluster, and the paths to the pull secret file and the Tectonic license file"
47,AduroIdeja,tectonic-installer,platforms/azure,"locals {
  ""bootstrapping_host"" = ""${var.tectonic_azure_private_cluster ?
    module.vnet.master_private_ip_addresses[0] :
    module.vnet.api_fqdn}""
}

module ""bootstrapper"" {
  source = ""../../modules/bootstrap-ssh""

  _dependencies = [
    ""${module.masters.master_vm_ids}"",
    ""${module.etcd.etcd_vm_ids}"",
    ""${module.etcd_certs.id}"",
    ""${module.bootkube.id}"",
    ""${module.tectonic.id}"",
    ""${module.flannel-vxlan.id}"",
    ""${module.calico-network-policy.id}"",
  ]

  bootstrapping_host = ""${local.bootstrapping_host}""
}


../../config.tf

provider ""azurerm"" {
  version       = ""0.1.7""
  environment   = ""${var.tectonic_azure_cloud_environment}""
  client_secret = ""${var.tectonic_azure_client_secret}""
}

data ""azurerm_client_config"" ""current"" {}

module ""resource_group"" {
  source = ""../../modules/azure/resource-group""

  external_rsg_id = ""${var.tectonic_azure_external_resource_group}""
  azure_location  = ""${var.tectonic_azure_location}""
  cluster_name    = ""${var.tectonic_cluster_name}""
  cluster_id      = ""${module.tectonic.cluster_id}""
  extra_tags      = ""${var.tectonic_azure_extra_tags}""
}

module ""vnet"" {
  source = ""../../modules/azure/vnet""

  location            = ""${var.tectonic_azure_location}""
  resource_group_name = ""${module.resource_group.name}""
  cluster_name        = ""${var.tectonic_cluster_name}""
  cluster_id          = ""${module.tectonic.cluster_id}""
  base_domain         = ""${var.tectonic_base_domain}""
  vnet_cidr_block     = ""${var.tectonic_azure_vnet_cidr_block}""

  etcd_count           = ""${local.etcd_count}""
  master_count         = ""${var.tectonic_master_count}""
  worker_count         = ""${var.tectonic_worker_count}""
  etcd_cidr            = ""${module.vnet.etcd_cidr}""
  master_cidr          = ""${module.vnet.master_cidr}""
  worker_cidr          = ""${module.vnet.worker_cidr}""
  ssh_network_internal = ""${var.tectonic_azure_ssh_network_internal}""
  ssh_network_external = ""${var.tectonic_azure_ssh_network_external}""

  external_vnet_id          = ""${var.tectonic_azure_external_vnet_id}""
  external_master_subnet_id = ""${var.tectonic_azure_external_master_subnet_id}""
  external_worker_subnet_id = ""${var.tectonic_azure_external_worker_subnet_id}""
  external_nsg_master_id    = ""${var.tectonic_azure_external_nsg_master_id}""
  external_nsg_worker_id    = ""${var.tectonic_azure_external_nsg_worker_id}""

  extra_tags = ""${var.tectonic_azure_extra_tags}""

  private_cluster = ""${var.tectonic_azure_private_cluster}""
}

module ""etcd"" {
  source = ""../../modules/azure/etcd""

  base_domain           = ""${var.tectonic_base_domain}""
  cl_channel            = ""${var.tectonic_cl_channel}""
  cluster_id            = ""${module.tectonic.cluster_id}""
  cluster_name          = ""${var.tectonic_cluster_name}""
  container_image       = ""${var.tectonic_container_images[""etcd""]}""
  etcd_count            = ""${local.etcd_count}""
  extra_tags            = ""${var.tectonic_azure_extra_tags}""
  location              = ""${var.tectonic_azure_location}""
  network_interface_ids = ""${module.vnet.etcd_network_interface_ids}""
  public_ssh_key        = ""${var.tectonic_azure_ssh_key}""
  resource_group_name   = ""${module.resource_group.name}""
  storage_id            = ""${module.resource_group.storage_id}""
  storage_type          = ""${var.tectonic_azure_etcd_storage_type}""
  tls_ca_crt_pem        = ""${module.etcd_certs.etcd_ca_crt_pem}""
  tls_client_crt_pem    = ""${module.etcd_certs.etcd_client_crt_pem}""
  tls_client_key_pem    = ""${module.etcd_certs.etcd_client_key_pem}""
  tls_enabled           = ""${var.tectonic_etcd_tls_enabled}""
  tls_peer_crt_pem      = ""${module.etcd_certs.etcd_peer_crt_pem}""
  tls_peer_key_pem      = ""${module.etcd_certs.etcd_peer_key_pem}""
  tls_server_crt_pem    = ""${module.etcd_certs.etcd_server_crt_pem}""
  tls_server_key_pem    = ""${module.etcd_certs.etcd_server_key_pem}""
  versions              = ""${var.tectonic_versions}""
  vm_size               = ""${var.tectonic_azure_etcd_vm_size}""

  ign_etcd_dropin_id_list = ""${module.ignition_masters.etcd_dropin_id_list}""
}

# Workaround for https://github.com/hashicorp/terraform/issues/4084
data ""null_data_source"" ""cloud_provider"" {
  inputs = {
    ""cloud""                      = ""${var.tectonic_azure_cloud_environment}""
    ""tenantId""                   = ""${data.azurerm_client_config.current.tenant_id}""
    ""subscriptionId""             = ""${data.azurerm_client_config.current.subscription_id}""
    ""aadClientId""                = ""${data.azurerm_client_config.current.client_id}""
    ""aadClientSecret""            = ""${var.tectonic_azure_client_secret}""
    ""resourceGroup""              = ""${module.resource_group.name}""
    ""location""                   = ""${var.tectonic_azure_location}""
    ""subnetName""                 = ""${module.vnet.worker_subnet_name}""
    ""securityGroupName""          = ""${module.vnet.worker_nsg_name}""
    ""vnetName""                   = ""${module.vnet.vnet_id}""
    ""primaryAvailabilitySetName"" = ""${module.workers.availability_set_name}""
  }
}

data ""template_file"" ""etcd_advertise_name_list"" {
  count    = ""${local.etcd_count}""
  template = ""$$$$$$$${COREOS_AZURE_IPV4_DYNAMIC}""
}

module ""ignition_masters"" {
  source = ""../../modules/ignition""

  base_domain               = ""${var.tectonic_base_domain}""
  bootstrap_upgrade_cl      = ""${var.tectonic_bootstrap_upgrade_cl}""
  cloud_provider            = ""azure""
  cloud_provider_config     = ""${jsonencode(data.null_data_source.cloud_provider.inputs)}""
  cluster_name              = ""${var.tectonic_cluster_name}""
  container_images          = ""${var.tectonic_container_images}""
  etcd_advertise_name_list  = ""${data.template_file.etcd_advertise_name_list.*.rendered}""
  etcd_count                = ""${local.etcd_count}""
  etcd_initial_cluster_list = ""${data.template_file.etcd_hostname_list.*.rendered}""
  etcd_tls_enabled          = ""${var.tectonic_etcd_tls_enabled}""
  image_re                  = ""${var.tectonic_image_re}""
  kube_dns_service_ip       = ""${module.bootkube.kube_dns_service_ip}""
  kubelet_cni_bin_dir       = ""${var.tectonic_calico_network_policy ? ""/var/lib/cni/bin"" : """" }""
  kubelet_node_label        = ""node-role.kubernetes.io/master""
  kubelet_node_taints       = ""node-role.kubernetes.io/master=:NoSchedule""
  tectonic_vanilla_k8s      = ""${var.tectonic_vanilla_k8s}""
}

module ""masters"" {
  source = ""../../modules/azure/master-as""

  cl_channel            = ""${var.tectonic_cl_channel}""
  cloud_provider_config = ""${jsonencode(data.null_data_source.cloud_provider.inputs)}""
  cluster_id            = ""${module.tectonic.cluster_id}""
  cluster_name          = ""${var.tectonic_cluster_name}""
  extra_tags            = ""${var.tectonic_azure_extra_tags}""
  kubeconfig_content    = ""${module.bootkube.kubeconfig}""
  location              = ""${var.tectonic_azure_location}""
  master_count          = ""${var.tectonic_master_count}""
  network_interface_ids = ""${module.vnet.master_network_interface_ids}""
  public_ssh_key        = ""${var.tectonic_azure_ssh_key}""
  resource_group_name   = ""${module.resource_group.name}""
  storage_id            = ""${module.resource_group.storage_id}""
  storage_type          = ""${var.tectonic_azure_master_storage_type}""
  vm_size               = ""${var.tectonic_azure_master_vm_size}""

  ign_azure_udev_rules_id           = ""${module.ignition_masters.azure_udev_rules_id}""
  ign_bootkube_path_unit_id         = ""${module.bootkube.systemd_path_unit_id}""
  ign_bootkube_service_id           = ""${module.bootkube.systemd_service_id}""
  ign_docker_dropin_id              = ""${module.ignition_masters.docker_dropin_id}""
  ign_installer_kubelet_env_id      = ""${module.ignition_workers.installer_kubelet_env_id}""
  ign_k8s_node_bootstrap_service_id = ""${module.ignition_masters.k8s_node_bootstrap_service_id}""
  ign_kubelet_service_id            = ""${module.ignition_masters.kubelet_service_id}""
  ign_locksmithd_service_id         = ""${module.ignition_masters.locksmithd_service_id}""
  ign_max_user_watches_id           = ""${module.ignition_masters.max_user_watches_id}""
  ign_tectonic_path_unit_id         = ""${var.tectonic_vanilla_k8s ? """" : module.tectonic.systemd_path_unit_id}""
  ign_tectonic_service_id           = ""${module.tectonic.systemd_service_id}""
  ign_tx_off_service_id             = ""${module.ignition_masters.tx_off_service_id}""
}

module ""ignition_workers"" {
  source = ""../../modules/ignition""

  bootstrap_upgrade_cl  = ""${var.tectonic_bootstrap_upgrade_cl}""
  cloud_provider        = ""azure""
  cloud_provider_config = ""${jsonencode(data.null_data_source.cloud_provider.inputs)}""
  container_images      = ""${var.tectonic_container_images}""
  image_re              = ""${var.tectonic_image_re}""
  kube_dns_service_ip   = ""${module.bootkube.kube_dns_service_ip}""
  kubelet_cni_bin_dir   = ""${var.tectonic_calico_network_policy ? ""/var/lib/cni/bin"" : """" }""
  kubelet_node_label    = ""node-role.kubernetes.io/node""
  kubelet_node_taints   = """"
  tectonic_vanilla_k8s  = ""${var.tectonic_vanilla_k8s}""
}

module ""workers"" {
  source = ""../../modules/azure/worker-as""

  cl_channel                   = ""${var.tectonic_cl_channel}""
  cloud_provider_config        = ""${jsonencode(data.null_data_source.cloud_provider.inputs)}""
  cluster_id                   = ""${module.tectonic.cluster_id}""
  cluster_name                 = ""${var.tectonic_cluster_name}""
  extra_tags                   = ""${var.tectonic_azure_extra_tags}""
  kubeconfig_content           = ""${module.bootkube.kubeconfig}""
  location                     = ""${var.tectonic_azure_location}""
  network_interface_ids        = ""${module.vnet.worker_network_interface_ids}""
  public_ssh_key               = ""${var.tectonic_azure_ssh_key}""
  resource_group_name          = ""${module.resource_group.name}""
  storage_id                   = ""${module.resource_group.storage_id}""
  storage_type                 = ""${var.tectonic_azure_worker_storage_type}""
  tectonic_kube_dns_service_ip = ""${module.bootkube.kube_dns_service_ip}""
  vm_size                      = ""${var.tectonic_azure_worker_vm_size}""
  worker_count                 = ""${var.tectonic_worker_count}""

  ign_azure_udev_rules_id           = ""${module.ignition_workers.azure_udev_rules_id}""
  ign_docker_dropin_id              = ""${module.ignition_workers.docker_dropin_id}""
  ign_installer_kubelet_env_id      = ""${module.ignition_workers.installer_kubelet_env_id}""
  ign_k8s_node_bootstrap_service_id = ""${module.ignition_workers.k8s_node_bootstrap_service_id}""
  ign_kubelet_service_id            = ""${module.ignition_workers.kubelet_service_id}""
  ign_locksmithd_service_id         = ""${module.ignition_masters.locksmithd_service_id}""
  ign_max_user_watches_id           = ""${module.ignition_workers.max_user_watches_id}""
  ign_tx_off_service_id             = ""${module.ignition_workers.tx_off_service_id}""
}

module ""dns"" {
  source = ""../../modules/dns/azure""

  etcd_count   = ""${local.etcd_count}""
  master_count = ""${var.tectonic_master_count}""
  worker_count = ""${var.tectonic_worker_count}""

  etcd_ip_addresses    = ""${module.vnet.etcd_endpoints}""
  master_ip_addresses  = ""${module.vnet.master_private_ip_addresses}""
  worker_ip_addresses  = ""${module.vnet.worker_private_ip_addresses}""
  api_ip_addresses     = ""${module.vnet.api_ip_addresses}""
  console_ip_addresses = ""${module.vnet.console_ip_addresses}""

  base_domain  = ""${var.tectonic_base_domain}""
  cluster_name = ""${var.tectonic_cluster_name}""
  cluster_id   = ""${module.tectonic.cluster_id}""

  location             = ""${var.tectonic_azure_location}""
  external_dns_zone_id = ""${var.tectonic_azure_external_dns_zone_id}""

  extra_tags = ""${var.tectonic_azure_extra_tags}""
}


locals {
  etcd_count = ""${var.tectonic_experimental ? 0 : max(var.tectonic_etcd_count, 1)}""
}

data ""template_file"" ""etcd_hostname_list"" {
  count    = ""${local.etcd_count}""
  template = ""${var.tectonic_cluster_name}-etcd-${count.index}${var.tectonic_base_domain == """" ? """" : "".${var.tectonic_base_domain}""}""
}

module ""kube_certs"" {
  source = ""../../modules/tls/kube/self-signed""

  ca_cert_pem        = ""${var.tectonic_ca_cert}""
  ca_key_alg         = ""${var.tectonic_ca_key_alg}""
  ca_key_pem         = ""${var.tectonic_ca_key}""
  kube_apiserver_url = ""https://${module.vnet.api_fqdn}:443""
  service_cidr       = ""${var.tectonic_service_cidr}""
}

module ""etcd_certs"" {
  source = ""../../modules/tls/etcd""

  etcd_ca_cert_path     = ""${var.tectonic_etcd_ca_cert_path}""
  etcd_cert_dns_names   = ""${data.template_file.etcd_hostname_list.*.rendered}""
  etcd_client_cert_path = ""${var.tectonic_etcd_client_cert_path}""
  etcd_client_key_path  = ""${var.tectonic_etcd_client_key_path}""
  self_signed           = ""${var.tectonic_experimental || var.tectonic_etcd_tls_enabled}""
  service_cidr          = ""${var.tectonic_service_cidr}""
}

module ""ingress_certs"" {
  source = ""../../modules/tls/ingress/self-signed""

  base_address = ""${module.vnet.ingress_fqdn}""
  ca_cert_pem  = ""${module.kube_certs.ca_cert_pem}""
  ca_key_alg   = ""${module.kube_certs.ca_key_alg}""
  ca_key_pem   = ""${module.kube_certs.ca_key_pem}""
}

module ""identity_certs"" {
  source = ""../../modules/tls/identity/self-signed""

  ca_cert_pem = ""${module.kube_certs.ca_cert_pem}""
  ca_key_alg  = ""${module.kube_certs.ca_key_alg}""
  ca_key_pem  = ""${module.kube_certs.ca_key_pem}""
}

module ""bootkube"" {
  source = ""../../modules/bootkube""

  cloud_provider        = ""azure""
  cloud_provider_config = ""${jsonencode(data.null_data_source.cloud_provider.inputs)}""

  cluster_name = ""${var.tectonic_cluster_name}""

  kube_apiserver_url = ""https://${module.vnet.api_fqdn}:443""
  oidc_issuer_url    = ""https://${module.vnet.ingress_fqdn}/identity""

  # Platform-independent variables wiring, do not modify.
  container_images = ""${var.tectonic_container_images}""
  versions         = ""${var.tectonic_versions}""

  service_cidr = ""${var.tectonic_service_cidr}""
  cluster_cidr = ""${var.tectonic_cluster_cidr}""

  advertise_address = ""0.0.0.0""
  anonymous_auth    = ""false""

  oidc_username_claim = ""email""
  oidc_groups_claim   = ""groups""
  oidc_client_id      = ""tectonic-kubectl""
  oidc_ca_cert        = ""${module.ingress_certs.ca_cert_pem}""

  apiserver_cert_pem   = ""${module.kube_certs.apiserver_cert_pem}""
  apiserver_key_pem    = ""${module.kube_certs.apiserver_key_pem}""
  etcd_ca_cert_pem     = ""${module.etcd_certs.etcd_ca_crt_pem}""
  etcd_client_cert_pem = ""${module.etcd_certs.etcd_client_crt_pem}""
  etcd_client_key_pem  = ""${module.etcd_certs.etcd_client_key_pem}""
  etcd_peer_cert_pem   = ""${module.etcd_certs.etcd_peer_crt_pem}""
  etcd_peer_key_pem    = ""${module.etcd_certs.etcd_peer_key_pem}""
  etcd_server_cert_pem = ""${module.etcd_certs.etcd_server_crt_pem}""
  etcd_server_key_pem  = ""${module.etcd_certs.etcd_server_key_pem}""
  kube_ca_cert_pem     = ""${module.kube_certs.ca_cert_pem}""
  kubelet_cert_pem     = ""${module.kube_certs.kubelet_cert_pem}""
  kubelet_key_pem      = ""${module.kube_certs.kubelet_key_pem}""

  etcd_endpoints       = ""${data.template_file.etcd_hostname_list.*.rendered}""
  experimental_enabled = ""${var.tectonic_experimental}""

  master_count = ""${var.tectonic_master_count}""

  cloud_config_path = ""/etc/kubernetes/cloud""
}

module ""tectonic"" {
  source   = ""../../modules/tectonic""
  platform = ""azure""

  cluster_name = ""${var.tectonic_cluster_name}""

  base_address       = ""${module.vnet.ingress_fqdn}""
  kube_apiserver_url = ""https://${module.vnet.api_fqdn}:443""
  service_cidr       = ""${var.tectonic_service_cidr}""

  # Platform-independent variables wiring, do not modify.
  container_images      = ""${var.tectonic_container_images}""
  container_base_images = ""${var.tectonic_container_base_images}""
  versions              = ""${var.tectonic_versions}""

  license_path     = ""${var.tectonic_vanilla_k8s ? ""/dev/null"" : pathexpand(var.tectonic_license_path)}""
  pull_secret_path = ""${var.tectonic_vanilla_k8s ? ""/dev/null"" : pathexpand(var.tectonic_pull_secret_path)}""

  admin_email    = ""${var.tectonic_admin_email}""
  admin_password = ""${var.tectonic_admin_password}""

  update_channel = ""${var.tectonic_update_channel}""
  update_app_id  = ""${var.tectonic_update_app_id}""
  update_server  = ""${var.tectonic_update_server}""

  ca_generated = ""${var.tectonic_ca_cert == """" ? false : true}""
  ca_cert      = ""${module.kube_certs.ca_cert_pem}""

  ingress_ca_cert_pem = ""${module.ingress_certs.ca_cert_pem}""
  ingress_cert_pem    = ""${module.ingress_certs.cert_pem}""
  ingress_key_pem     = ""${module.ingress_certs.key_pem}""

  identity_client_cert_pem = ""${module.identity_certs.client_cert_pem}""
  identity_client_key_pem  = ""${module.identity_certs.client_key_pem}""
  identity_server_cert_pem = ""${module.identity_certs.server_cert_pem}""
  identity_server_key_pem  = ""${module.identity_certs.server_key_pem}""

  console_client_id = ""tectonic-console""
  kubectl_client_id = ""tectonic-kubectl""
  ingress_kind      = ""NodePort""
  experimental      = ""${var.tectonic_experimental}""
  master_count      = ""${var.tectonic_master_count}""
  stats_url         = ""${var.tectonic_stats_url}""

  image_re = ""${var.tectonic_image_re}""
}

module ""flannel-vxlan"" {
  source = ""../../modules/net/flannel-vxlan""

  flannel_image     = ""${var.tectonic_container_images[""flannel""]}""
  flannel_cni_image = ""${var.tectonic_container_images[""flannel_cni""]}""
  cluster_cidr      = ""${var.tectonic_cluster_cidr}""
}

module ""calico-network-policy"" {
  source = ""../../modules/net/calico-network-policy""

  kube_apiserver_url = ""https://${module.vnet.api_fqdn}:443""
  calico_image       = ""${var.tectonic_container_images[""calico""]}""
  calico_cni_image   = ""${var.tectonic_container_images[""calico_cni""]}""
  cluster_cidr       = ""${var.tectonic_cluster_cidr}""
  enabled            = ""${var.tectonic_calico_network_policy}""
}


variable ""tectonic_azure_config_version"" {
  description = <<EOF
(internal) This declares the version of the Azure configuration variables.
It has no impact on generated assets but declares the version contract of the configuration.
EOF

  default = ""1.1""
}

variable ""tectonic_azure_ssh_network_internal"" {
  type = ""string""

  description = <<EOF
(optional) Network (internal) to allow SSH access from. Maps to `source_address_prefix` in Azure.
Defaults to `VirtualNetwork`. Should be internal to Azure environment.
Allowed values: [network CIDR (i.e., 10.0.0.0/16) \| `VirtualNetwork` \| `Internet` \| `*` ]
EOF

  default = ""VirtualNetwork""
}

variable ""tectonic_azure_ssh_network_external"" {
  type = ""string""

  description = <<EOF
(optional) Network (external) to allow SSH access from. Maps to `source_address_prefix` in Azure.
Defaults to `*`. Can be external to Azure environment.
Allowed values: [network CIDR (i.e., 10.0.0.0/16) \| `VirtualNetwork` \| `Internet` \| `*` ]
EOF

  default = ""*""
}

variable ""tectonic_azure_location"" {
  type = ""string""

  description = <<EOF
An Azure location where the cluster will be built.
Use the location name as returned in the *Name* column by `az account list-locations` CLI command.
Lowercase string with no spaces between words. Example: southcentralus
EOF
}

variable ""tectonic_azure_ssh_key"" {
  type        = ""string""
  description = ""(required) Path to an SSH public key file to be provisioned as the SSH key for the 'core' user.""
}

variable ""tectonic_azure_master_vm_size"" {
  type        = ""string""
  description = ""(optional) Instance size for the master node(s). Example: Standard_DS2_v2.""
  default     = ""Standard_DS2_v2""
}

variable ""tectonic_azure_worker_vm_size"" {
  type        = ""string""
  description = ""(optional) Instance size for the worker node(s). Example: Standard_DS2_v2.""
  default     = ""Standard_DS2_v2""
}

variable ""tectonic_azure_etcd_vm_size"" {
  type        = ""string""
  description = ""(optional) Instance size for the etcd node(s). Example: Standard_DS2_v2.""
  default     = ""Standard_DS2_v2""
}

variable ""tectonic_azure_master_storage_type"" {
  type = ""string""

  description = <<EOF
(optional) Storage account type for the master node(s). Example: Premium_LRS.
Using Premium storage is constrained by the of instance specified in 'tectonic_azure_master_vm_size'.
See https://docs.microsoft.com/en-us/azure/storage/storage-premium-storage#supported-vms
EOF

  default = ""Premium_LRS""
}

variable ""tectonic_azure_worker_storage_type"" {
  type = ""string""

  description = <<EOF
(optional) Storage account type for the worker node(s). Example: Premium_LRS.
Using Premium storage is constrained by the of instance specified in 'tectonic_azure_worker_vm_size'.
See https://docs.microsoft.com/en-us/azure/storage/storage-premium-storage#supported-vms
EOF

  default = ""Premium_LRS""
}

variable ""tectonic_azure_etcd_storage_type"" {
  type = ""string""

  description = <<EOF
(optional) Storage account type for the etcd node(s). Example: Premium_LRS.
Using Premium storage is constrained by the of instance specified in 'tectonic_azure_etcd_vm_size'.
See https://docs.microsoft.com/en-us/azure/storage/storage-premium-storage#supported-vms
EOF

  default = ""Premium_LRS""
}

variable ""tectonic_azure_vnet_cidr_block"" {
  type    = ""string""
  default = ""10.0.0.0/16""

  description = <<EOF
(optional) Range of IP addresses assigned to the Virtual Network in which the cluster nodes run.
This should not overlap with any other networks, such as the Kubernetes cluster (pod) range,
service range or a private datacenter connected via ExpressRoute.""
EOF
}

variable ""tectonic_azure_external_vnet_id"" {
  type    = ""string""
  default = """"

  description = <<EOF
(optional) Resource ID of an existing Virtual Network to launch nodes into.
Leave blank to create a new Virtual Network.

Note this is the complete ID as returned in the ""id"" field by the Azure client, not just the name of the resource.

Example: /subscriptions/b520eabf-d6c0-4757-8a5e-0fa7d2fe12b5/resourceGroups/my-k8s-cluster/providers/Microsoft.Network/virtualNetworks/my-k8s-vnet
EOF
}

variable ""tectonic_azure_external_master_subnet_id"" {
  type = ""string""

  description = <<EOF
(optional) Subnet ID within an existing VNet to deploy master nodes into.
Required to use an existing VNet.

Note this is the complete ID as returned in the ""id"" field by the Azure client, not just the name of the resource.

Example: ""/subscriptions/b520eabf-d6c0-4757-8a5e-0fa7d2fe12b5/resourceGroups/my-k8s-cluster/providers/Microsoft.Network/virtualNetworks/test-pre-vnet/subnets/my-k8s-subnet
EOF

  default = """"
}

variable ""tectonic_azure_external_worker_subnet_id"" {
  type = ""string""

  description = <<EOF
(optional) Subnet ID within an existing VNet to deploy worker nodes into.
Required to use an existing VNet.

Note this is the complete ID as returned in the ""id"" field by the Azure client, not just the name of the resource.

Example: ""/subscriptions/b520eabf-d6c0-4757-8a5e-0fa7d2fe12b5/resourceGroups/my-k8s-cluster/providers/Microsoft.Network/virtualNetworks/test-pre-vnet/subnets/my-k8s-subnet
EOF

  default = """"
}

variable ""tectonic_azure_external_resource_group"" {
  type = ""string""

  description = <<EOF
(optional) Name of an external resource group to place created resources in.
Leave blank to have a new one created.
EOF

  default = """"
}

variable ""tectonic_azure_external_nsg_master_id"" {
  type = ""string""

  description = <<EOF
(optional) The ID of the external Network Security Group used for masters.
Leave blank to have a new one created.

Note this is the complete ID as returned in the ""id"" field by the Azure client, not just the name of the resource.

Example: ""/subscriptions/b520eabf-d6c0-4757-8a5e-0fa7d2fe12b5/resourceGroups/my-k8s-cluster/providers/Microsoft.Network/networkSecurityGroups/my-master-nsg
EOF

  default = """"
}

variable ""tectonic_azure_external_nsg_worker_id"" {
  type = ""string""

  description = <<EOF
(optional) The ID of the external Network Security Group used for workers.
Leave blank to have a new one created.

Note this is the complete ID as returned in the ""id"" field by the Azure client, not just the name of the resource.

Example: ""/subscriptions/b520eabf-d6c0-4757-8a5e-0fa7d2fe12b5/resourceGroups/my-k8s-cluster/providers/Microsoft.Network/networkSecurityGroups/my-worker-nsg
EOF

  default = """"
}

variable ""tectonic_azure_external_dns_zone_id"" {
  description = <<EOF
(optional) The ID of the external Azure DNS zone used for nodes & endpoints FQDNs.
Required when 'tectonic_base_domain' is set.
This must be a pre-existing, properly configured Azure DNS zone that the Azure service principal running the Tectonic installer has permission to perform operations on.

Note this is the complete ID as returned in the ""id"" field by the Azure client, not just the name of the resource.

Example: ""/subscriptions/b520eabf-d6c0-4757-8a5e-0fa7d2fe12b5/resourceGroups/my-k8s-cluster/providers/Microsoft.Network/dnszones/my-k8s-dns
EOF

  default = """"
}

variable ""tectonic_azure_cloud_environment"" {
  type = ""string""

  description = <<EOF
(optional) Azure cloud environment to use. See
https://github.com/Azure/go-autorest/blob/ec5f4903f77ed9927ac95b19ab8e44ada64c1356/autorest/azure/environments.go#L13
for available environments.
EOF

  default = ""AZUREPUBLICCLOUD""
}

variable ""tectonic_azure_client_secret"" {
  type = ""string""

  description = ""The client secret to use.""
}

variable ""tectonic_azure_extra_tags"" {
  type = ""map""

  description = <<EOF
(optional) A map of extra Azure tags to be applied to created resources.
NOTE: Tags MUST NOT contain reserved characters '<,>,%,&,\,?,/' or control characters.
EOF

  default = {}
}

variable ""tectonic_azure_private_cluster"" {
  description = <<EOF
(optional) Setting this to true will result in NO public facing endpoints being created. All traffic is contained within the VNET.
A VNET with an already configured and active VPN connection is required and needs to be supplied via 'tectonic_azure_external_vnet_id'.
DNS is currently required, either the Azure managed one or configured via the generic DNS module.
EOF

  default = false
}


","{
  ""userQuery1"": ""The user wants to create a Kubernetes cluster on Azure. The cluster should include master nodes, worker nodes, and etcd nodes. The user wants to specify the instance size for these nodes and the type of storage account to use."",
  ""userQuery2"": ""The user wants to configure network settings for the cluster, including the ability to specify an existing Virtual Network and Subnet IDs. The user also wants to specify the range of IP addresses assigned to the Virtual Network."",
  ""userQuery3"": ""The user wants to enable SSH access to the cluster nodes from both internal and external networks. The user also wants to specify the path to an SSH public key file for the 'core' user."",
  ""userQuery4"": ""The user wants to use Azure's DNS service for the cluster nodes and endpoints. The user wants to specify an existing Azure DNS zone."",
  ""userQuery5"": ""The user wants to enable network policies using Calico"
48,bsiegel,tectonic-installer,modules/vmware/node,"data ""ignition_config"" ""node"" {
  count = ""${var.instance_count}""

  users = [
    ""${data.ignition_user.core.id}"",
  ]

  files = [
    ""${var.ign_max_user_watches_id}"",
    ""${data.ignition_file.node_hostname.*.id[count.index]}"",
    ""${var.ign_kubelet_env_id}"",
  ]

  systemd = [
    ""${var.ign_docker_dropin_id}"",
    ""${var.ign_locksmithd_service_id}"",
    ""${var.ign_kubelet_service_id}"",
    ""${var.ign_kubelet_env_service_id}"",
    ""${data.ignition_systemd_unit.bootkube.id}"",
    ""${data.ignition_systemd_unit.tectonic.id}"",
  ]

  networkd = [
    ""${data.ignition_networkd_unit.vmnetwork.*.id[count.index]}"",
  ]
}

data ""ignition_user"" ""core"" {
  name                = ""core""
  ssh_authorized_keys = [""${var.core_public_keys}""]
}

data ""ignition_systemd_unit"" ""bootkube"" {
  name    = ""bootkube.service""
  content = ""${var.bootkube_service}""
}

data ""ignition_systemd_unit"" ""tectonic"" {
  name    = ""tectonic.service""
  enable  = ""${var.tectonic_service_disabled == 0 ? true : false}""
  content = ""${var.tectonic_service}""
}

data ""ignition_networkd_unit"" ""vmnetwork"" {
  count = ""${var.instance_count}""
  name  = ""00-ens192.network""

  content = <<EOF
  [Match]
  Name=ens192
  [Network]
  DNS=${var.dns_server}
  Address=${var.ip_address[""${count.index}""]}
  Gateway=${var.gateway}
  UseDomains=yes
  Domains=${var.base_domain}
EOF
}

data ""ignition_file"" ""node_hostname"" {
  count      = ""${var.instance_count}""
  path       = ""/etc/hostname""
  mode       = 0644
  filesystem = ""root""

  content {
    content = ""${var.hostname[""${count.index}""]}""
  }
}


../../ignition/outputs.import

resource ""vsphere_virtual_machine"" ""node"" {
  count      = ""${var.instance_count}""
  name       = ""${var.hostname[""${count.index}""]}""
  datacenter = ""${var.vmware_datacenter}""
  cluster    = ""${var.vmware_cluster}""
  vcpu       = ""${var.vm_vcpu}""
  memory     = ""${var.vm_memory}""
  folder     = ""${var.vmware_folder}""
  domain     = ""${var.base_domain}""

  network_interface {
    label = ""${var.vm_network_label}""
  }

  disk {
    datastore = ""${var.vm_disk_datastore}""
    template  = ""${var.vm_disk_template_folder}/${var.vm_disk_template}""
    type      = ""thin""
  }

  custom_configuration_parameters {
    guestinfo.coreos.config.data.encoding = ""base64""
    guestinfo.coreos.config.data          = ""${base64encode(data.ignition_config.node.*.rendered[count.index])}""
  }

  connection {
    type        = ""ssh""
    user        = ""core""
    private_key = ""${file(var.private_key != """" ? pathexpand(var.private_key) : ""/dev/null"")}""
  }

  provisioner ""file"" {
    content     = ""${var.kubeconfig}""
    destination = ""$HOME/kubeconfig""
  }

  provisioner ""remote-exec"" {
    inline = [
      ""sudo mv /home/core/kubeconfig /etc/kubernetes/kubeconfig"",
    ]
  }
}


variable ""base_domain"" {
  type = ""string""
}

variable ""bootkube_service"" {
  type        = ""string""
  description = ""The content of the bootkube systemd service unit""
}

variable ""container_images"" {
  description = ""Container images to use""
  type        = ""map""
}

variable ""ign_kubelet_env_id"" {
  type = ""string""
}

variable ""image_re"" {
  description = ""(internal) Regular expression used to extract repo and tag components from image strings""
  type        = ""string""
}

variable ""instance_count"" {
  type        = ""string""
  description = ""Number of nodes to be created.""
}

variable ""kubeconfig"" {
  type        = ""string""
  description = ""Contents of Kubeconfig""
}

variable ""private_key"" {
  type        = ""string""
  description = ""SSH private key file in .pem format corresponding to tectonic_vmware_ssh_authorized_key. If not provided, SSH agent will be used.""
  default     = """"
}

variable ""tectonic_service"" {
  type        = ""string""
  description = ""The content of the tectonic installer systemd service unit""
}

variable ""tectonic_service_disabled"" {
  description = ""Specifies whether the tectonic installer systemd unit will be disabled. If true, no tectonic assets will be deployed""
  default     = false
}

variable ""vmware_folder"" {
  type        = ""string""
  description = ""Name of the VMware folder to create objects in""
}

variable ""core_public_keys"" {
  type        = ""list""
  description = ""Public Key for Core User""
}

variable ""dns_server"" {
  type        = ""string""
  description = ""DNS Server of the nodes""
}

variable ""gateway"" {
  type        = ""string""
  description = ""Gateway of the node""
}

variable ""hostname"" {
  type        = ""map""
  description = ""Hostname of the node""
}

variable ""ip_address"" {
  type        = ""map""
  description = ""IP Address of the node""
}

variable ""vm_disk_datastore"" {
  type        = ""string""
  description = ""Datastore to create VM(s) in ""
}

variable ""vm_disk_template"" {
  type        = ""string""
  description = ""Disk template to use for cloning CoreOS Container Linux""
}

variable ""vm_disk_template_folder"" {
  type        = ""string""
  description = ""vSphere Folder CoreOS Container Linux is located in""
}

variable ""vm_memory"" {
  type        = ""string""
  description = ""VMs Memory size in MB""
}

variable ""vm_network_label"" {
  type        = ""string""
  description = ""VMs PortGroup""
}

variable ""vm_vcpu"" {
  type        = ""string""
  description = ""VMs vCPU count""
}

variable ""vmware_cluster"" {
  type        = ""string""
  description = ""vSphere Cluster to create VMs in""
}

variable ""vmware_datacenter"" {
  type        = ""string""
  description = ""vSphere Datacenter to create VMs in""
}

variable ""ign_kubelet_env_service_id"" {
  type        = ""string""
  description = ""The kubelet env service to use""
}


output ""ip_address"" {
  value = [""${vsphere_virtual_machine.node.*.network_interface.0.ipv4_address}""]
}


","{
  ""userQuery1"": ""The user needs to create a certain number of virtual machines in a VMware environment. The number of instances, their names, and other specifications such as CPU, memory, and network settings are all customizable."",
  ""userQuery2"": ""The user intends to set up a CoreOS environment on these virtual machines, with specific system configurations, files, and users. The user also wants to enable certain systemd services, including 'bootkube' and 'tectonic', and set up network configurations."",
  ""userQuery3"": ""The user wants to provision these virtual machines with specific files and execute certain commands remotely. This includes moving a 'kubeconfig' file to a specific location and setting up SSH connections for remote management.""
}"
49,lander2k2,tectonic-installer,modules/tls/kube,"variable ""kube_ca_cert_pem"" {
  description = ""PEM-encoded CA certificate""
  type        = ""string""
}

variable ""kube_ca_key_alg"" {
  description = ""Algorithm used to generate kube_ca_key""
  type        = ""string""
}

variable ""kube_ca_key_pem"" {
  description = ""PEM-encoded CA key""
  type        = ""string""
}

variable ""aggregator_ca_cert_pem"" {
  description = ""PEM-encoded CA certificate""
  type        = ""string""
}

variable ""aggregator_ca_key_alg"" {
  description = ""Algorithm used to generate aggregator_ca_key""
  type        = ""string""
}

variable ""aggregator_ca_key_pem"" {
  description = ""PEM-encoded CA key""
  type        = ""string""
}

variable ""kube_apiserver_url"" {
  type = ""string""
}

variable ""service_cidr"" {
  type = ""string""
}


# Admin (generated/tls/{admin.key,admin.crt})
# Used to create kubeconfig (generated/auth/kubeconfig) with admin level privileges.
resource ""tls_private_key"" ""admin"" {
  algorithm = ""RSA""
  rsa_bits  = ""2048""
}

resource ""tls_cert_request"" ""admin"" {
  key_algorithm   = ""${tls_private_key.admin.algorithm}""
  private_key_pem = ""${tls_private_key.admin.private_key_pem}""

  subject {
    common_name  = ""admin""
    organization = ""system:masters""
  }
}

resource ""tls_locally_signed_cert"" ""admin"" {
  cert_request_pem = ""${tls_cert_request.admin.cert_request_pem}""

  ca_key_algorithm      = ""${var.kube_ca_key_alg}""
  ca_private_key_pem    = ""${var.kube_ca_key_pem}""
  ca_cert_pem           = ""${var.kube_ca_cert_pem}""
  validity_period_hours = ""26280""

  allowed_uses = [
    ""key_encipherment"",
    ""digital_signature"",
    ""server_auth"",
    ""client_auth"",
  ]
}


# Kubernetes API Server (resources/generated/tls/{apiserver.key,apiserver.crt})
resource ""tls_private_key"" ""apiserver"" {
  algorithm = ""RSA""
  rsa_bits  = ""2048""
}

resource ""tls_cert_request"" ""apiserver"" {
  key_algorithm   = ""${tls_private_key.apiserver.algorithm}""
  private_key_pem = ""${tls_private_key.apiserver.private_key_pem}""

  subject {
    common_name  = ""kube-apiserver""
    organization = ""kube-master""
  }

  dns_names = [
    ""${replace(element(split("":"", var.kube_apiserver_url), 1), ""/"", """")}"",
    ""kubernetes"",
    ""kubernetes.default"",
    ""kubernetes.default.svc"",
    ""kubernetes.default.svc.cluster.local"",
  ]

  ip_addresses = [
    ""${cidrhost(var.service_cidr, 1)}"",
  ]
}

resource ""tls_locally_signed_cert"" ""apiserver"" {
  cert_request_pem = ""${tls_cert_request.apiserver.cert_request_pem}""

  ca_key_algorithm      = ""${var.kube_ca_key_alg}""
  ca_private_key_pem    = ""${var.kube_ca_key_pem}""
  ca_cert_pem           = ""${var.kube_ca_cert_pem}""
  validity_period_hours = ""26280""

  allowed_uses = [
    ""key_encipherment"",
    ""digital_signature"",
    ""server_auth"",
    ""client_auth"",
  ]
}


# Kubernetes API Server Proxy (resources/generated/tls/{apiserver-proxy.key,apiserver-proxy.crt})
resource ""tls_private_key"" ""apiserver_proxy"" {
  algorithm = ""RSA""
  rsa_bits  = ""2048""
}

resource ""tls_cert_request"" ""apiserver_proxy"" {
  key_algorithm   = ""${tls_private_key.apiserver_proxy.algorithm}""
  private_key_pem = ""${tls_private_key.apiserver_proxy.private_key_pem}""

  subject {
    common_name  = ""kube-apiserver-proxy""
    organization = ""kube-master""
  }
}

resource ""tls_locally_signed_cert"" ""apiserver_proxy"" {
  cert_request_pem = ""${tls_cert_request.apiserver_proxy.cert_request_pem}""

  ca_key_algorithm      = ""${var.aggregator_ca_key_alg}""
  ca_private_key_pem    = ""${var.aggregator_ca_key_pem}""
  ca_cert_pem           = ""${var.aggregator_ca_cert_pem}""
  validity_period_hours = ""26280""

  allowed_uses = [
    ""key_encipherment"",
    ""digital_signature"",
    ""client_auth"",
  ]
}


resource ""local_file"" ""apiserver_key"" {
  content  = ""${tls_private_key.apiserver.private_key_pem}""
  filename = ""./generated/tls/apiserver.key""
}

data ""template_file"" ""apiserver_cert"" {
  template = ""${join("""", list(tls_locally_signed_cert.apiserver.cert_pem, var.kube_ca_cert_pem))}""
}

resource ""local_file"" ""apiserver_cert"" {
  content  = ""${data.template_file.apiserver_cert.rendered}""
  filename = ""./generated/tls/apiserver.crt""
}

resource ""local_file"" ""apiserver_proxy_key"" {
  content  = ""${tls_private_key.apiserver_proxy.private_key_pem}""
  filename = ""./generated/tls/apiserver-proxy.key""
}

resource ""local_file"" ""apiserver_proxy_cert"" {
  content  = ""${tls_locally_signed_cert.apiserver_proxy.cert_pem}""
  filename = ""./generated/tls/apiserver-proxy.crt""
}

resource ""local_file"" ""admin_key"" {
  content  = ""${tls_private_key.admin.private_key_pem}""
  filename = ""./generated/tls/admin.key""
}

resource ""local_file"" ""admin_cert"" {
  content  = ""${tls_locally_signed_cert.admin.cert_pem}""
  filename = ""./generated/tls/admin.crt""
}


output ""admin_cert_pem"" {
  value = ""${tls_locally_signed_cert.admin.cert_pem}""
}

output ""admin_key_pem"" {
  value = ""${tls_private_key.admin.private_key_pem}""
}

output ""apiserver_cert_pem"" {
  value = ""${data.template_file.apiserver_cert.rendered}""
}

output ""apiserver_key_pem"" {
  value = ""${tls_private_key.apiserver.private_key_pem}""
}

output ""apiserver_proxy_cert_pem"" {
  value = ""${tls_locally_signed_cert.apiserver_proxy.cert_pem}""
}

output ""apiserver_proxy_key_pem"" {
  value = ""${tls_private_key.apiserver_proxy.private_key_pem}""
}

output ""id"" {
  value = ""${sha1(""
  ${join("" "",
    list(local_file.apiserver_key.id,
    local_file.apiserver_cert.id,
    local_file.apiserver_proxy_key.id,
    local_file.apiserver_proxy_cert.id,
    local_file.admin_key.id,
    local_file.admin_cert.id,)
    )}
  "")}""
}


","{
  ""userQuery1"": ""The user needs to generate a private key and a certificate for an admin user with admin level privileges. The certificate should be signed by a Certificate Authority (CA) and should be valid for a certain number of hours. The private key and the certificate should be saved in specific files."",
  ""userQuery2"": ""The user needs to generate a private key and a certificate for a Kubernetes API server. The certificate should be signed by a Certificate Authority (CA) and should be valid for a certain number of hours. The certificate should include certain DNS names and IP addresses. The private key and the certificate should be saved in specific files."",
  ""userQuery3"": ""The user needs to generate a private key and a certificate for a Kubernetes API server proxy. The certificate should be signed by a different Certificate Authority (CA) and should be valid for a certain number of hours. The private key and the certificate should be saved in specific files."",
  ""user"
50,hashicorp,terraform,internal/terraform/testdata/import-provider-locals,"variable ""foo"" {}

locals {
  baz = ""baz-${var.foo}""
}

provider ""aws"" {
  foo = ""${local.baz}""
}

resource ""aws_instance"" ""foo"" {
  id = ""bar""
}


","{
  ""userQuery1"": ""The user needs to create a variable named 'foo' that can be used in the Terraform configuration. The value of this variable is not defined in the code, so it will need to be provided when the code is run."",
  ""userQuery2"": ""The user wants to create a local value 'baz' that is a string composed of the word 'baz' followed by the value of the variable 'foo'. This local value can be used in other parts of the Terraform configuration."",
  ""userQuery3"": ""The user intends to set up an AWS provider and an AWS instance resource. The provider has a parameter 'foo' that is set to the local value 'baz'. The AWS instance resource has an id of 'bar'.""
}"
51,aknuds1,tectonic-installer,modules/aws/vpc,"variable ""master_az_count"" {
  type = ""string""
}

variable ""worker_az_count"" {
  type = ""string""
}

variable ""cidr_block"" {
  type = ""string""
}

variable ""cluster_id"" {
  type = ""string""
}

variable ""base_domain"" {
  type = ""string""
}

variable ""cluster_name"" {
  type = ""string""
}

variable ""external_vpc_id"" {
  type = ""string""
}

variable ""external_master_subnets"" {
  type = ""list""
}

variable ""external_worker_subnets"" {
  type = ""list""
}

variable ""extra_tags"" {
  description = ""Extra AWS tags to be applied to created resources.""
  type        = ""map""
  default     = {}
}

variable ""enable_etcd_sg"" {
  description = ""If set to true, security groups for etcd nodes are being created""
  default     = true
}

variable ""master_subnets"" {
  type = ""list""
}

variable ""worker_subnets"" {
  type = ""list""
}

variable ""master_azs"" {
  type = ""list""
}

variable ""worker_azs"" {
  type = ""list""
}

variable ""private_master_endpoints"" {
  description = ""If set to true, private-facing ingress resources are created.""
  default     = true
}

variable ""public_master_endpoints"" {
  description = ""If set to true, public-facing ingress resources are created.""
  default     = true
}

variable ""custom_dns_name"" {
  type        = ""string""
  default     = """"
  description = ""DNS prefix used to construct the console and API server endpoints.""
}


data ""aws_availability_zones"" ""azs"" {}

resource ""aws_vpc"" ""new_vpc"" {
  count                = ""${var.external_vpc_id == """" ? 1 : 0}""
  cidr_block           = ""${var.cidr_block}""
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}.${var.base_domain}"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""shared"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

data ""aws_vpc"" ""cluster_vpc"" {
  # The join() hack is required because currently the ternary operator
  # evaluates the expressions on both branches of the condition before
  # returning a value. When providing and external VPC, the template VPC
  # resource gets a count of zero which triggers an evaluation error.
  #
  # This is tracked upstream: https://github.com/hashicorp/hil/issues/50
  #
  id = ""${var.external_vpc_id == """" ? join("" "", aws_vpc.new_vpc.*.id) : var.external_vpc_id }""
}

locals {
  master_subnet_ids = [""${split("","", var.external_vpc_id == """" ? join("","", aws_subnet.master_subnet.*.id) :  join("","", data.aws_subnet.external_master.*.id))}""]
  worker_subnet_ids = [""${split("","", var.external_vpc_id == """" ? join("","", aws_subnet.worker_subnet.*.id) :  join("","", data.aws_subnet.external_worker.*.id))}""]
}


# These subnet data-sources import external subnets from their user-supplied subnet IDs
# whenever an external VPC is specified
#
data ""aws_subnet"" ""external_worker"" {
  count = ""${var.external_vpc_id == """" ? 0 : length(var.external_worker_subnets)}""
  id    = ""${var.external_worker_subnets[count.index]}""
}

data ""aws_subnet"" ""external_master"" {
  count = ""${var.external_vpc_id == """" ? 0 : length(var.external_master_subnets)}""
  id    = ""${var.external_master_subnets[count.index]}""
}


resource ""aws_internet_gateway"" ""igw"" {
  count  = ""${var.external_vpc_id == """" ? 1 : 0}""
  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}-igw"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""shared"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_route_table"" ""default"" {
  count  = ""${var.external_vpc_id == """" ? 1 : 0}""
  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}-public"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""shared"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_main_route_table_association"" ""main_vpc_routes"" {
  count          = ""${var.external_vpc_id == """" ? 1 : 0}""
  vpc_id         = ""${data.aws_vpc.cluster_vpc.id}""
  route_table_id = ""${aws_route_table.default.id}""
}

resource ""aws_route"" ""igw_route"" {
  count                  = ""${var.external_vpc_id == """" ? 1 : 0}""
  destination_cidr_block = ""0.0.0.0/0""
  route_table_id         = ""${aws_route_table.default.id}""
  gateway_id             = ""${aws_internet_gateway.igw.id}""
}

resource ""aws_subnet"" ""master_subnet"" {
  count = ""${var.external_vpc_id == """" ? var.master_az_count : 0}""

  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  cidr_block = ""${length(var.master_subnets) > 1 ?
    ""${element(var.master_subnets, count.index)}"" :
    ""${cidrsubnet(data.aws_vpc.cluster_vpc.cidr_block, 4, count.index)}""
  }""

  availability_zone = ""${var.master_azs[count.index]}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}-master-${ ""${length(var.master_azs)}"" > 0 ?
     ""${var.master_azs[count.index]}"" :
     ""${data.aws_availability_zones.azs.names[count.index]}"" }"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""shared"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_route_table_association"" ""route_net"" {
  count          = ""${var.external_vpc_id == """" ? var.master_az_count : 0}""
  route_table_id = ""${aws_route_table.default.id}""
  subnet_id      = ""${aws_subnet.master_subnet.*.id[count.index]}""
}

resource ""aws_eip"" ""nat_eip"" {
  count = ""${var.external_vpc_id == """" ? min(var.master_az_count, var.worker_az_count) : 0}""
  vpc   = true

  # Terraform does not declare an explicit dependency towards the internet gateway.
  # this can cause the internet gateway to be deleted/detached before the EIPs.
  # https://github.com/coreos/tectonic-installer/issues/1017#issuecomment-307780549
  depends_on = [""aws_internet_gateway.igw""]
}

resource ""aws_nat_gateway"" ""nat_gw"" {
  count         = ""${var.external_vpc_id == """" ? min(var.master_az_count, var.worker_az_count) : 0}""
  allocation_id = ""${aws_eip.nat_eip.*.id[count.index]}""
  subnet_id     = ""${aws_subnet.master_subnet.*.id[count.index]}""
}


resource ""aws_route_table"" ""private_routes"" {
  count  = ""${var.external_vpc_id == """" ? var.worker_az_count : 0}""
  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}-private-${data.aws_availability_zones.azs.names[count.index]}"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""shared"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_route"" ""to_nat_gw"" {
  count                  = ""${var.external_vpc_id == """" ? var.worker_az_count : 0}""
  route_table_id         = ""${aws_route_table.private_routes.*.id[count.index]}""
  destination_cidr_block = ""0.0.0.0/0""
  nat_gateway_id         = ""${element(aws_nat_gateway.nat_gw.*.id, count.index)}""
  depends_on             = [""aws_route_table.private_routes""]
}

resource ""aws_subnet"" ""worker_subnet"" {
  count = ""${var.external_vpc_id == """" ? var.worker_az_count : 0}""

  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  cidr_block = ""${length(var.worker_subnets) > 1 ?
    ""${element(var.worker_subnets, count.index)}"" :
    ""${cidrsubnet(data.aws_vpc.cluster_vpc.cidr_block, 4, count.index + var.worker_az_count)}""
  }""

  availability_zone = ""${var.worker_azs[count.index]}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}-worker-${ ""${length(var.worker_azs)}"" > 0 ?
    ""${var.worker_azs[count.index]}"" :
    ""${data.aws_availability_zones.azs.names[count.index]}"" }"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""shared"",
      ""kubernetes.io/role/internal-elb"", """",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_route_table_association"" ""worker_routing"" {
  count          = ""${var.external_vpc_id == """" ? var.worker_az_count : 0}""
  route_table_id = ""${aws_route_table.private_routes.*.id[count.index]}""
  subnet_id      = ""${aws_subnet.worker_subnet.*.id[count.index]}""
}


resource ""aws_security_group"" ""api"" {
  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}_api_sg"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""owned"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    self        = true
    cidr_blocks = [""0.0.0.0/0""]
  }

  ingress {
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
    from_port   = 443
    to_port     = 443
  }
}

resource ""aws_security_group"" ""console"" {
  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}_console_sg"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""owned"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    self        = true
    cidr_blocks = [""0.0.0.0/0""]
  }

  ingress {
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
    from_port   = 80
    to_port     = 80
  }

  ingress {
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
    from_port   = 443
    to_port     = 443
  }
}


resource ""aws_security_group"" ""etcd"" {
  count  = ""${var.enable_etcd_sg}""
  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}_etcd_sg"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""owned"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    self        = true
    cidr_blocks = [""0.0.0.0/0""]
  }

  ingress {
    protocol    = ""icmp""
    cidr_blocks = [""0.0.0.0/0""]
    from_port   = 0
    to_port     = 0
  }

  ingress {
    protocol  = ""tcp""
    from_port = 22
    to_port   = 22
    self      = true

    security_groups = [""${aws_security_group.master.id}""]
  }

  ingress {
    protocol  = ""tcp""
    from_port = 2379
    to_port   = 2379
    self      = true

    security_groups = [""${aws_security_group.master.id}""]
  }

  ingress {
    protocol  = ""tcp""
    from_port = 2380
    to_port   = 2380
    self      = true
  }
}


resource ""aws_security_group"" ""master"" {
  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}_master_sg"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""owned"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_security_group_rule"" ""master_egress"" {
  type              = ""egress""
  security_group_id = ""${aws_security_group.master.id}""

  from_port   = 0
  to_port     = 0
  protocol    = ""-1""
  cidr_blocks = [""0.0.0.0/0""]
}

resource ""aws_security_group_rule"" ""master_ingress_icmp"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol    = ""icmp""
  cidr_blocks = [""0.0.0.0/0""]
  from_port   = 0
  to_port     = 0
}

resource ""aws_security_group_rule"" ""master_ingress_ssh"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol    = ""tcp""
  cidr_blocks = [""0.0.0.0/0""]
  from_port   = 22
  to_port     = 22
}

resource ""aws_security_group_rule"" ""master_ingress_http"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol    = ""tcp""
  cidr_blocks = [""0.0.0.0/0""]
  from_port   = 80
  to_port     = 80
}

resource ""aws_security_group_rule"" ""master_ingress_https"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol    = ""tcp""
  cidr_blocks = [""0.0.0.0/0""]
  from_port   = 443
  to_port     = 443
}

resource ""aws_security_group_rule"" ""master_ingress_heapster"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 4194
  to_port   = 4194
  self      = true
}

resource ""aws_security_group_rule"" ""master_ingress_heapster_from_worker"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.master.id}""
  source_security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 4194
  to_port   = 4194
}

resource ""aws_security_group_rule"" ""master_ingress_flannel"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""udp""
  from_port = 4789
  to_port   = 4789
  self      = true
}

resource ""aws_security_group_rule"" ""master_ingress_flannel_from_worker"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.master.id}""
  source_security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""udp""
  from_port = 4789
  to_port   = 4789
}

resource ""aws_security_group_rule"" ""master_ingress_node_exporter"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 9100
  to_port   = 9100
  self      = true
}

resource ""aws_security_group_rule"" ""master_ingress_node_exporter_from_worker"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.master.id}""
  source_security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 9100
  to_port   = 9100
}

resource ""aws_security_group_rule"" ""master_ingress_kubelet_insecure"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 10250
  to_port   = 10250
  self      = true
}

resource ""aws_security_group_rule"" ""master_ingress_kubelet_insecure_from_worker"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.master.id}""
  source_security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 10250
  to_port   = 10250
}

resource ""aws_security_group_rule"" ""master_ingress_kubelet_secure"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 10255
  to_port   = 10255
  self      = true
}

resource ""aws_security_group_rule"" ""master_ingress_kubelet_secure_from_worker"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.master.id}""
  source_security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 10255
  to_port   = 10255
}

resource ""aws_security_group_rule"" ""master_ingress_etcd"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 2379
  to_port   = 2380
  self      = true
}

resource ""aws_security_group_rule"" ""master_ingress_bootstrap_etcd"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 12379
  to_port   = 12380
  self      = true
}

resource ""aws_security_group_rule"" ""master_ingress_services"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 30000
  to_port   = 32767
  self      = true
}

resource ""aws_security_group_rule"" ""master_ingress_services_from_console"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.master.id}""
  source_security_group_id = ""${aws_security_group.console.id}""

  protocol  = ""tcp""
  from_port = 30000
  to_port   = 32767
}


resource ""aws_security_group"" ""worker"" {
  vpc_id = ""${data.aws_vpc.cluster_vpc.id}""

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}_worker_sg"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""owned"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_security_group_rule"" ""worker_egress"" {
  type              = ""egress""
  security_group_id = ""${aws_security_group.worker.id}""

  from_port   = 0
  to_port     = 0
  protocol    = ""-1""
  cidr_blocks = [""0.0.0.0/0""]
}

resource ""aws_security_group_rule"" ""worker_ingress_icmp"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol    = ""icmp""
  cidr_blocks = [""0.0.0.0/0""]
  from_port   = 0
  to_port     = 0
}

resource ""aws_security_group_rule"" ""worker_ingress_ssh"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol    = ""tcp""
  cidr_blocks = [""0.0.0.0/0""]
  from_port   = 22
  to_port     = 22
}

resource ""aws_security_group_rule"" ""worker_ingress_http"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol    = ""tcp""
  cidr_blocks = [""0.0.0.0/0""]
  from_port   = 80
  to_port     = 80
}

resource ""aws_security_group_rule"" ""worker_ingress_https"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol    = ""tcp""
  cidr_blocks = [""0.0.0.0/0""]
  from_port   = 443
  to_port     = 443
}

resource ""aws_security_group_rule"" ""worker_ingress_heapster"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 4194
  to_port   = 4194
  self      = true
}

resource ""aws_security_group_rule"" ""worker_ingress_heapster_from_master"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.worker.id}""
  source_security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 4194
  to_port   = 4194
}

resource ""aws_security_group_rule"" ""worker_ingress_flannel"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""udp""
  from_port = 4789
  to_port   = 4789
  self      = true
}

resource ""aws_security_group_rule"" ""worker_ingress_flannel_from_master"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.worker.id}""
  source_security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""udp""
  from_port = 4789
  to_port   = 4789
}

resource ""aws_security_group_rule"" ""worker_ingress_node_exporter"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 9100
  to_port   = 9100
  self      = true
}

resource ""aws_security_group_rule"" ""worker_ingress_node_exporter_from_master"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.worker.id}""
  source_security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 9100
  to_port   = 9100
}

resource ""aws_security_group_rule"" ""worker_ingress_kubelet_insecure"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 10250
  to_port   = 10250
  self      = true
}

resource ""aws_security_group_rule"" ""worker_ingress_kubelet_insecure_from_master"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.worker.id}""
  source_security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 10250
  to_port   = 10250
}

resource ""aws_security_group_rule"" ""worker_ingress_kubelet_secure"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 10255
  to_port   = 10255
  self      = true
}

resource ""aws_security_group_rule"" ""worker_ingress_kubelet_secure_from_master"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.worker.id}""
  source_security_group_id = ""${aws_security_group.master.id}""

  protocol  = ""tcp""
  from_port = 10255
  to_port   = 10255
}

resource ""aws_security_group_rule"" ""worker_ingress_services"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.worker.id}""

  protocol  = ""tcp""
  from_port = 30000
  to_port   = 32767
  self      = true
}

resource ""aws_security_group_rule"" ""worker_ingress_services_from_console"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.worker.id}""
  source_security_group_id = ""${aws_security_group.console.id}""

  protocol  = ""tcp""
  from_port = 30000
  to_port   = 32767
}


resource ""aws_elb"" ""api_internal"" {
  count           = ""${var.private_master_endpoints}""
  name            = ""${var.cluster_name}-int""
  subnets         = [""${local.master_subnet_ids}""]
  internal        = true
  security_groups = [""${aws_security_group.api.id}""]

  idle_timeout                = 3600
  connection_draining         = true
  connection_draining_timeout = 300

  listener {
    instance_port     = 443
    instance_protocol = ""tcp""
    lb_port           = 443
    lb_protocol       = ""tcp""
  }

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 2
    timeout             = 3
    target              = ""SSL:443""
    interval            = 5
  }

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}-int"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""owned"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_elb"" ""api_external"" {
  count           = ""${var.public_master_endpoints}""
  name            = ""${var.custom_dns_name == """" ? var.cluster_name : var.custom_dns_name}-ext""
  subnets         = [""${local.master_subnet_ids}""]
  internal        = false
  security_groups = [""${aws_security_group.api.id}""]

  idle_timeout                = 3600
  connection_draining         = true
  connection_draining_timeout = 300

  listener {
    instance_port     = 443
    instance_protocol = ""tcp""
    lb_port           = 443
    lb_protocol       = ""tcp""
  }

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 2
    timeout             = 3
    target              = ""SSL:443""
    interval            = 5
  }

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}-api-external"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""owned"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}

resource ""aws_elb"" ""console"" {
  name            = ""${var.custom_dns_name == """" ? var.cluster_name : var.custom_dns_name}-con""
  subnets         = [""${local.master_subnet_ids}""]
  internal        = ""${var.public_master_endpoints ? false : true}""
  security_groups = [""${aws_security_group.console.id}""]

  idle_timeout = 3600

  listener {
    instance_port     = 32001
    instance_protocol = ""tcp""
    lb_port           = 80
    lb_protocol       = ""tcp""
  }

  listener {
    instance_port     = 32000
    instance_protocol = ""tcp""
    lb_port           = 443
    lb_protocol       = ""tcp""
  }

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 2
    timeout             = 3
    target              = ""HTTP:32002/healthz""
    interval            = 5
  }

  tags = ""${merge(map(
      ""Name"", ""${var.cluster_name}-console"",
      ""kubernetes.io/cluster/${var.cluster_name}"", ""owned"",
      ""tectonicClusterID"", ""${var.cluster_id}""
    ), var.extra_tags)}""
}


output ""vpc_id"" {
  value = ""${data.aws_vpc.cluster_vpc.id}""
}

# We have to do this join() & split() 'trick' because null_data_source and
# the ternary operator can't output lists or maps
output ""master_subnet_ids"" {
  value = ""${local.master_subnet_ids}""
}

output ""worker_subnet_ids"" {
  value = ""${local.worker_subnet_ids}""
}

output ""etcd_sg_id"" {
  value = ""${element(concat(aws_security_group.etcd.*.id, list("""")), 0)}""
}

output ""master_sg_id"" {
  value = ""${aws_security_group.master.id}""
}

output ""worker_sg_id"" {
  value = ""${aws_security_group.worker.id}""
}

output ""api_sg_id"" {
  value = ""${aws_security_group.api.id}""
}

output ""console_sg_id"" {
  value = ""${aws_security_group.console.id}""
}

output ""aws_elb_api_external_id"" {
  value = ""${aws_elb.api_external.*.id}""
}

output ""aws_elb_internal_id"" {
  value = ""${aws_elb.api_internal.*.id}""
}

output ""aws_elb_console_id"" {
  value = ""${aws_elb.console.id}""
}

output ""aws_lbs"" {
  value = [""${compact(concat(aws_elb.api_internal.*.id, list(aws_elb.console.id), aws_elb.api_external.*.id))}""]
}

output ""aws_api_external_dns_name"" {
  value = ""${element(concat(aws_elb.api_external.*.dns_name, list("""")), 0)}""
}

output ""aws_elb_api_external_zone_id"" {
  value = ""${element(concat(aws_elb.api_external.*.zone_id, list("""")), 0)}""
}

output ""aws_api_internal_dns_name"" {
  value = ""${element(concat(aws_elb.api_internal.*.dns_name, list("""")), 0)}""
}

output ""aws_elb_api_internal_zone_id"" {
  value = ""${element(concat(aws_elb.api_internal.*.zone_id, list("""")), 0)}""
}

output ""aws_console_dns_name"" {
  value = ""${aws_elb.console.dns_name}""
}

output ""aws_elb_console_zone_id"" {
  value = ""${aws_elb.console.zone_id}""
}


","{
  ""userQuery1"": ""The user wants to create a new Virtual Private Cloud (VPC) in AWS with specific CIDR block, DNS hostname and DNS support. If an external VPC ID is provided, the user wants to use the existing VPC instead of creating a new one."",
  ""userQuery2"": ""The user wants to create a set of subnets within the VPC for master and worker nodes. If external subnet IDs are provided, the user wants to use the existing subnets instead of creating new ones. The user also wants to create an internet gateway, route tables, and NAT gateways for these subnets."",
  ""userQuery3"": ""The user wants to create several security groups with specific ingress and egress rules for different components of the cluster such as API, console, etcd, master, and worker nodes."",
  ""userQuery4"": ""The user wants to create internal and external Elastic Load Balancers (ELBs) for the"
52,GoogleCloudPlatform,sap-deployment-automation,terraform/modules/terraform-google-vm/test/fixtures/compute_instance/simple,"/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = ""~> 0.12.6""
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""project_id"" {
  description = ""The GCP project to use for integration tests""
}

variable ""service_account"" {
  default = null
  type = object({
    email  = string
    scopes = list(string)
  })
  description = ""Service account to attach to the instance. See https://www.terraform.io/docs/providers/google/r/compute_instance_template.html#service_account.""
}



/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


module ""instance_simple"" {
  source          = ""../../../../examples/compute_instance/simple""
  project_id      = var.project_id
  region          = ""us-central1""
  subnetwork      = google_compute_subnetwork.main.self_link
  num_instances   = 4
  service_account = var.service_account
}


../../shared/network.tf

/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""instances_self_links"" {
  description = ""List of instance self-links""
  value       = module.instance_simple.instances_self_links
}

output ""project_id"" {
  description = ""The GCP project to use for integration tests""
  value       = var.project_id
}





","{
  ""userQuery1"": ""What is the required version of Terraform for this project?"",
  ""userQuery2"": ""What are the details of the Google Cloud Platform (GCP) project to be used for integration tests?"",
  ""userQuery3"": ""What are the details of the service account to be attached to the instance?"",
  ""userQuery4"": ""What is the source of the 'instance_simple' module and what are its configurations?"",
  ""userQuery5"": ""What is the number of instances to be created in the 'instance_simple' module?"",
  ""userQuery6"": ""What is the region where the instances in the 'instance_simple' module will be created?"",
  ""userQuery7"": ""What is the subnetwork where the instances in the 'instance_simple' module will be created?"",
  ""userQuery8"": ""What are the self-links of the instances created in the 'instance_simple' module?"",
  ""userQuery9"": """
53,nusnewob,terraform-module-aws-vpc,,"variable ""aws_conf"" {
  type    = ""map""
  default = {}
}

data ""aws_region"" ""region"" {
  name = ""${var.aws_conf[""region""]}""
}

resource ""aws_vpc"" ""default"" {
  cidr_block                       = ""${var.aws_conf[""cidr_block""]}""
  assign_generated_ipv6_cidr_block = true
  enable_dns_hostnames             = true

  tags {
    Name  = ""${var.aws_conf[""domain""]} VPC""
    Stack = ""${var.aws_conf[""domain""]}""
  }

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

data ""aws_availability_zones"" ""vpc_az"" {
  state = ""available""
}

resource ""aws_internet_gateway"" ""default"" {
  vpc_id = ""${aws_vpc.default.id}""

  tags {
    Name  = ""${var.aws_conf[""domain""]} VPC Gateway""
    Stack = ""${var.aws_conf[""domain""]}""
  }

  depends_on = [""aws_vpc.default""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_egress_only_internet_gateway"" ""ipv6-gw"" {
  vpc_id = ""${aws_vpc.default.id}""

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_vpc_dhcp_options"" ""search"" {
  domain_name         = ""${var.aws_conf[""domain""]}""
  domain_name_servers = [""AmazonProvidedDNS""]

  tags {
    Name  = ""${var.aws_conf[""domain""]} DHCP""
    Stack = ""${var.aws_conf[""domain""]}""
  }

  depends_on = [""aws_subnet.public"", ""aws_subnet.private""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_vpc_dhcp_options_association"" ""search"" {
  vpc_id          = ""${aws_vpc.default.id}""
  dhcp_options_id = ""${aws_vpc_dhcp_options.search.id}""

  depends_on = [""aws_subnet.public"", ""aws_subnet.private""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_vpc_endpoint"" ""vpc_endpoint"" {
  vpc_id       = ""${aws_vpc.default.id}""
  service_name = ""com.amazonaws.${data.aws_region.region.name}.s3""
}

resource ""aws_vpn_gateway"" ""vpn_gw"" {
  vpc_id = ""${aws_vpc.default.id}""

  tags {
    Name  = ""${var.aws_conf[""domain""]} VPN Gateway""
    Stack = ""${var.aws_conf[""domain""]}""
  }

  depends_on = [""aws_vpc.default""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_security_group"" ""base-sg"" {
  name        = ""${var.aws_conf[""domain""]}-base-sg""
  description = ""Allow outgoing traffic""

  vpc_id = ""${aws_vpc.default.id}""

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }

  egress {
    from_port        = 0
    to_port          = 0
    protocol         = ""-1""
    ipv6_cidr_blocks = [""::/0""]
  }

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = ""tcp""
    cidr_blocks = [""${var.aws_conf[""cidr_block""]}""]
  }

  tags {
    Name  = ""${var.aws_conf[""domain""]} default SG""
    Stack = ""${var.aws_conf[""domain""]}""
  }

  depends_on = [""aws_vpc.default""]

  lifecycle {
    create_before_destroy = true
  }
}


data ""aws_ami"" ""ami"" {
  most_recent = true
  name_regex  = ""${var.aws_conf[""ami_name""]}""

  filter {
    name   = ""virtualization-type""
    values = [""hvm""]
  }

  filter {
    name   = ""architecture""
    values = [""x86_64""]
  }

  filter {
    name   = ""root-device-type""
    values = [""ebs""]
  }
}


resource ""aws_kms_key"" ""kms_key"" {
  description = ""KMS key for ${var.aws_conf[""domain""]}""
}

resource ""aws_iam_role"" ""default"" {
  name               = ""${var.aws_conf[""domain""]}-role""
  assume_role_policy = ""${file(""${path.module}/policies/default-role.json"")}""
}

resource ""aws_iam_role_policy"" ""default"" {
  name   = ""${var.aws_conf[""domain""]}-role-policy""
  policy = ""${file(""${path.module}/policies/default-policy.json"")}""
  role   = ""${aws_iam_role.default.id}""
}

resource ""aws_iam_instance_profile"" ""default"" {
  name = ""${var.aws_conf[""domain""]}-profile""
  path = ""/""
  role = ""${aws_iam_role.default.name}""

  lifecycle {
    create_before_destroy = true
  }
}


resource ""aws_route53_zone"" ""root_zone"" {
  name = ""${var.aws_conf[""domain""]}.""

  tags {
    Name  = ""${var.aws_conf[""domain""]}""
    Stack = ""${var.aws_conf[""domain""]}""
  }

  lifecycle {
    prevent_destroy = true
  }
}


resource ""aws_subnet"" ""public"" {
  count  = ""${length(data.aws_availability_zones.vpc_az.names)}""
  vpc_id = ""${aws_vpc.default.id}""

  availability_zone               = ""${element(data.aws_availability_zones.vpc_az.names, count.index)}""
  ipv6_cidr_block                 = ""${cidrsubnet(aws_vpc.default.ipv6_cidr_block, 8, count.index + 1)}""
  cidr_block                      = ""${cidrsubnet(var.aws_conf[""cidr_block""], 4, count.index + 1)}""
  map_public_ip_on_launch         = true
  assign_ipv6_address_on_creation = true

  tags {
    Name             = ""${var.aws_conf[""domain""]} Public Subnet ${element(data.aws_availability_zones.vpc_az.names, count.index)}""
    Stack            = ""${var.aws_conf[""domain""]}""
    AvailabilityZone = ""${element(data.aws_availability_zones.vpc_az.names, count.index)}""
    Type             = ""public""
  }

  depends_on = [""aws_vpc.default""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_route_table"" ""public"" {
  vpc_id = ""${aws_vpc.default.id}""

  route {
    cidr_block = ""0.0.0.0/0""
    gateway_id = ""${aws_internet_gateway.default.id}""
  }

  route {
    ipv6_cidr_block        = ""::/0""
    egress_only_gateway_id = ""${aws_egress_only_internet_gateway.ipv6-gw.id}""
  }

  tags {
    Name  = ""${var.aws_conf[""domain""]} Public Routing Table ${join(""/"", data.aws_availability_zones.vpc_az.names)}""
    Stack = ""${var.aws_conf[""domain""]}""
  }

  depends_on = [""aws_subnet.public""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_vpc_endpoint_route_table_association"" ""public_vpc_endpoint"" {
  vpc_endpoint_id = ""${aws_vpc_endpoint.vpc_endpoint.id}""
  route_table_id  = ""${aws_route_table.public.id}""
}

resource ""aws_route_table_association"" ""public"" {
  count          = ""${length(data.aws_availability_zones.vpc_az.names)}""
  subnet_id      = ""${element(aws_subnet.public.*.id, count.index)}""
  route_table_id = ""${aws_route_table.public.id}""

  depends_on = [""aws_route_table.public""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}


resource ""aws_subnet"" ""private"" {
  count  = ""${length(data.aws_availability_zones.vpc_az.names)}""
  vpc_id = ""${aws_vpc.default.id}""

  availability_zone               = ""${element(data.aws_availability_zones.vpc_az.names, count.index)}""
  cidr_block                      = ""${cidrsubnet(var.aws_conf[""cidr_block""], 4, length(data.aws_availability_zones.vpc_az.names) + count.index + 1)}""
  map_public_ip_on_launch         = false
  assign_ipv6_address_on_creation = false

  tags {
    Name             = ""${var.aws_conf[""domain""]} Private Subnet ${element(data.aws_availability_zones.vpc_az.names, count.index)}""
    Stack            = ""${var.aws_conf[""domain""]}""
    AvailabilityZone = ""${element(data.aws_availability_zones.vpc_az.names, count.index)}""
    Type             = ""private""
  }

  depends_on = [""aws_vpc.default""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_eip"" ""nat"" {
  count = ""${length(data.aws_availability_zones.vpc_az.names)}""
  vpc   = true

  depends_on = [""aws_vpc.default""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_nat_gateway"" ""nat-gw"" {
  count         = ""${length(data.aws_availability_zones.vpc_az.names)}""
  depends_on    = [""aws_internet_gateway.default""]
  allocation_id = ""${element(aws_eip.nat.*.id, count.index)}""
  subnet_id     = ""${element(aws_subnet.public.*.id, count.index)}""

  depends_on = [""aws_eip.nat""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_route_table"" ""private"" {
  count  = ""${length(data.aws_availability_zones.vpc_az.names)}""
  vpc_id = ""${aws_vpc.default.id}""

  route {
    cidr_block     = ""0.0.0.0/0""
    nat_gateway_id = ""${element(aws_nat_gateway.nat-gw.*.id, count.index)}""
  }

  route {
    ipv6_cidr_block        = ""::/0""
    egress_only_gateway_id = ""${aws_egress_only_internet_gateway.ipv6-gw.id}""
  }

  tags {
    Name  = ""${var.aws_conf[""domain""]} Private Routing Table ${element(data.aws_availability_zones.vpc_az.names, count.index)}""
    Stack = ""${var.aws_conf[""domain""]}""
  }

  depends_on = [""aws_nat_gateway.nat-gw""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}

resource ""aws_vpc_endpoint_route_table_association"" ""private_vpc_endpoint"" {
  count           = ""${length(data.aws_availability_zones.vpc_az.names)}""
  vpc_endpoint_id = ""${aws_vpc_endpoint.vpc_endpoint.id}""
  route_table_id  = ""${element(aws_route_table.private.*.id, count.index)}""
}

resource ""aws_route_table_association"" ""private"" {
  count          = ""${length(data.aws_availability_zones.vpc_az.names)}""
  subnet_id      = ""${element(aws_subnet.private.*.id, count.index)}""
  route_table_id = ""${element(aws_route_table.private.*.id, count.index)}""

  depends_on = [""aws_route_table.private""]

  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
  }
}


data ""null_data_source"" ""vpc_conf"" {
  inputs = {
    region             = ""${data.aws_region.region.name}""
    availability_zones = ""${data.aws_availability_zones.availability_zones.names}""
    id                 = ""${aws_vpc.default.id}""
    subnets_public     = ""${join("","", aws_subnet.public.*.id)}""
    subnets_private    = ""${join("","", aws_subnet.private.*.id)}""
    availability_zones = ""${join("","", data.aws_availability_zones.vpc_az.names)}""
    security_group     = ""${aws_security_group.base-sg.id}""
    profile            = ""${aws_iam_instance_profile.default.id}""
    role               = ""${aws_iam_role.default.id}""
    role_arn           = ""${aws_iam_role.default.arn}""
    zone_id            = ""${aws_route53_zone.root_zone.zone_id}""
    kms                = ""${aws_kms_key.kms_key.arn}""
    nat_public         = ""${join("","", aws_nat_gateway.nat-gw.*.public_ip)}""
    nat_private        = ""${join("","", aws_nat_gateway.nat-gw.*.private_ip)}""
    ami                = ""${data.aws_ami.ami.image_id}""
    s3_endpoint        = ""${join("","", aws_vpc_endpoint.vpc_endpoint.cidr_blocks)}""
  }
}

output ""vpc_conf"" {
  value = ""${map(
              ""region"", ""${data.aws_region.region.name}"",
              ""id"", ""${aws_vpc.default.id}"",
              ""subnets_public"", ""${list(aws_subnet.public.*.id)}"",
              ""subnets_private"", ""${list(aws_subnet.private.*.id)}"",
              ""availability_zones"", ""${list(data.aws_availability_zones.vpc_az.names)}"",
              ""security_group"", ""${aws_security_group.base-sg.id}"",
              ""profile"", ""${aws_iam_instance_profile.default.id}"",
              ""role"", ""${aws_iam_role.default.id}"",
              ""role_arn"", ""${aws_iam_role.default.arn}"",
              ""zone_id"", ""${aws_route53_zone.root_zone.zone_id}"",
              ""kms"", ""${aws_kms_key.kms_key.arn}"",
              ""nat_public"", ""${list(aws_nat_gateway.nat-gw.*.public_ip)}"",
              ""nat_private"", ""${list(aws_nat_gateway.nat-gw.*.private_ip)}"",
              ""ami"", ""${data.aws_ami.ami.image_id}"",
              ""s3_endpoint"", ""${join("","", aws_vpc_endpoint.vpc_endpoint.cidr_blocks)}""
            )}""
}


","{
  ""userQuery1"": ""The user wants to create a Virtual Private Cloud (VPC) in a specific AWS region. The VPC should have a unique CIDR block and should be tagged with a specific domain name. The VPC should also have DNS hostnames enabled and should be assigned a generated IPv6 CIDR block."",
  ""userQuery2"": ""The user wants to create an Internet Gateway and a VPN Gateway for the VPC. These gateways should be tagged with the same domain name as the VPC and should be created before the VPC is destroyed. The user also wants to prevent these resources from being destroyed."",
  ""userQuery3"": ""The user wants to create public and private subnets within the VPC. Each subnet should be in a different availability zone and should have a unique CIDR block. The public subnets should have public IP addresses mapped on launch and should be assigned IPv6 addresses on creation. The private subnets should not have"
54,GoogleCloudPlatform,sap-deployment-automation,terraform/modules/umig,"/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

locals {
  instances_by_zone = {
    for zone in var.zones : zone => [
      for instance in data.google_compute_instance.instances : instance.self_link if instance.zone == zone
    ]
  }
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

data ""google_compute_instance"" ""instances"" {
  count  = length(var.instances_self_links)

  self_link = var.instances_self_links[count.index]
}

resource ""google_compute_instance_group"" ""groups"" {
  for_each                = local.instances_by_zone

  instances               = each.value
  name                    = ""${var.name}-${each.key}""
  project                 = var.project_id
  zone                    = each.key

  dynamic ""named_port"" {
    for_each              = var.named_ports
    content {
      name                = named_port.value.name
      port                = named_port.value.port
    }
  }

  lifecycle {
    create_before_destroy = true
  }
}



/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""instances_self_links"" {
  type        = list(string)
  description = ""A list of instance self links.""
}

variable ""name"" {
  type        = string
  description = ""The base name of the instance groups.""
}

variable ""named_ports"" {
  type        = list(object({
    name      = string
    port      = string
  }))
  description = ""A list of named ports for the backend.""
  default     = []
}

variable ""project_id"" {
  type        = string
  description = ""The ID of the project in which the instance groups will be located.""
}

variable ""zones"" {
  type        = list(string)
  description = ""The zones in which instances are located.""
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""instance_groups"" {
  value = google_compute_instance_group.groups
}


","{
  ""userQuery1"": ""The user needs to create Google Compute instance groups in a specific project. The instance groups should be named based on a provided base name and the zone in which they are located."",
  ""userQuery2"": ""The user wants to populate these instance groups with existing Google Compute instances. The instances should be grouped by the zone they are located in. The user will provide a list of the self links of these instances."",
  ""userQuery3"": ""The user wants to assign named ports to these instance groups. The user will provide a list of named ports, each with a name and a port number. The instance groups should be created before they are destroyed in case of updates."",
  ""userQuery4"": ""The user wants to output the details of the created instance groups.""
}"
55,neil-power-hs,aws-lambda-sample,terraform,"provider ""aws"" {
  access_key = ""${var.access_key}""
  secret_key = ""${var.secret_key}""
  region = ""${var.region}""
}

variable ""access_key"" {}

variable ""secret_key"" {}

variable ""env"" {
  description = ""The environment name (staging, production)""
}

variable ""region"" {
  description = ""The AWS region for the infrastructure to be created in""
  default = ""us-east-1""
}

variable ""bucket"" {
  description = ""The S3 bucket to place the Lambda code into""
}

variable ""account"" {
  description = ""Your AWS Account number""
}

resource ""aws_lambda_function"" ""sample_lambda"" {

    filename = ""../build/distributions/sample-lambda-1.0.0.zip""
  // TODO STEP 8 Comment out the 'filename' line above and uncomment the 's3_bucket' and 's3_key' lines below
//   s3_bucket = ""${var.bucket}""
//   s3_key = ""sample_lambda/${var.env}/sample-lambda-1.0.0.zip""

  function_name = ""sampleLambda_${var.env}""
  description = ""A demonstration of AWS Lambda""
  runtime = ""java8""

  timeout = 10
  role = ""${aws_iam_role.sample_lambda_role.arn}""
  handler = ""com.hootsuite.example.lambda.SampleLambda::invokeFunction""
}

resource ""aws_iam_role"" ""sample_lambda_role"" {
    name = ""sample-lambda-role-${var.env}""
    assume_role_policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Statement"": [
    {
      ""Action"": ""sts:AssumeRole"",
      ""Principal"": {
        ""Service"": ""lambda.amazonaws.com""
      },
      ""Effect"": ""Allow"",
      ""Sid"": """"
    }
  ]
}
EOF
}

data ""template_file"" ""sample_lambda_policy"" {
  template = ""${file(""templates/iam_sample_lambda_policy.json.hcl.tpl"")}""
}

resource ""aws_iam_role_policy"" ""sample_lambda_policy"" {
  name = ""sample-lambda-policy-${var.env}""
  role = ""${aws_iam_role.sample_lambda_role.id}""
  policy = ""${data.template_file.sample_lambda_policy.rendered}""
}



resource ""aws_iam_user"" ""sample_lambda_jenkins"" {
  name = ""sample_lambda_jenkins_${var.env}""
}

resource ""aws_iam_access_key"" ""sample_lambda_jenkins"" {
  user = ""${aws_iam_user.sample_lambda_jenkins.name}""
}

resource ""aws_iam_user_policy"" ""sample_lambda_jenkins"" {
  name = ""sample-lambda-jenkins""
  user = ""${aws_iam_user.sample_lambda_jenkins.name}""
  policy = ""${data.template_file.jenkins_user_policy.rendered}""
}

data ""template_file"" ""jenkins_user_policy"" {
  template = ""${file(""templates/iam_jenkins_user_policy.json.hcl.tpl"")}""
  vars {
    env = ""${var.env}""
    bucket = ""${var.bucket}""
    region = ""${var.region}""
    account = ""${var.account}""
  }
}


resource ""aws_iam_user"" ""sample_lambda_invoker"" {
  name = ""sample_lambda_invoker_${var.env}""
}

resource ""aws_iam_access_key"" ""sample_lambda_invoker"" {
  user = ""${aws_iam_user.sample_lambda_invoker.name}""
}

resource ""aws_iam_user_policy"" ""sample_lambda_invoker"" {
  name = ""sample_lambda_invocation""
  user = ""${aws_iam_user.sample_lambda_invoker.name}""
  policy = ""${data.template_file.lambda_invoker_policy.rendered}""
}

data ""template_file"" ""lambda_invoker_policy"" {
  template = ""${file(""templates/iam_lambda_invoker_user_policy.json.hcl.tpl"")}""
  vars {
    env = ""${var.env}""
    region = ""${var.region}""
    account = ""${var.account}""
  }
}

//// TODO Uncomment to create API Gateway
//
//resource ""aws_api_gateway_rest_api"" ""sample_lambda_api"" {
//  name = ""sample_lambda_api_${var.env}""
//  description = ""A gateway to use a lambda function to convert Twitter Search string to JSON model and vice versa.""
//}
//
//resource ""aws_api_gateway_resource"" ""sample_lambda_resource"" {
//  rest_api_id = ""${aws_api_gateway_rest_api.sample_lambda_api.id}""
//  parent_id = ""${aws_api_gateway_rest_api.sample_lambda_api.root_resource_id}""
//  path_part = ""sample_lambda""
//}
//
//resource ""aws_api_gateway_method"" ""sample_lambda_post"" {
//  rest_api_id = ""${aws_api_gateway_rest_api.sample_lambda_api.id}""
//  resource_id = ""${aws_api_gateway_resource.sample_lambda_resource.id}""
//
//  http_method = ""POST""
//  authorization = ""NONE""
//}
//
//resource ""aws_api_gateway_method_response"" ""sample_lambda_post_200"" {
//  rest_api_id = ""${aws_api_gateway_rest_api.sample_lambda_api.id}""
//  resource_id = ""${aws_api_gateway_resource.sample_lambda_resource.id}""
//  http_method = ""${aws_api_gateway_method.sample_lambda_post.http_method}""
//  status_code = ""200""
//}
//
//resource ""aws_api_gateway_integration"" ""sample_lambda_integration"" {
//  rest_api_id = ""${aws_api_gateway_rest_api.sample_lambda_api.id}""
//  resource_id = ""${aws_api_gateway_resource.sample_lambda_resource.id}""
//  http_method = ""${aws_api_gateway_method.sample_lambda_post.http_method}""
//  integration_http_method = ""POST""
//
//  type = ""AWS""
//  uri = ""arn:aws:apigateway:${var.region}:lambda:path/2015-03-31/functions/${aws_lambda_function.sample_lambda.arn}/invocations""
//}
//
//resource ""aws_api_gateway_integration_response"" ""sample_lambda_integration_response"" {
//  rest_api_id = ""${aws_api_gateway_rest_api.sample_lambda_api.id}""
//  resource_id = ""${aws_api_gateway_resource.sample_lambda_resource.id}""
//  http_method = ""${aws_api_gateway_method.sample_lambda_post.http_method}""
//  status_code = ""${aws_api_gateway_method_response.sample_lambda_post_200.status_code}""
//
//}
//
//resource ""aws_api_gateway_model"" ""sample_lambda_model"" {
//  rest_api_id = ""${aws_api_gateway_rest_api.sample_lambda_api.id}""
//  name = ""sampleLambdaModel""
//  description = ""Schema for input to Query Builder Lambda Function""
//  content_type = ""application/json""
//
//  schema = <<EOF
//{
//  ""$schema"" : ""http://json-schema.org/draft-04/schema#"",
//  ""title"" : ""Request Schema"",
//  ""type"" : ""object""
//}
//EOF
//}
//
//# Basic deployment and permission for hitting $LATEST of Lambda function
//
//resource ""aws_api_gateway_deployment"" ""sample_lambda_deployment"" {
//  depends_on = [
//    ""aws_api_gateway_method.sample_lambda_post"",
//    ""aws_api_gateway_integration.sample_lambda_integration"",
//    ""aws_api_gateway_integration_response.sample_lambda_integration_response"",
//    ""aws_api_gateway_method_response.sample_lambda_post_200""
//  ]
//
//  rest_api_id = ""${aws_api_gateway_rest_api.sample_lambda_api.id}""
//  stage_name = ""${var.env}""
//
//  # forces a new deployment each run
//  stage_description = ""${timestamp()}""
//}
//
//resource ""aws_lambda_permission"" ""sample_lambda_permission"" {
//  statement_id = ""AllowExecutionFromAPIGateway""
//  action = ""lambda:InvokeFunction""
//  function_name = ""${aws_lambda_function.sample_lambda.arn}""
//  principal = ""apigateway.amazonaws.com""
//
//  source_arn = ""arn:aws:execute-api:${var.region}:${var.account}:${aws_api_gateway_rest_api.sample_lambda_api.id}/*/*/*""
//}


////TODO Uncomment to create stage for invoking SAMPLE_LAMBDA alias
//
//# SAMPLE_LAMBDA Alias
//
//resource ""aws_api_gateway_deployment"" ""sample_lambda_deployment_SAMPLE_ALIAS"" {
//  depends_on = [""aws_api_gateway_integration.sample_lambda_integration""]
//
//  rest_api_id = ""${aws_api_gateway_rest_api.sample_lambda_api.id}""
//  stage_name = ""SAMPLE_ALIAS""
//
//  variables {
//    ""lambdaAlias"" = ""SAMPLE_ALIAS""
//  }
//
//  # forces a new deployment each run
//  stage_description = ""${timestamp()}""
//}
//
//resource ""aws_lambda_permission"" ""sample_lambda_permission_SAMPLE_ALIAS"" {
//  statement_id = ""AllowExecutionFromAPIGateway""
//  action = ""lambda:InvokeFunction""
//  function_name = ""${aws_lambda_function.sample_lambda.arn}""
//  principal = ""apigateway.amazonaws.com""
//
//  source_arn = ""arn:aws:execute-api:${var.region}:${var.account}:${aws_api_gateway_rest_api.sample_lambda_api.id}/*/*/*""
//
//  qualifier = ""SAMPLE_ALIAS""
//}

","{
  ""userQuery1"": ""The user wants to create an AWS Lambda function named 'sampleLambda' with a specific environment name. The function is written in Java 8 and has a timeout of 10 seconds. The function's code is located in a zip file in the build/distributions directory. The user also plans to store the function's code in an S3 bucket in the future."",
  ""userQuery2"": ""The user wants to create an IAM role named 'sample-lambda-role' with a specific environment name. This role is assumed by the Lambda service and is attached to the Lambda function. The user also wants to attach a policy to this role, which is defined in a template file."",
  ""userQuery3"": ""The user wants to create two IAM users: 'sample_lambda_jenkins' and 'sample_lambda_invoker', each with a specific environment name. Each user has an access key and a policy attached to it. The policies are defined in template"
56,vcfvct,misc,cccg/infra-terraform,"variable ""amiId"" {
  description = ""ami to use""
  type = string
  default = ""ami-0758470213bdd23b1""
}

variable ""az"" {
  description = ""availability zone to use""
  type = string
  default = ""us-east-1c""
}



terraform {
  backend ""s3"" {
    bucket = ""tf-cccgadm5""
    key    = ""web.tfstate""
    region = ""us-east-1""
  }
}

provider ""aws"" {
  region = ""us-east-1""
}


resource ""aws_vpc"" ""main"" {
  cidr_block = ""172.30.0.0/16""
}

resource ""aws_subnet"" ""main"" {
  vpc_id                  = aws_vpc.main.id
  cidr_block              = ""172.30.0.0/24""
  map_public_ip_on_launch = true
  availability_zone       = var.az

  tags = {
    Name = ""Main""
  }
}

resource ""aws_security_group"" ""server"" {
  vpc_id      = aws_vpc.main.id
  name        = ""server""
  description = ""Security Group for server""

  tags = {
    Name           = ""server_SG""
    Terraform_Name = ""server_SG""
  }
}

resource ""aws_security_group_rule"" ""http"" {
  security_group_id = aws_security_group.server.id
  type              = ""ingress""
  cidr_blocks       = [""0.0.0.0/0""]
  protocol          = ""tcp""
  from_port         = 80
  to_port           = 80
}

resource ""aws_security_group_rule"" ""https"" {
  security_group_id = aws_security_group.server.id
  type              = ""ingress""
  cidr_blocks       = [""0.0.0.0/0""]
  protocol          = ""tcp""
  from_port         = 443
  to_port           = 443
}

resource ""aws_security_group_rule"" ""ssh"" {
  security_group_id = aws_security_group.server.id
  type              = ""ingress""
  cidr_blocks       = [""0.0.0.0/0""]
  protocol          = ""tcp""
  from_port         = 22
  to_port           = 22
}

resource ""aws_security_group_rule"" ""outbound"" {
  security_group_id = aws_security_group.server.id
  type              = ""egress""
  cidr_blocks       = [""0.0.0.0/0""]
  protocol          = ""-1""
  from_port         = 0
  to_port           = 0
}


resource ""aws_internet_gateway"" ""gw"" {
  vpc_id = aws_vpc.main.id

  tags = {
    Name = ""main""
  }
}

resource ""aws_route_table"" ""r"" {
  vpc_id = aws_vpc.main.id

  route {
    cidr_block = ""0.0.0.0/0""
    gateway_id = aws_internet_gateway.gw.id
  }

  tags = {
    Name = ""main""
  }
}

resource ""aws_route_table_association"" ""a"" {
  subnet_id      = aws_subnet.main.id
  route_table_id = aws_route_table.r.id
}

resource ""aws_key_pair"" ""han-pub"" {
  key_name   = ""han-pub""
  public_key = file(""han.pub"")
}

resource ""aws_instance"" ""web"" {
  ami                    = var.amiId
  instance_type          = ""t2.micro""
  vpc_security_group_ids = [aws_security_group.server.id]
  subnet_id              = aws_subnet.main.id
  key_name               = aws_key_pair.han-pub.key_name
  user_data              = file(""init.sh"")
  availability_zone      = var.az
  root_block_device {
    volume_type = ""gp2""
    volume_size = 30
  }
  tags = {
    Name = ""cccgWeb""
  }
}

resource ""aws_eip"" ""main"" {
  vpc = true
}

resource ""aws_eip_association"" ""eip_assoc"" {
  instance_id   = aws_instance.web.id
  allocation_id = aws_eip.main.id
}


","{
  ""userQuery1"": ""The user wants to create a Virtual Private Cloud (VPC) in the AWS region 'us-east-1' with a CIDR block of '172.30.0.0/16'."",
  ""userQuery2"": ""The user intends to create a subnet within the VPC with a CIDR block of '172.30.0.0/24'. This subnet should be able to automatically assign public IP addresses to instances and should be located in the availability zone specified by the user."",
  ""userQuery3"": ""The user wants to create a security group for a server within the VPC. This security group should allow inbound traffic on ports 80 (HTTP), 443 (HTTPS), and 22 (SSH) from any IP address. It should also allow all outbound traffic."",
  ""userQuery4"": ""The user intends to create an internet gateway and attach it to the VPC. They also want to create a"
57,oss-laboratries,OpenPIE,sfj/etc/sfj,"variable ""aws_access_key"" {}
variable ""aws_secret_key"" {}
variable ""private_key_name"" {}
variable ""network0"" {}
variable ""netmask0"" {}

resource ""aws_security_group"" ""SFJTAGS_acl"" {
  name = ""SFJTAGS_acl""
  description = ""Allow inbound traffic""
  vpc_id = ""${aws_vpc.SFJTAGS_vpc.id}""

  ingress {
      from_port = 22
      to_port = 22
      protocol = ""tcp""
      cidr_blocks = [""0.0.0.0/0""]
  }

  ingress {
      from_port = 80
      to_port = 80
      protocol = ""tcp""
      cidr_blocks = [""0.0.0.0/0""]
  }

  ingress {
      from_port = 443
      to_port = 443
      protocol = ""tcp""
      cidr_blocks = [""0.0.0.0/0""]
  }

  ingress {
      from_port = 3306
      to_port = 3306
      protocol = ""tcp""
      cidr_blocks = [""0.0.0.0/0""]
  }

  egress {
      from_port = 0
      to_port = 0
      protocol = ""-1""
      cidr_blocks = [""0.0.0.0/0""]
  }
}



resource ""aws_eip"" ""eipSFJPARA"" {
  depends_on = [""aws_internet_gateway.SFJTAGS_igw""]
  instance = ""${aws_instance.hostSFJPARA.id}""
  vpc = true
  provisioner ""remote-exec"" {
    inline = [
      ""sleep 10""
    ]
    connection {
      host = ""${self.public_ip}""
      user = ""${var.ansible_ssh_user}""
      private_key = ""${var.privatekeyfile}""
      timeout = ""${var.tftimeout}""
    }
  }
}



variable ""aws_access_key"" {}
variable ""aws_secret_key"" {}
variable ""reagion"" {}
variable ""private_key_name"" {}
variable ""network0"" {}
variable ""netmask0"" {}

provider ""aws"" {
  access_key= ""${var.aws_access_key}""
  secret_key= ""${var.aws_secret_key}""
  region = ""${var.reagion}""
}

resource ""aws_vpc"" ""SFJTAGS_vpc"" {
  cidr_block = ""${var.network0}/${var.netmask0}""
  tags {
    Name = ""SFJTAGS_vpc""
  }
}

resource ""aws_subnet"" ""SFJTAGS_subnet"" {
  vpc_id = ""${aws_vpc.SFJTAGS_vpc.id}""
  cidr_block = ""${var.network0}/${var.netmask0}""
  tags {
    Name = ""SFJTAGS_subnet""
  }
}

resource ""aws_internet_gateway"" ""SFJTAGS_igw"" {
  vpc_id = ""${aws_vpc.SFJTAGS_vpc.id}""
  tags {
    Name = ""SFJTAGS""
  }
}

resource ""aws_route"" ""SFJTAGS_igw_route"" {
  route_table_id = ""${aws_vpc.SFJTAGS_vpc.main_route_table_id}""
  destination_cidr_block = ""0.0.0.0/0""
  gateway_id = ""${aws_internet_gateway.SFJTAGS_igw.id}""
}

resource ""aws_route_table_association"" ""SFJTAGS_route_table"" {
  subnet_id = ""${aws_subnet.SFJTAGS_subnet.id}""
  route_table_id = ""${aws_vpc.SFJTAGS_vpc.main_route_table_id}""
}



","{
  ""userQuery1"": ""The user needs to create a Virtual Private Cloud (VPC) in AWS with a specific network and netmask. The VPC should be tagged with the name 'SFJTAGS_vpc'."",
  ""userQuery2"": ""Within the created VPC, the user intends to create a subnet with the same network and netmask as the VPC. This subnet should be tagged with the name 'SFJTAGS_subnet'."",
  ""userQuery3"": ""The user wants to set up an internet gateway for the VPC, tagged with the name 'SFJTAGS'. The user also wants to create a route that directs all traffic (0.0.0.0/0) to this internet gateway."",
  ""userQuery4"": ""The user intends to associate the main route table of the VPC with the created subnet."",
  ""userQuery5"": ""The user needs to create a security group for the VPC"
58,heimweh,terraform,configs/testdata/invalid-files,"data ""test"" ""foo"" {
  count = 2
  for_each = [""a""]
}


data ""test"" ""foo"" {
  lifecycle {}
}


data ""test"" ""foo"" {
  locals {}
}


data ""example"" ""example"" {
  lifecycle {
    # This block intentionally left blank
  }
}


data ""null_resource"" ""foo_${interpolations_invalid_here}"" {
}


resource ""null_resource"" ""foo_${interpolations_invalid_here}"" {
}


{
  ""terraform"": {}
}



module ""foo"" {
  source = ""./foo""
  # this block intentionally left (almost) blank
}

module ""bar"" {
  source = ""hashicorp/bar/aws""

  boom = """"
  yes  = true
}

module ""baz"" {
  source = ""git::https://example.com/""

  a = 1

  count = 12
  for_each = [""a"", ""b"", ""c""]

  depends_on = [
    module.bar,
  ]

  providers = {
    aws = aws.foo
  }
}


provider ""test"" {
  # These are okay
  alias   = ""foo""
  version = ""1.0.0""

  # Provider-specific arguments are also okay
  arbitrary = true

  # These are all reserved and should generate errors.
  count      = 3
  depends_on = [""foo.bar""]
  for_each   = [""a"", ""b""]
  source     = ""foo.example.com/baz/bar""
  lifecycle {}
  locals {}
}


provider ""template"" {
  version = 
}


resource ""test"" ""foo"" {
  count = 2
  for_each = [""a""]
}


resource ""example"" ""example"" {
  lifecycle {
    create_before_destroy = ""ABSOLUTELY NOT""
  }
}


resource ""test"" ""foo"" {
  locals {}
}


resource ""aws_instance"" ""web"" {
  lifecycle {
    ignore_changes = [""*"", ""foo""]
  }
}


foo = ""bar""


varyable ""whoops"" {
}


variable ""incorrectly_typed_default"" {
    type    = list(string)
    default = ""hello""
}


variable ""bad_type"" {
    type = notatype
}



terraform {
  experiments = [variable_validation]
}

variable ""validation"" {
  validation {
    condition     = var.validation != 4
    error_message = ""not four"" # ERROR: Invalid validation error message
  }
}



terraform {
  experiments = [variable_validation]
}

locals {
  foo = 1
}

variable ""validation"" {
  validation {
    condition     = local.foo == var.validation # ERROR: Invalid reference in variable validation
    error_message = ""Must be five.""
  }
}



terraform {
  experiments = [variable_validation]
}

variable ""validation"" {
  validation {
    condition     = true # ERROR: Invalid variable validation condition
    error_message = ""Must be true.""
  }
}


variable ""module_version"" { default = ""v1.0"" }

module ""foo"" {
  source  = ""./ff""
  version = var.module_version
}


","{
  ""userQuery1"": ""The user needs to create two instances of a 'test' data source with a single attribute 'a'."",
  ""userQuery2"": ""The user intends to use multiple modules, namely 'foo', 'bar', and 'baz', each with different sources and configurations. The 'baz' module depends on the 'bar' module and uses the 'aws.foo' provider."",
  ""userQuery3"": ""The user wants to set up a 'test' provider with an alias 'foo', version '1.0.0', and an arbitrary argument set to true. However, the user also attempts to use reserved arguments which should generate errors."",
  ""userQuery4"": ""The user intends to create resources of types 'test', 'example', and 'aws_instance' with different lifecycle configurations."",
  ""userQuery5"": ""The user wants to define variables with different types and default values, some of which are incorrectly typed or not a type"
59,opencredo,terrahelp,terrahelp/test-data/example-project/original,"# -------------------------------------------------
#      Example terraform file based on 0.12.x
# -------------------------------------------------
provider ""aws"" {
  access_key = var.pretend_aws_access_key
  secret_key = var.pretend_aws_secret_key
  region = ""us-east-1""
}

resource ""template_dir"" ""config"" {
  source_dir      = ""${path.module}/templates""
  destination_dir = ""${path.module}/renders""

  vars = {
      msg1 = var.tf_sensitive_key_1
      msg2 = var.tf_normal_key_1
      msg3 = var.tf_sensitive_key_3
      msg4 = var.tf_sensitive_key_4
      msg5 = var.tf_sensitive_list_vals[0]
      msg6 = var.tf_sensitive_flatmap_vals[""foo""]
      msg7 = var.tf_sensitive_flatmap_vals[""overlap""]
    }
}

output ""sensitive_key_1"" {
  value = var.tf_sensitive_key_1
}

output ""normal_val_2"" {
  value = var.tf_normal_key_2
}

# ----------------------------------------------------------------
# sensitive variables (should be passed in via tfvars)
# ----------------------------------------------------------------
variable ""pretend_aws_access_key"" {}
variable ""pretend_aws_secret_key"" {}
variable ""tf_sensitive_key_1""     {}
variable ""tf_sensitive_key_2""     {}
variable ""tf_sensitive_key_3""     {}
variable ""tf_sensitive_key_4""     {}
variable ""tf_sensitive_key_6""     {}

variable ""tf_sensitive_list_vals""       { type = ""list"" }
variable ""tf_sensitive_flatmap_vals""    { type = ""map""  }

# ----------------------------------------------------------------
# Non sensitive variable defaults
# ----------------------------------------------------------------
variable ""tf_normal_key_1""     { default = ""normal value 1"" }
variable ""tf_normal_key_2""     { default = ""normal value 2"" }


","{
  ""userQuery1"": ""The user needs to interact with AWS services, specifically in the 'us-east-1' region, using a specific access key and secret key."",
  ""userQuery2"": ""The user intends to create a directory of templates, with certain variables (both sensitive and non-sensitive) to be replaced in the templates. The rendered templates are to be stored in a specific directory."",
  ""userQuery3"": ""The user wants to output the values of certain variables, specifically 'tf_sensitive_key_1' and 'tf_normal_key_2'."",
  ""userQuery4"": ""The user has a set of sensitive variables that need to be passed in via tfvars. These include AWS access keys, several sensitive keys, a list of sensitive values, and a map of sensitive values."",
  ""userQuery5"": ""The user has a set of non-sensitive variables with default values, specifically 'tf_normal_key_1' and 'tf_normal_key_"
60,GoogleCloudPlatform,cloud-foundation-fabric,modules/cloud-identity-group,"# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

terraform {
  required_version = "">= 1.5.1""
  required_providers {
    google = {
      source  = ""hashicorp/google""
      version = "">= 5.10.0, < 6.0.0"" # tftest
    }
    google-beta = {
      source  = ""hashicorp/google-beta""
      version = "">= 5.10.0, < 6.0.0"" # tftest
    }
  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""customer_id"" {
  description = ""Directory customer ID in the form customers/C0xxxxxxx.""
  type        = string
  validation {
    condition     = can(regex(""^customers/C0[a-z0-9]{7}$"", var.customer_id))
    error_message = ""Customer ID must be in the form customers/C0xxxxxxx.""
  }
}

variable ""description"" {
  description = ""Group description.""
  type        = string
  default     = null
}

variable ""display_name"" {
  description = ""Group display name.""
  type        = string
}

variable ""managers"" {
  description = ""List of group managers.""
  type        = list(string)
  default     = []
}

variable ""members"" {
  description = ""List of group members.""
  type        = list(string)
  default     = []
}

variable ""name"" {
  description = ""Group ID (usually an email).""
  type        = string
}

# variable ""owners"" {
#   description = ""List of group owners.""
#   type        = list(string)
#   default     = []
# }


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

resource ""google_cloud_identity_group"" ""group"" {
  display_name = var.display_name
  parent       = var.customer_id
  description  = var.description

  group_key {
    id = var.name
  }

  labels = {
    ""cloudidentity.googleapis.com/groups.discussion_forum"" = """"
  }
}

# resource ""google_cloud_identity_group_membership"" ""owners"" {
#   group    = google_cloud_identity_group.group.id
#   for_each = toset(var.owners)
#   preferred_member_key { id = each.key }
#   roles { name = ""OWNER"" }
#   roles { name = ""MEMBER"" }
#   roles { name = ""MANAGER"" }
# }

resource ""google_cloud_identity_group_membership"" ""managers"" {
  group    = google_cloud_identity_group.group.id
  for_each = toset(var.managers)
  preferred_member_key { id = each.key }
  roles { name = ""MEMBER"" }
  roles { name = ""MANAGER"" }
}

resource ""google_cloud_identity_group_membership"" ""members"" {
  group    = google_cloud_identity_group.group.id
  for_each = toset(var.members)
  preferred_member_key { id = each.key }
  roles { name = ""MEMBER"" }
  depends_on = [google_cloud_identity_group_membership.managers]
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""id"" {
  description = ""Fully qualified group id.""
  value       = google_cloud_identity_group.group.id
}

output ""name"" {
  description = ""Group name.""
  value       = var.name
  depends_on = [
    google_cloud_identity_group.group
  ]
}


","{
  ""userQuery1"": ""The user wants to specify the version of Terraform and the providers 'google' and 'google-beta' that are required for the code to run correctly."",
  ""userQuery2"": ""The user wants to create a Google Cloud Identity Group with specific attributes such as a display name, a parent customer ID, a description, and a group ID. The user also wants to assign labels to the group."",
  ""userQuery3"": ""The user wants to add members and managers to the created group. The user also wants to specify the roles of these members and managers in the group."",
  ""userQuery4"": ""The user wants to output the fully qualified group id and the group name after the group has been created.""
}"
61,oracle,terraform-provider-baremetal,examples/email,"// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

/*
 * This example file shows how to configure the oci provider to target a single region.
 */

// These variables would commonly be defined as environment variables or sourced in a .env file
variable ""tenancy_ocid"" {
}

variable ""user_ocid"" {
}

variable ""fingerprint"" {
}

variable ""private_key_path"" {
}

variable ""compartment_ocid"" {
}

variable ""region"" {
  default = ""us-ashburn-1""
}

provider ""oci"" {
  region           = var.region
  tenancy_ocid     = var.tenancy_ocid
  user_ocid        = var.user_ocid
  fingerprint      = var.fingerprint
  private_key_path = var.private_key_path
}



resource ""random_id"" ""random_email_domain"" {
  byte_length = 8
}

variable ""email_domain_description"" {
  default = ""Test Email Domain""
}

resource ""oci_email_email_domain"" ""test_email_domain"" {

	#Required
	compartment_id = var.compartment_ocid
	name = ""${random_id.random_email_domain.id}.email.${var.region}.dummydomain.com""

	#Optional
	description = var.email_domain_description
	freeform_tags = {""Department""= ""Finance""}

  depends_on = [random_id.random_email_domain]
}


// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

// Configure a DNS that has the TXT record to setup the SPF for the email
resource ""oci_dns_zone"" ""zone1"" {
  compartment_id = var.tenancy_ocid
  name           = ""${data.oci_identity_compartment.compartment.name}2-tf-example-primary.oci-email-dns""
  zone_type      = ""PRIMARY""
}

resource ""oci_dns_rrset"" ""record-txt"" {
    #Required
    domain = oci_dns_zone.zone1.name
    rtype = ""TXT""
    zone_name_or_id = oci_dns_zone.zone1.name
    items {
        #Required
        domain = oci_dns_zone.zone1.name
        rdata = ""v=spf1 include:spf.oracleemaildelivery.com -all""
        rtype = ""TXT""
        ttl = 86400
    }
}

data ""oci_dns_rrset"" ""rs"" {
    #Required
    domain = oci_dns_zone.zone1.name
    rtype = ""TXT""
    zone_name_or_id = oci_dns_zone.zone1.name
}

data ""oci_identity_compartment"" ""compartment"" {
  id = var.tenancy_ocid
}

output ""dns_records"" {
  value = data.oci_dns_rrset.rs
}


variable ""dkim_name"" {
  default = ""test-selector-1""
}

variable ""dkim_description"" {
  default = ""Test DKIM""
}

resource ""oci_email_dkim"" ""testdkim"" {
	#Required
	email_domain_id = oci_email_email_domain.test_email_domain.id
	#Optional
	description = var.dkim_description
	name = var.dkim_name
  depends_on = [oci_email_email_domain.test_email_domain]
}


// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

variable ""sender_email_address"" {
  default = ""johnsmithtester@example.com""
}

variable ""sender_state"" {
  default = ""ACTIVE""
}

resource ""oci_email_sender"" ""test_sender"" {
  #Required
  compartment_id = var.compartment_ocid
  email_address  = var.sender_email_address

  timeouts {
    create = ""10m""
  }
}

data ""oci_email_senders"" ""test_senders"" {
  #Required
  compartment_id = var.compartment_ocid

  #Optional
  email_address = var.sender_email_address
  state         = var.sender_state

  filter {
    name   = ""id""
    values = [oci_email_sender.test_sender.id]
  }
}

output ""emailSenders"" {
  value = data.oci_email_senders.test_senders.senders
}


// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

variable ""suppression_email_address"" {
  default = ""johnsmithtester@example.com""
}

variable ""suppression_time_created_greater_than_or_equal_to"" {
  default = ""2018-01-01T00:00:00.000Z""
}

variable ""suppression_time_created_less_than"" {
  default = ""2038-01-01T00:00:00.000Z""
}

resource ""oci_email_suppression"" ""test_suppression"" {
  #Required
  compartment_id = var.tenancy_ocid
  email_address  = var.suppression_email_address
}

data ""oci_email_suppressions"" ""test_suppressions"" {
  #Required
  compartment_id = var.tenancy_ocid

  #Optional
  email_address                         = var.suppression_email_address
  time_created_greater_than_or_equal_to = var.suppression_time_created_greater_than_or_equal_to
  time_created_less_than                = var.suppression_time_created_less_than

  filter {
    name   = ""id""
    values = [oci_email_suppression.test_suppression.id]
  }
}

output ""emailSuppressions"" {
  value = data.oci_email_suppressions.test_suppressions.suppressions
}


","{
  ""userQuery1"": ""The user wants to set up an Oracle Cloud Infrastructure (OCI) provider to target a specific region. They need to provide their tenancy OCID, user OCID, fingerprint, private key path, and compartment OCID. The default region is set to 'us-ashburn-1'."",
  ""userQuery2"": ""The user intends to create an email domain in the OCI. They want to generate a random domain name, provide a description, and tag it with the department name 'Finance'. They also want to set up a DNS with a TXT record for SPF setup for the email, and retrieve the DNS records."",
  ""userQuery3"": ""The user wants to create a sender email address and a suppression email address in the OCI. They want to filter and retrieve the sender and suppression email addresses based on certain conditions. They also want to create a DKIM for the email domain.""
}"
62,Originate,exosphere,terraform/aws/alb-security-groups,"/* Variables */

variable ""name"" {
  description = ""Name of application""
}

variable ""env"" {
  description = ""Environment tag, e.g prod""
}

variable ""vpc_cidr"" {
  description = ""CIDR block of the VPC""
}

variable ""vpc_id"" {
  description = ""ID of the VPC""
}

/* Output */

output ""internal_id"" {
  description = ""ID of internal ALB security group""
  value       = ""${aws_security_group.internal_alb.id}""
}

output ""external_id"" {
  description = ""ID of external ALB security group""
  value       = ""${aws_security_group.external_alb.id}""
}


resource ""aws_security_group"" ""internal_alb"" {
  name        = ""${var.name}-internal-alb""
  vpc_id      = ""${var.vpc_id}""
  description = ""Allows internal VPC traffic through the ALB""

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = ""tcp""
    cidr_blocks = [""${var.vpc_cidr}""]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }

  lifecycle {
    create_before_destroy = true
  }

  tags {
    Name        = ""${var.name}-internal-alb""
    Environment = ""${var.env}""
  }
}

resource ""aws_security_group"" ""external_alb"" {
  name        = ""${var.name}-external-alb""
  vpc_id      = ""${var.vpc_id}""
  description = ""Allows all external traffic through the ALB""

  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = -1
    cidr_blocks = [""0.0.0.0/0""]
  }

  lifecycle {
    create_before_destroy = true
  }

  tags {
    Name        = ""${var.name}-external-alb""
    Environment = ""${var.env}""
  }
}


","{
  ""userQuery1"": ""What is the name of the application that the security groups are being created for?"",
  ""userQuery2"": ""What is the environment tag (e.g., prod, dev, test) for the application?"",
  ""userQuery3"": ""What is the CIDR block of the VPC where the security groups will be created?"",
  ""userQuery4"": ""What is the ID of the VPC where the security groups will be created?"",
  ""userQuery5"": ""What is the ID of the internal Application Load Balancer (ALB) security group that allows internal VPC traffic?"",
  ""userQuery6"": ""What is the ID of the external Application Load Balancer (ALB) security group that allows all external traffic?"",
  ""userQuery7"": ""What are the ingress and egress rules for the internal and external ALB security groups?""
}"
63,zhadow,concourse-creator,terraform,"variable ""aws_region"" {
    type = ""string""
    default =  ""eu-west-1""
}
variable ""boshers"" {
  type = ""list""
}
variable ""ci_hostname"" {
type = ""string""
}
variable ""ci_dns_zone_id"" {
type = ""string""
}
variable ""ssl_cert_arn"" {
type = ""string""
}
variable ""aws_access_key"" {
  type = ""string""
}
variable ""aws_secret_key"" {
  type = ""string""
}


# Create a Concourse security group
resource ""aws_security_group"" ""concourse-sg"" {
  name        = ""concourse-sg""
  description = ""Concourse security group""
  vpc_id      = ""${aws_vpc.default.id}""
  tags {
  Name = ""concourse-sg""
  component = ""concourse""
  }

  # outbound internet access
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }

  # inbound connections from ELB
  ingress {
    from_port   = 8080
    to_port     = 8080
    protocol    = ""tcp""
    security_groups = [""${aws_security_group.elb-sg.id}""]
  }

  ingress {
    from_port   = 2222
    to_port     = 2222
    protocol    = ""tcp""
    security_groups = [""${aws_security_group.elb-sg.id}""]
  }
}

# Create an ELB security group
resource ""aws_security_group"" ""elb-sg"" {
  name        = ""elb-sg""
  description = ""ELB security group""
  vpc_id      = ""${aws_vpc.default.id}""
  tags {
  Name = ""elb-sg""
  component = ""concourse""
  }

  # outbound internet access
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }

  # inbound https
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }

  # inbound https
  ingress {
    from_port   = 2222
    to_port     = 2222
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }

}

# Create a new load balancer
resource ""aws_elb"" ""concourse"" {
  name = ""concourse-elb""
  subnets = [""${aws_subnet.ops_services.id}""]
  security_groups = [""${aws_security_group.elb-sg.id}""]

  listener {
    instance_port = 8080
    instance_protocol = ""http""
    lb_port = 80
    lb_protocol = ""http""
  }

  listener {
    instance_port = 8080
    instance_protocol = ""tcp""
    lb_port = 443
    lb_protocol = ""ssl""
    ssl_certificate_id = ""${var.ssl_cert_arn}""
}

  listener {
    instance_port = 2222
    instance_protocol = ""tcp""
    lb_port = 2222
    lb_protocol = ""tcp""
  }

  tags {
  component = ""concourse""
  }
}


# Specify the provider and access details
provider ""aws"" {
  region = ""${var.aws_region}""
  access_key = ""${var.aws_access_key}""
  secret_key = ""${var.aws_secret_key}""
}

# Create a VPC to launch our instances into
resource ""aws_vpc"" ""default"" {
  cidr_block = ""10.0.0.0/16""

    tags {
    Name = ""bosh-default""
    component = ""bosh-director""
  }
}

# Create an internet gateway to give our subnet access to the outside world
resource ""aws_internet_gateway"" ""default"" {
  vpc_id = ""${aws_vpc.default.id}""
  tags {
  Name = ""bosh-default""
  component = ""bosh-director""
  }
}

# Grant the VPC internet access on its main route table
resource ""aws_route"" ""internet_access"" {
  route_table_id         = ""${aws_vpc.default.main_route_table_id}""
  destination_cidr_block = ""0.0.0.0/0""
  gateway_id             = ""${aws_internet_gateway.default.id}""
}

# Create a subnet to launch our instances into
resource ""aws_subnet"" ""default"" {
  vpc_id                  = ""${aws_vpc.default.id}""
  cidr_block              = ""10.0.0.0/24""
  availability_zone = ""eu-west-1a""
  depends_on = [""aws_internet_gateway.default""]
  map_public_ip_on_launch = true
  tags {
  Name = ""bosh-default""
  component = ""bosh-director""
  }
}

# Create an ops_services subnet
resource ""aws_subnet"" ""ops_services"" {
  vpc_id                  = ""${aws_vpc.default.id}""
  cidr_block              = ""10.0.10.0/24""
  availability_zone = ""eu-west-1a""
  depends_on = [""aws_internet_gateway.default""]
  map_public_ip_on_launch = true
  tags {
  Name = ""ops_services""
  component = ""ops_services""
  }
}

# Create an EIP for our Director
resource ""aws_eip"" ""boshdirector"" {
    vpc = true
}

# The default security group
resource ""aws_security_group"" ""boshdefault"" {
  name        = ""boshdefault""
  description = ""Default BOSH security group""
  vpc_id      = ""${aws_vpc.default.id}""
  tags {
  Name = ""bosh-default""
  component = ""bosh-director""
  }

	# inbound access rules
  ingress {
    from_port   = 6868
    to_port     = 6868
    protocol    = ""tcp""
    cidr_blocks = [""${var.boshers}""]
  }

	ingress {
		from_port   = 25555
		to_port     = 25555
		protocol    = ""tcp""
    cidr_blocks = [""${var.boshers}""]
	}

	ingress {
		from_port   = 22
		to_port     = 22
		protocol    = ""tcp""
    cidr_blocks = [""${var.boshers}""]
	}

	ingress {
		from_port   = 0
		to_port     = 65535
		protocol    = ""tcp""
		self        = true
	}

	ingress {
		from_port   = 0
		to_port     = 65535
		protocol    = ""udp""
		self        = true
	}

	# outbound internet access
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}


resource ""aws_route53_record"" ""concourse"" {
   zone_id = ""${var.ci_dns_zone_id}""
   name = ""${var.ci_hostname}""
   type = ""CNAME""
   ttl = ""300""
   records = [""${aws_elb.concourse.dns_name}""]
}


resource ""aws_s3_bucket"" ""setup-files"" {
    bucket = ""concourse-setup-files""
    acl = ""private""
    region = ""eu-west-1""
}


output ""security_group_id"" {
    value = ""${aws_security_group.boshdefault.id}""
}

output ""default_subnet_id"" {
    value = ""${aws_subnet.default.id}""
}

output ""ops_services_subnet_id"" {
    value = ""${aws_subnet.ops_services.id}""
}

output ""eip"" {
    value = ""${aws_eip.boshdirector.public_ip}""
}


","{
""userQuery1"": ""The user needs to create a Virtual Private Cloud (VPC) in the AWS region 'eu-west-1' with a CIDR block of '10.0.0.0/16'. This VPC should have an internet gateway for outside world access and two subnets, one with a CIDR block of '10.0.0.0/24' and the other with a CIDR block of '10.0.10.0/24', both in the availability zone 'eu-west-1a'."",
""userQuery2"": ""The user intends to set up a Concourse CI/CD system. For this, they need to create two security groups, one for the Concourse application and another for the Elastic Load Balancer (ELB). The Concourse security group should allow inbound connections from the ELB on ports 8080 and 2222. The ELB security group should allow inbound HTTPS and TCP connections on ports "
64,iliyahoo,terraform-up-and-running-code,my_code/modules/services/webserver-cluster,"resource ""aws_launch_configuration"" ""example"" {
    instance_type     = ""${var.instance_type}""
    key_name          = ""${var.key_name}""
    image_id          = ""${var.image_id}""
    security_groups   = [""${data.terraform_remote_state.vpc.instance_sg}""]
    user_data         = ""${data.template_file.user_data.rendered}""
    lifecycle {
        create_before_destroy = true
    }
}


resource ""aws_security_group_rule"" ""allow_http_inbound"" {
    type = ""ingress""
    security_group_id = ""${data.terraform_remote_state.vpc.instance_sg}""
    from_port   = ""${var.server_port}""
    to_port     = ""${var.server_port}""
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
}


resource ""aws_autoscaling_group"" ""example"" {
    launch_configuration = ""${aws_launch_configuration.example.id}""
    vpc_zone_identifier  = [""${data.terraform_remote_state.vpc.my_subnets}""]
    load_balancers       = [""${aws_elb.example.name}""]
    health_check_type    = ""ELB""
    min_size = ""${var.min_size}""
    max_size = ""${var.max_size}""
    name     = ""terraform-${var.prefix}""
    tag {
        key                 = ""Name""
        value               = ""terraform-${var.prefix}""
        propagate_at_launch = true
    }
}


resource ""aws_elb"" ""example"" {
    name            = ""terraform-asg-${var.prefix}""
    subnets         = [""${data.terraform_remote_state.vpc.my_subnets}""]
    security_groups = [""${aws_security_group.elb.id}""]
    listener {
        lb_port           = 80
        lb_protocol       = ""http""
        instance_port     = ""${var.server_port}""
        instance_protocol = ""http""
    }
    health_check {
        healthy_threshold   = 2
        unhealthy_threshold = 2
        timeout             = 3
        interval            = 30
        target              = ""HTTP:${var.server_port}/""
    }
    tags {
        Name = ""terraform-${var.prefix}""
    }
}


resource ""aws_security_group"" ""elb"" {
    name    = ""terraform-${var.prefix}-elb""
    vpc_id  = ""${data.terraform_remote_state.vpc.my_vpc}""
    ingress {
        from_port   = 80
        to_port     = 80
        protocol    = ""tcp""
        cidr_blocks = [""0.0.0.0/0""]
    }
    egress {
        from_port   = 0
        to_port     = 0
        protocol    = ""-1""
        cidr_blocks = [""0.0.0.0/0""]
    }
    tags {
        Name = ""terraform-${var.prefix}-elb""
    }
}


data ""terraform_remote_state"" ""vpc"" {
    backend = ""s3""
    config {
        bucket  = ""terraform-up-and-running-state-iliyahoo""
        key     = ""my_code/${var.prefix}/vpc/terraform.tfstate""
        region  = ""${var.my_region}""
        profile = ""${var.aws_profile}""
    }
}


data ""terraform_remote_state"" ""db"" {
    backend = ""s3""
    config {
        bucket  = ""terraform-up-and-running-state-iliyahoo""
        key     = ""my_code/${var.prefix}/data-storage/mysql/terraform.tfstate""
        region  = ""${var.my_region}""
        profile = ""${var.aws_profile}""
    }
}


data ""template_file"" ""user_data"" {
    template = ""${file(""${path.module}/user-data.sh"")}""
    vars {
        server_port = ""${var.server_port}""
        db_address  = ""${data.terraform_remote_state.db.address}""
        db_port     = ""${data.terraform_remote_state.db.port}""
    }
}


variable ""aws_profile"" {
    type        = ""string""
    description = ""AWS credentials.""
}


variable ""server_port"" {
    type        = ""string""
    description = ""The port the server will use for HTTP requests""
}


variable ""my_region"" {
    type    = ""string""
    description = ""ec2 region""
}


variable ""instance_type"" {
    type        = ""string""
    description = ""ec2 instance type""
}


variable ""key_name"" {
    type        = ""string""
    description = ""SSH key""
}


variable ""image_id"" {
    type        = ""string""
    description = ""desired AMI""
}


variable ""prefix"" {
    type        = ""string""
    description = ""environment prefix""
}


variable ""min_size"" {
    type        = ""string""
    description = ""ASG min_size""
}


variable ""max_size"" {
    type        = ""string""
    description = ""ASG max_size""
}


output ""elb_dns"" {
    value = ""${aws_elb.example.dns_name}""
}


output ""asg_name"" {
    value = ""${aws_autoscaling_group.example.name}""
}


","{
    ""userQuery1"": ""The user wants to create an AWS launch configuration with a specific instance type, key name, image ID, and security group. The user also wants to ensure that a new resource is created before the old one is destroyed."",
    ""userQuery2"": ""The user wants to create an AWS security group rule that allows inbound HTTP traffic from any IP address to a specific server port."",
    ""userQuery3"": ""The user wants to create an AWS auto-scaling group that uses the previously created launch configuration, is associated with specific subnets and a load balancer, and has a specific minimum and maximum size."",
    ""userQuery4"": ""The user wants to create an AWS Elastic Load Balancer (ELB) with a specific name, associated with specific subnets and a security group, and configured to listen for HTTP traffic on port 80 and forward it to the server port."",
    ""userQuery5"": ""The user wants to create an"
65,terraform-google-modules,terraform-google-github-actions-runners,test/fixtures/gh-runner-mig-container-vm,"/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ""example_mig_runner"" {
  source = ""../../../examples/gh-runner-mig-container-vm-simple""

  project_id = var.project_id_mig_container
  image      = ""gcr.io/google-samples/hello-app:1.0""
  repo_url   = ""example""
  repo_name  = ""example""
  repo_owner = ""example""
  gh_token   = ""example""
}


/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""project_id_mig_container"" {
  type        = string
  description = ""The GCP project to use for integration tests""
}


/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""project_id"" {
  value = var.project_id_mig_container
}

output ""mig_instance_group"" {
  description = ""The instance group url of the created MIG""
  value       = module.example_mig_runner.mig_instance_group
}

output ""mig_name"" {
  description = ""The name of the MIG""
  value       = module.example_mig_runner.mig_name
}

output ""service_account"" {
  description = ""Service account email for GCE""
  value       = module.example_mig_runner.service_account
}

output ""mig_instance_template"" {
  description = ""The name of the MIG Instance Template""
  value       = module.example_mig_runner.mig_instance_template
}


","{
  ""userQuery1"": ""The user wants to create a Managed Instance Group (MIG) on Google Cloud Platform (GCP) using a specific project ID. The MIG will use a container image from Google Container Registry (GCR) named 'gcr.io/google-samples/hello-app:1.0'."",
  ""userQuery2"": ""The user wants to connect the MIG to a GitHub repository. The user provides the repository URL, name, owner, and a GitHub token for authentication."",
  ""userQuery3"": ""The user wants to output several details about the created MIG, including the project ID, the instance group URL, the name of the MIG, the service account email for Google Compute Engine (GCE), and the name of the MIG Instance Template.""
}"
66,AlanHohn,otto,builtin/foundation/consul/data/aws-vpc-public-private/deploy,"#--------------------------------------------------------------------
# Access Info
#--------------------------------------------------------------------

variable ""aws_access_key"" {
    description = ""Access key for AWS""
}

variable ""aws_secret_key"" {
    description = ""Secret key for AWS""
}

variable ""region"" {
    description = ""Region where we will operate.""
}

#--------------------------------------------------------------
# General settings
#--------------------------------------------------------------

variable ""ami"" {
    description = ""AMI to launch with Consul""
    default = ""ami-7f6a1f1a""
}

variable ""bastion_host"" {
    description = ""SSH bastion host""
}

variable ""bastion_user"" {
    description = ""SSH bastion user""
}

variable ""key_name"" {
    description = ""SSH key name""
}

variable ""subnet-private"" {
    description = ""Private subnet""
}

variable ""vpc_id"" {
    description = ""VPC ID""
}


provider ""aws"" {
    access_key = ""${var.aws_access_key}""
    secret_key = ""${var.aws_secret_key}""
    region = ""${var.region}""
}

module ""consul-1"" {
    source = ""./module-aws""

    index = ""1""
    private-ip = ""10.0.1.8""
    ami = ""${var.ami}""
    key-name = ""${var.key_name}""
    subnet-id = ""${var.subnet-private}""
    vpc-id = ""${var.vpc_id}""
    join_addr = ""10.0.1.6""
    bastion_host = ""${var.bastion_host}""
    bastion_user = ""${var.bastion_user}""
}

module ""consul-2"" {
    source = ""./module-aws""

    index = ""2""
    private-ip = ""10.0.1.7""
    ami = ""${var.ami}""
    key-name = ""${var.key_name}""
    subnet-id = ""${var.subnet-private}""
    vpc-id = ""${var.vpc_id}""
    join_addr = ""10.0.1.6""
    bastion_host = ""${var.bastion_host}""
    bastion_user = ""${var.bastion_user}""
}

module ""consul-3"" {
    source = ""./module-aws""

    index = ""3""
    private-ip = ""10.0.1.6""
    ami = ""${var.ami}""
    key-name = ""${var.key_name}""
    subnet-id = ""${var.subnet-private}""
    vpc-id = ""${var.vpc_id}""
    join_addr = ""10.0.1.6""
    bastion_host = ""${var.bastion_host}""
    bastion_user = ""${var.bastion_user}""
}

output ""consul_address"" {
    value = ""${module.consul-3.address}""
}


","{
    ""userQuery1"": ""The user needs to access AWS services, for which they need to provide their AWS access key, secret key, and the region in which they will operate."",
    ""userQuery2"": ""The user intends to launch an Amazon Machine Image (AMI) with Consul, for which they need to specify the AMI ID. They also need to provide details about the SSH bastion host and user, the SSH key name, the private subnet, and the VPC ID."",
    ""userQuery3"": ""The user plans to create three Consul modules on AWS, each with a unique index and private IP. For each module, they need to specify the AMI ID, SSH key name, subnet ID, VPC ID, join address, bastion host, and bastion user. They also want to output the address of the third Consul module.""
}"
67,bashtoni,terraform,examples/alicloud-ecs-vpc-cluster,"variable ""ecs_password"" {
  default = ""Test12345""
}

variable ""control_count"" {
  default = ""3""
}
variable ""control_count_format"" {
  default = ""%02d""
}
variable ""control_ecs_type"" {
  default = ""ecs.n1.medium""
}
variable ""control_disk_size"" {
  default = ""100""
}

variable ""edge_count"" {
  default = ""2""
}
variable ""edge_count_format"" {
  default = ""%02d""
}
variable ""edge_ecs_type"" {
  default = ""ecs.n1.small""
}

variable ""worker_count"" {
  default = ""1""
}
variable ""worker_count_format"" {
  default = ""%03d""
}
variable ""worker_ecs_type"" {
  default = ""ecs.n1.small""
}

variable ""short_name"" {
  default = ""ali""
}
variable ""ssh_username"" {
  default = ""root""
}

variable ""region"" {
  default = ""cn-beijing""
}

variable ""availability_zones"" {
  default = ""cn-beijing-c""
}

variable ""datacenter"" {
  default = ""beijing""
}


module ""vpc"" {
  availability_zones = ""${var.availability_zones}""
  source = ""../alicloud-vpc""
  short_name = ""${var.short_name}""
  region = ""${var.region}""
}

module ""security-groups"" {
  source = ""../alicloud-vpc-cluster-sg""
  short_name = ""${var.short_name}""
  vpc_id = ""${module.vpc.vpc_id}""
}

module ""control-nodes"" {
  source = ""../alicloud-ecs-vpc""
  count = ""${var.control_count}""
  role = ""control""
  datacenter = ""${var.datacenter}""
  ecs_type = ""${var.control_ecs_type}""
  disk_size = ""${var.control_disk_size}""
  ssh_username = ""${var.ssh_username}""
  short_name = ""${var.short_name}""
  availability_zones = ""${module.vpc.availability_zones}""
  security_groups = [""${module.security-groups.control_security_group}""]
  vswitch_id = ""${module.vpc.vswitch_ids}""
}

module ""edge-nodes"" {
  source = ""../alicloud-ecs-vpc""
  count = ""${var.edge_count}""
  role = ""edge""
  datacenter = ""${var.datacenter}""
  ecs_type = ""${var.edge_ecs_type}""
  ssh_username = ""${var.ssh_username}""
  short_name = ""${var.short_name}""
  availability_zones = ""${module.vpc.availability_zones}""
  security_groups = [""${module.security-groups.worker_security_group}""]
  vswitch_id = ""${module.vpc.vswitch_ids}""
}

module ""worker-nodes"" {
  source = ""../alicloud-ecs-vpc""
  count = ""${var.worker_count}""
  role = ""worker""
  datacenter = ""${var.datacenter}""
  ecs_type = ""${var.worker_ecs_type}""
  ssh_username = ""${var.ssh_username}""
  short_name = ""${var.short_name}""
  availability_zones = ""${module.vpc.availability_zones}""
  security_groups = [""${module.security-groups.worker_security_group}""]
  vswitch_id = ""${module.vpc.vswitch_ids}""
}

","{
  ""userQuery1"": ""The user needs to create a Virtual Private Cloud (VPC) in the 'cn-beijing' region of Alibaba Cloud. The VPC should be available in the 'cn-beijing-c' availability zone. The short name for the VPC should be 'ali'."",
  ""userQuery2"": ""The user intends to create three types of nodes: control, edge, and worker. The control nodes should be of type 'ecs.n1.medium' and have a disk size of 100. The edge and worker nodes should be of type 'ecs.n1.small'. The number of control nodes should be 3, edge nodes should be 2, and worker nodes should be 1. All nodes should be in the 'beijing' datacenter and have 'root' as the SSH username."",
  ""userQuery3"": ""The user wants to apply security groups to the nodes. The control nodes should have the 'control_security_group',"
68,sidcarter,indus,templates/azure/k8s/terraform/kubernetes,"variable ""subscription_id"" {}
variable ""client_id"" {}
variable ""client_secret"" {}
variable ""tenant_id"" {}

variable ""azure_region"" {}

variable ""azure_resource_group"" {}
variable ""azure_vnet_name"" {}

variable ""cluster_name"" {}
variable ""load_balancer_frontend_port"" {}
variable ""azure_admin_username"" {}
variable ""azure_admin_password"" {}
variable ""ssh_pub_key"" {}

variable ""azure_vnet_address_space"" {
    description = ""Address space to use""
    default = ""10.145.0.0/16""
}

variable ""azure_vnet_subnets"" {
    description = ""Subnets within the Vnet""
    default = {
        ""WebSN"" = ""10.145.0.0/20""
        ""BackendSN"" = ""10.145.16.0/20""
        ""DatastoreSN"" = ""10.145.32.0/20""
    }
}

variable ""default_image"" {
    description = ""AMI Information""
    default = {
        publisher   = ""credativ""
        offer       = ""Debian""
        sku         = ""9""
        version     = ""latest""
    }
}

variable ""workers_count"" {
    default = 3
}

variable ""masters_count"" {
    default = 3
}

variable ""workers_avail_set"" {
    default = ""ku8ie-workers""
}

variable ""masters_avail_set"" {
    default = ""ku8ie-masters""
}


# Configure the Microsoft Azure Provider
provider ""azurerm"" {
  subscription_id = ""${var.subscription_id}""
  client_id       = ""${var.client_id}""
  client_secret   = ""${var.client_secret}""
  tenant_id       = ""${var.tenant_id}""
}

# Create a resource group
resource ""azurerm_resource_group"" ""rg"" {
  name     = ""${var.azure_resource_group}""
  location = ""East US 2""
}

resource ""azurerm_virtual_network"" ""vnet"" {
  name                = ""${var.azure_vnet_name}""
  address_space       = [""10.145.0.0/16""]
  location            = ""East US 2""
  resource_group_name = ""${azurerm_resource_group.rg.name}""
}

resource ""azurerm_subnet"" ""backend"" {
    name                 = ""backend_subnet""
    resource_group_name  = ""${azurerm_resource_group.rg.name}""
    virtual_network_name = ""${azurerm_virtual_network.vnet.name}""
    address_prefix       = ""10.145.0.0/20""
    network_security_group_id = ""${azurerm_network_security_group.primary_nsg.id}""
}

# Create security groups
resource ""azurerm_network_security_group"" ""primary_nsg"" {
    name = ""primary_nsg""
    location = ""${var.azure_region}""
    resource_group_name = ""${azurerm_resource_group.rg.name}""

    security_rule {
        name = ""allow_inbound_ssh""
        priority = 100
        direction = ""Inbound""
        access = ""Allow""
        protocol = ""Tcp""
        source_port_range = ""*""
        destination_port_range = ""22""
        source_address_prefix = ""*""
        destination_address_prefix = ""*""
    }

    security_rule {
        name = ""allow_http_outbound""
        priority = 110
        direction = ""Outbound""
        access = ""Allow""
        protocol = ""Tcp""
        source_port_range = ""*""
        destination_port_range = ""80""
        source_address_prefix = ""*""
        destination_address_prefix = ""*""
    }

    security_rule {
        name = ""allow_https_outbound""
        priority = 120
        direction = ""Outbound""
        access = ""Allow""
        protocol = ""Tcp""
        source_port_range = ""*""
        destination_port_range = ""443""
        source_address_prefix = ""*""
        destination_address_prefix = ""*""
    }
}


# configuring the load balancer to get the masters

resource ""azurerm_public_ip"" ""master_lb_publicip"" {
    name                = ""${var.cluster_name}-masters-pip""
    location            = ""${var.azure_region}""
    resource_group_name = ""${azurerm_resource_group.rg.name}""
    domain_name_label   = ""${var.cluster_name}-control-lb""
    public_ip_address_allocation = ""static""
}

resource ""azurerm_lb"" ""master_lb"" {
    name                = ""${var.cluster_name}-masters-lb""
    location            = ""${var.azure_region}""
    resource_group_name = ""${azurerm_resource_group.rg.name}""

    frontend_ip_configuration {
        name                 = ""${var.cluster_name}-masters-feip""
        public_ip_address_id = ""${azurerm_public_ip.master_lb_publicip.id}""
    }
}

resource ""azurerm_lb_backend_address_pool"" ""master_bep"" {
    resource_group_name = ""${azurerm_resource_group.rg.name}""
    loadbalancer_id     = ""${azurerm_lb.master_lb.id}""
    name                = ""${var.cluster_name}-masters-lb-bep""
}

resource ""azurerm_lb_nat_rule"" ""master_nat_rule"" {
    count                   = ""${var.masters_count}""
    resource_group_name     = ""${azurerm_resource_group.rg.name}""
    loadbalancer_id         = ""${azurerm_lb.master_lb.id}""
    name                    = ""nat-rule-${count.index + 1}""
    protocol                = ""Tcp""
    frontend_port           = ""${var.load_balancer_frontend_port + count.index}""
    backend_port            = 22
    frontend_ip_configuration_name = ""${var.cluster_name}-masters-feip""
}

#let's create the default availability sets
resource ""azurerm_availability_set"" ""masters_avail_set"" {
    name                = ""${var.masters_avail_set}""
    location            = ""${var.azure_region}""
    resource_group_name = ""${azurerm_resource_group.rg.name}""
    
    managed             = true

    tags {
        environment = ""${var.azure_resource_group}""
    }
}

resource ""azurerm_network_interface"" ""master_nic"" {
    count               = ""${var.masters_count}""
    name                = ""master-${count.index + 1}-nic""
    location            = ""${var.azure_region}""
    resource_group_name = ""${azurerm_resource_group.rg.name}""

    ip_configuration {
        name        = ""master-${count.index + 1}-nic-config""
        subnet_id   = ""${azurerm_subnet.backend.id}""
        private_ip_address_allocation = ""dynamic""
        load_balancer_backend_address_pools_ids = [""${azurerm_lb_backend_address_pool.master_bep.id}""]
        load_balancer_inbound_nat_rules_ids = [""${element(azurerm_lb_nat_rule.master_nat_rule.*.id, count.index)}""]
    }
}

resource ""azurerm_virtual_machine"" ""master"" {
    count                 = ""${var.masters_count}""
    name                  = ""${var.cluster_name}-master-${count.index + 1}""
    location              = ""${var.azure_region}""
    resource_group_name   = ""${azurerm_resource_group.rg.name}""
    availability_set_id   = ""${azurerm_availability_set.masters_avail_set.id}""
    network_interface_ids = [""${element(azurerm_network_interface.master_nic.*.id, count.index)}""]
    vm_size               = ""Standard_A3""

    storage_image_reference {
        publisher = ""${var.default_image[""publisher""]}""
        offer = ""${var.default_image[""offer""]}""
        sku = ""${var.default_image[""sku""]}""
        version = ""${var.default_image[""version""]}""
    }

    storage_os_disk {
        name              = ""master-${count.index + 1}-osdisk""
        caching           = ""ReadWrite""
        create_option     = ""FromImage""
        managed_disk_type = ""Standard_LRS""
    }

    delete_os_disk_on_termination    = true

    os_profile {
        computer_name  = ""${var.cluster_name}-master-${count.index + 1}""
        admin_username = ""${var.azure_admin_username}""
        admin_password = ""${var.azure_admin_password}""
    }

    os_profile_linux_config {
        disable_password_authentication = true
        ssh_keys {
            path = ""/home/${var.azure_admin_username}/.ssh/authorized_keys""
            key_data = ""${var.ssh_pub_key}""
        }
    }

    provisioner ""file"" {
        source = ""scripts/setup-docker.sh""
        destination = ""/tmp/setup-docker.sh""
    }

    tags {
        orchestrator = ""kubernetes""
        environment = ""dev""
        type = ""master""
    }
}

resource ""azurerm_virtual_machine_extension"" ""master_extension"" {
    count                = ""${var.masters_count}""
    name                 = ""master-extension-${count.index + 1}""
    location             = ""${var.azure_region}""
    resource_group_name  = ""${azurerm_resource_group.rg.name}""
    virtual_machine_name = ""${element(azurerm_virtual_machine.master.*.name, count.index)}""
    publisher            = ""Microsoft.Azure.Extensions""
    type                 = ""CustomScript""
    type_handler_version = ""2.0""
    auto_upgrade_minor_version = true

    settings = <<SETTINGS
    {
        ""commandToExecute"": ""bash /tmp/setup-docker.sh &""
    }
    SETTINGS

}


#let's create the default availability sets
resource ""azurerm_availability_set"" ""workers_avail_set"" {
    name                = ""${var.workers_avail_set}""
    location            = ""${var.azure_region}""
    resource_group_name = ""${azurerm_resource_group.rg.name}""
    
    managed             = true

    tags {
        environment = ""${var.azure_resource_group}""
    }
}

resource ""azurerm_network_interface"" ""worker_nic"" {
    count               = ""${var.workers_count}""
    name                = ""worker-${count.index + 1}-nic""
    location            = ""${var.azure_region}""
    resource_group_name = ""${azurerm_resource_group.rg.name}""

    ip_configuration {
        name        = ""worker-${count.index + 1}-nic-config""
        subnet_id   = ""${azurerm_subnet.backend.id}""
        private_ip_address_allocation = ""dynamic""
    }
}

resource ""azurerm_managed_disk"" ""worker_data_disk"" {
    count       = ""${var.workers_count}""
    name        = ""worker-${count.index + 1}-datadisk""
    location    = ""${var.azure_region}""
    resource_group_name     = ""${azurerm_resource_group.rg.name}""
    storage_account_type    = ""Premium_LRS""
    create_option           = ""Empty""
    disk_size_gb            = ""511""
}

resource ""azurerm_virtual_machine"" ""worker"" {
    count                   = ""${var.workers_count}""
    name                    = ""${var.cluster_name}-worker-${count.index + 1}""
    location                = ""${var.azure_region}""
    resource_group_name     = ""${azurerm_resource_group.rg.name}""
    availability_set_id     = ""${azurerm_availability_set.workers_avail_set.id}""
    network_interface_ids = [""${element(azurerm_network_interface.worker_nic.*.id, count.index)}""]
    vm_size = ""Standard_DS12_v2""

    storage_image_reference {
        publisher   = ""${var.default_image[""publisher""]}""
        offer       = ""${var.default_image[""offer""]}""
        sku         = ""${var.default_image[""sku""]}""
        version     = ""${var.default_image[""version""]}""
    }

    storage_os_disk {
        name              = ""worker-${count.index + 1}-osdisk""
        caching           = ""ReadWrite""
        create_option     = ""FromImage""
        managed_disk_type = ""Premium_LRS""
    }

    storage_data_disk {
        name            = ""${element(azurerm_managed_disk.worker_data_disk.*.name, count.index)}""
        managed_disk_id = ""${element(azurerm_managed_disk.worker_data_disk.*.id, count.index)}""
        create_option   = ""Attach""
        lun             = 1
        disk_size_gb    = ""${element(azurerm_managed_disk.worker_data_disk.*.disk_size_gb, count.index)}""
    }

    delete_os_disk_on_termination    = true
    delete_data_disks_on_termination = true

    os_profile {
        computer_name  = ""${var.cluster_name}-worker-${count.index + 1}""
        admin_username = ""${var.azure_admin_username}""
        admin_password = ""${var.azure_admin_password}""
    }

    os_profile_linux_config {
        disable_password_authentication = false
        ssh_keys {
            path        = ""/home/${var.azure_admin_username}/.ssh/authorized_keys""
            key_data    = ""${var.ssh_pub_key}""
        }
    }

    provisioner ""file"" {
        source = ""scripts/setup-docker.sh""
        destination = ""/tmp/setup-docker.sh""
    }

    tags {
        orchestrator = ""kubernetes""
        environment = ""dev""
        type = ""worker""
    }
}

resource ""azurerm_virtual_machine_extension"" ""worker_extension"" {
    count                = ""${var.workers_count}""
    name                 = ""worker-extension-${count.index + 1}""
    location             = ""${var.azure_region}""
    resource_group_name  = ""${azurerm_resource_group.rg.name}""
    virtual_machine_name = ""${element(azurerm_virtual_machine.worker.*.name, count.index)}""
    publisher            = ""Microsoft.Azure.Extensions""
    type                 = ""CustomScript""
    type_handler_version = ""2.0""
    auto_upgrade_minor_version = true

    settings = <<SETTINGS
    {
        ""commandToExecute"": ""bash /tmp/setup-docker.sh &""
    }
    SETTINGS

}


","{
""userQuery1"": ""The user wants to create a Kubernetes cluster on Microsoft Azure. The cluster should consist of a set of master nodes and worker nodes. The number of master nodes and worker nodes should be configurable."",
""userQuery2"": ""The user wants to set up a virtual network for the Kubernetes cluster. The network should have a specific address space and should be divided into subnets. The user also wants to set up a network security group with specific rules for inbound and outbound traffic."",
""userQuery3"": ""The user wants to set up a load balancer for the master nodes of the Kubernetes cluster. The load balancer should have a public IP address and should be able to distribute traffic to the master nodes."",
""userQuery4"": ""The user wants to set up a specific type of virtual machine for the master nodes and worker nodes. The virtual machines should have a specific storage configuration and should be part of an availability set. The user also wants to set up a specific type of operating"
69,enxebre,tectonic-installer,modules/google/ignition,"/*
Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

variable ""container_images"" {
  description = ""Container images to use""
  type        = ""map""
}

variable ""assets_gcs_location"" {
  type        = ""string""
  description = ""Location on GCS of the Bootkube/Tectonic assets to use (bucket/key)""
}

variable ""kubeconfig_gcs_location"" {
  type        = ""string""
  description = ""Location on GCS of the kubeconfig file to use (bucket/key)""
}

variable ""kube_dns_service_ip"" {
  type        = ""string""
  description = ""Service IP used to reach kube-dns""
}

variable ""kubelet_node_label"" {
  type        = ""string""
  description = ""Label that Kubelet will apply on the node""
}

variable ""kubelet_node_taints"" {
  type        = ""string""
  description = ""Taints that Kubelet will apply on the node""
}

variable ""etcd_endpoints"" {
  type        = ""list""
  description = ""List of etcd endpoints""
}

variable ""bootkube_service"" {
  type        = ""string""
  description = ""The content of the bootkube systemd service unit""
}

variable ""tectonic_service"" {
  type        = ""string""
  description = ""The content of the tectonic installer systemd service unit""
}

variable ""tectonic_service_disabled"" {
  description = ""Specifies whether the tectonic installer systemd unit will be disabled. If true, no tectonic assets will be deployed""
  default     = false
}

variable ""locksmithd_disabled"" {
  description = ""Specifies whether locksmith will be disabled or not""
  default     = false
}


data ""ignition_config"" ""main"" {
  files = [
    ""${data.ignition_file.max-user-watches.id}"",
    ""${data.ignition_file.gcs-puller.id}"",
    ""${data.ignition_file.init-assets.id}"",
  ]

  systemd = [
    ""${data.ignition_systemd_unit.etcd-member.id}"",
    ""${data.ignition_systemd_unit.docker.id}"",
    ""${data.ignition_systemd_unit.locksmithd.id}"",
    ""${data.ignition_systemd_unit.kubelet.id}"",
    ""${data.ignition_systemd_unit.init-assets.id}"",
    ""${data.ignition_systemd_unit.bootkube.id}"",
    ""${data.ignition_systemd_unit.tectonic.id}"",
  ]
}

data ""ignition_systemd_unit"" ""docker"" {
  name   = ""docker.service""
  enable = true

  dropin = [
    {
      name    = ""10-dockeropts.conf""
      content = ""[Service]\nEnvironment=\""DOCKER_OPTS=--log-opt max-size=50m --log-opt max-file=3\""\n""
    },
  ]
}

data ""ignition_systemd_unit"" ""locksmithd"" {
  name = ""locksmithd.service""
  mask = true
}

data ""template_file"" ""kubelet"" {
  template = ""${file(""${path.module}/resources/services/kubelet.service"")}""

  vars {
    aci                     = ""${element(split("":"", var.container_images[""hyperkube""]), 0)}""
    version                 = ""${element(split("":"", var.container_images[""hyperkube""]), 1)}""
    cluster_dns_ip          = ""${var.kube_dns_service_ip}""
    node_label              = ""${var.kubelet_node_label}""
    node_taints_param       = ""${var.kubelet_node_taints != """" ? ""--register-with-taints=${var.kubelet_node_taints}"" : """"}""
    kubeconfig_gcs_location = ""${var.kubeconfig_gcs_location}""
  }
}

data ""ignition_systemd_unit"" ""kubelet"" {
  name    = ""kubelet.service""
  enable  = true
  content = ""${data.template_file.kubelet.rendered}""
}

data ""template_file"" ""etcd-member"" {
  template = ""${file(""${path.module}/resources/services/etcd-member.service"")}""

  vars {
    image     = ""${var.container_images[""etcd""]}""
    endpoints = ""${join("","", formatlist(""%s:2379"", var.etcd_endpoints))}""
  }
}

data ""ignition_systemd_unit"" ""etcd-member"" {
  name   = ""etcd-member.service""
  enable = ""false""

  dropin = [
    {
      name    = ""40-etcd-gateway.conf""
      content = ""${data.template_file.etcd-member.rendered}""
    },
  ]
}

data ""ignition_file"" ""max-user-watches"" {
  filesystem = ""root""
  path       = ""/etc/sysctl.d/max-user-watches.conf""
  mode       = ""420""

  content {
    content = ""fs.inotify.max_user_watches=16184""
  }
}

data ""ignition_file"" ""gcs-puller"" {
  filesystem = ""root""
  path       = ""/opt/gcs-puller.sh""
  mode       = ""555""

  content {
    content = ""${file(""${path.module}/resources/gcs-puller.sh"")}""
  }
}

data ""template_file"" ""init-assets"" {
  template = ""${file(""${path.module}/resources/init-assets.sh"")}""

  vars {
    assets_gcs_location = ""${var.assets_gcs_location}""
  }
}

data ""ignition_file"" ""init-assets"" {
  filesystem = ""root""
  path       = ""/opt/tectonic/init-assets.sh""
  mode       = ""555""

  content {
    content = ""${data.template_file.init-assets.rendered}""
  }
}

data ""ignition_systemd_unit"" ""init-assets"" {
  name    = ""init-assets.service""
  enable  = ""${var.assets_gcs_location != """" ? true : false}""
  content = ""${file(""${path.module}/resources/services/init-assets.service"")}""
}

data ""ignition_systemd_unit"" ""bootkube"" {
  name    = ""bootkube.service""
  content = ""${var.bootkube_service}""
}

data ""ignition_systemd_unit"" ""tectonic"" {
  name    = ""tectonic.service""
  enable  = ""${var.tectonic_service_disabled == 0 ? true : false}""
  content = ""${var.tectonic_service}""
}


/*
Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

output ""ignition"" {
  value = ""${data.ignition_config.main.rendered}""
}


","{
  ""userQuery1"": ""What container images should be used for the deployment?"",
  ""userQuery2"": ""Where are the Bootkube/Tectonic assets located on Google Cloud Storage (GCS)?"",
  ""userQuery3"": ""Where is the kubeconfig file located on Google Cloud Storage (GCS)?"",
  ""userQuery4"": ""What is the service IP used to reach kube-dns?"",
  ""userQuery5"": ""What label should the Kubelet apply on the node?"",
  ""userQuery6"": ""What taints should the Kubelet apply on the node?"",
  ""userQuery7"": ""What are the endpoints for etcd?"",
  ""userQuery8"": ""What is the content of the bootkube systemd service unit?"",
  ""userQuery9"": ""What is the content of the tectonic installer systemd service unit?"",
  ""userQuery10"": ""Should the tectonic installer systemd unit be disabled?"",
 "
70,ento,discourse_aws,tfmodules/discourse-vpc,"data ""aws_availability_zones"" ""available"" {
}

module ""vpc"" {
  source  = ""terraform-aws-modules/vpc/aws""
  version = ""2.32.0""

  name = var.name_prefix

  cidr            = ""10.0.0.0/16""
  private_subnets = [""10.0.1.0/24"", ""10.0.2.0/24""]
  public_subnets  = [""10.0.101.0/24""]

  azs = data.aws_availability_zones.available.names

  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = var.tags
}

resource ""aws_security_group"" ""web"" {
  name   = ""${var.name_prefix}_web""
  vpc_id = module.vpc.vpc_id

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = ""TCP""
    cidr_blocks = [""0.0.0.0/0""]
  }

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = ""TCP""
    cidr_blocks = [""0.0.0.0/0""]
  }

  tags = var.tags
}

resource ""aws_security_group"" ""db"" {
  name   = ""${var.name_prefix}_db""
  vpc_id = module.vpc.vpc_id

  ingress {
    from_port       = 5432
    to_port         = 5432
    protocol        = ""TCP""
    security_groups = [aws_security_group.web.id]
  }

  tags = var.tags
}


variable ""name_prefix"" {
  default = ""discourse""
}

variable ""tags"" {
  type = map(string)

  default = {
    Terraform = ""true""
  }
}



terraform {
  required_version = "">= 0.12""
}


output ""vpc_id"" {
  value = module.vpc.vpc_id
}

output ""public_subnet"" {
  value = module.vpc.public_subnets[0]
}

output ""private_subnets"" {
  value = module.vpc.private_subnets
}

output ""default_security_group_id"" {
  value = module.vpc.default_security_group_id
}

output ""db_security_group_id"" {
  value = aws_security_group.db.id
}

output ""web_security_group_id"" {
  value = aws_security_group.web.id
}


","{
  ""userQuery1"": ""The user wants to create a Virtual Private Cloud (VPC) in AWS with a specific IP address range (CIDR block of '10.0.0.0/16'). The VPC should have both private and public subnets with their respective IP address ranges. The VPC should be named with a prefix provided by the user and should have DNS hostnames and DNS support enabled. The VPC should also be tagged with a set of key-value pairs provided by the user."",
  ""userQuery2"": ""The user wants to create two security groups within the VPC, one for a web server and another for a database server. The web server security group should allow incoming traffic on port 22 (SSH) and port 443 (HTTPS) from any IP address. The database server security group should only allow incoming traffic on port 5432 (PostgreSQL) from the web server security group. Both security groups should be named with a"
71,terraform-google-modules,terraform-google-kubernetes-engine,test/setup,"/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">= 0.13""
  required_providers {
    google = {
      source = ""hashicorp/google""
    }
    google-beta = {
      source = ""hashicorp/google-beta""
    }
    random = {
      source = ""hashicorp/random""
    }
  }
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
variable ""org_id"" {
  description = ""The numeric organization id""
}

variable ""folder_id"" {
  description = ""The folder to deploy in""
}

variable ""billing_account"" {
  description = ""The billing account id associated with the project, e.g. XXXXXX-YYYYYY-ZZZZZZ""
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

resource ""random_id"" ""random_project_id_suffix"" {
  byte_length = 4
}

locals {
  apis = [
    ""cloudkms.googleapis.com"",
    ""cloudresourcemanager.googleapis.com"",
    ""container.googleapis.com"",
    ""pubsub.googleapis.com"",
    ""serviceusage.googleapis.com"",
    ""storage-api.googleapis.com"",
    ""anthos.googleapis.com"",
    ""anthosconfigmanagement.googleapis.com"",
    ""logging.googleapis.com"",
    ""meshca.googleapis.com"",
    ""meshconfig.googleapis.com"",
    ""cloudresourcemanager.googleapis.com"",
    ""monitoring.googleapis.com"",
    ""stackdriver.googleapis.com"",
    ""cloudtrace.googleapis.com"",
    ""meshca.googleapis.com"",
    ""iamcredentials.googleapis.com"",
    ""gkeconnect.googleapis.com"",
    ""privateca.googleapis.com"",
    ""gkehub.googleapis.com""
  ]
}

module ""gke-project-1"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 14.0""

  name                     = ""ci-gke-${random_id.random_project_id_suffix.hex}""
  random_project_id        = true
  random_project_id_length = 4
  org_id                   = var.org_id
  folder_id                = var.folder_id
  billing_account          = var.billing_account
  # due to https://github.com/hashicorp/terraform-provider-google/issues/9505 for AP
  default_service_account = ""keep""

  auto_create_network = true

  activate_apis = local.apis
  activate_api_identities = [
    {
      api   = ""container.googleapis.com""
      roles = [""roles/cloudkms.cryptoKeyEncrypterDecrypter"", ""roles/container.serviceAgent""]
    },
  ]
}

module ""gke-project-2"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 14.0""

  name              = ""ci-gke-${random_id.random_project_id_suffix.hex}""
  random_project_id = true
  org_id            = var.org_id
  folder_id         = var.folder_id
  billing_account   = var.billing_account
  # due to https://github.com/hashicorp/terraform-provider-google/issues/9505 for AP
  default_service_account = ""keep""

  activate_apis = local.apis
  activate_api_identities = [
    {
      api   = ""container.googleapis.com""
      roles = [""roles/cloudkms.cryptoKeyEncrypterDecrypter"", ""roles/container.serviceAgent""]
    },
  ]
}

# apis as documented https://cloud.google.com/service-mesh/docs/scripted-install/reference#setting_up_your_project
module ""gke-project-asm"" {
  source  = ""terraform-google-modules/project-factory/google""
  version = ""~> 14.0""

  name              = ""ci-gke-asm-${random_id.random_project_id_suffix.hex}""
  random_project_id = true
  org_id            = var.org_id
  folder_id         = var.folder_id
  billing_account   = var.billing_account
  # due to https://github.com/hashicorp/terraform-provider-google/issues/9505 for AP
  default_service_account = ""keep""

  activate_apis = local.apis
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

locals {
  int_required_roles = [
    ""roles/cloudkms.admin"",
    ""roles/cloudkms.cryptoKeyEncrypterDecrypter"",
    ""roles/compute.networkAdmin"",
    ""roles/compute.securityAdmin"",
    ""roles/container.admin"",
    ""roles/container.clusterAdmin"",
    ""roles/container.developer"",
    ""roles/iam.serviceAccountAdmin"",
    ""roles/iam.serviceAccountUser"",
    ""roles/compute.admin"",
    ""roles/resourcemanager.projectIamAdmin"",
    ""roles/composer.worker"",
    ""roles/serviceusage.serviceUsageAdmin"",
    ""roles/compute.osLogin"",
    ""roles/compute.instanceAdmin"",
    ""roles/iam.roleAdmin"",
    ""roles/iap.admin"",
    ""roles/gkehub.admin"",
  ]

  # roles as documented https://cloud.google.com/service-mesh/docs/installation-permissions
  int_asm_required_roles = [
    ""roles/editor"",
    ""roles/compute.admin"",
    ""roles/container.admin"",
    ""roles/resourcemanager.projectIamAdmin"",
    ""roles/servicemanagement.admin"",
    ""roles/serviceusage.serviceUsageAdmin"",
    ""roles/iam.serviceAccountAdmin"",
    ""roles/iam.serviceAccountKeyAdmin"",
    ""roles/meshconfig.admin"",
    ""roles/gkehub.admin"",
    ""roles/privateca.admin"",
  ]
}

resource ""random_id"" ""random_suffix"" {
  byte_length = 2
}

resource ""google_service_account"" ""int_test"" {
  project      = module.gke-project-1.project_id
  account_id   = ""gke-int-test-${random_id.random_suffix.hex}""
  display_name = ""gke-int-test""
}

resource ""google_service_account"" ""gke_sa_1"" {
  project      = module.gke-project-1.project_id
  account_id   = ""gke-sa-int-test-p1-${random_id.random_suffix.hex}""
  display_name = ""gke-sa-int-test-p1""
}

resource ""google_service_account"" ""gke_sa_2"" {
  project      = module.gke-project-2.project_id
  account_id   = ""gke-sa-int-test-p2-${random_id.random_suffix.hex}""
  display_name = ""gke-sa-int-test-p2""
}

resource ""google_service_account"" ""gke_sa_asm"" {
  project      = module.gke-project-asm.project_id
  account_id   = ""gke-sa-int-test-asm-${random_id.random_suffix.hex}""
  display_name = ""gke-sa-int-test-asm""
}

resource ""google_project_iam_member"" ""int_test_1"" {
  count = length(local.int_required_roles)

  project = module.gke-project-1.project_id
  role    = local.int_required_roles[count.index]
  member  = ""serviceAccount:${google_service_account.int_test.email}""
}

resource ""google_project_iam_member"" ""int_test_2"" {
  count = length(local.int_required_roles)

  project = module.gke-project-2.project_id
  role    = local.int_required_roles[count.index]
  member  = ""serviceAccount:${google_service_account.int_test.email}""
}

resource ""google_project_iam_member"" ""int_test_asm"" {
  for_each = toset(concat(local.int_required_roles, local.int_asm_required_roles))

  project = module.gke-project-asm.project_id
  role    = each.value
  member  = ""serviceAccount:${google_service_account.int_test.email}""
}

resource ""google_service_account_key"" ""int_test"" {
  service_account_id = google_service_account.int_test.id
}

resource ""google_project_iam_binding"" ""kubernetes_engine_kms_access"" {
  project = module.gke-project-1.project_id
  role    = ""roles/cloudkms.cryptoKeyEncrypterDecrypter""

  members = [
    ""serviceAccount:service-${module.gke-project-1.project_number}@container-engine-robot.iam.gserviceaccount.com"",
  ]
}


/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""project_ids"" {
  value = [module.gke-project-1.project_id, module.gke-project-2.project_id, module.gke-project-asm.project_id]
}

output ""sa_key"" {
  value     = google_service_account_key.int_test.private_key
  sensitive = true
}

output ""int_sa"" {
  value = google_service_account.int_test.email
}

output ""compute_engine_service_accounts"" {
  value = [google_service_account.gke_sa_1.email, google_service_account.gke_sa_2.email, google_service_account.gke_sa_asm.email]
}

output ""registry_project_ids"" {
  value = [module.gke-project-1.project_id]
}


","{
  ""userQuery1"": ""The user needs to specify the version of Terraform and the providers required for the infrastructure. The providers include Google, Google-beta, and Random."",
  ""userQuery2"": ""The user wants to create three Google Cloud projects with specific configurations. Each project requires a unique name, organization ID, folder ID, and billing account. The projects also need to have certain APIs activated and service accounts created with specific roles."",
  ""userQuery3"": ""The user intends to output the project IDs, service account key, email of the service account, and the email of the compute engine service accounts. The user also wants to output the project IDs for the registry.""
}"
72,GoogleCloudPlatform,cloud-foundation-fabric,modules/compute-mig,"/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

locals {
  health_check = (
    try(var.auto_healing_policies.health_check, null) == null
    ? try(google_compute_health_check.default.0.self_link, null)
    : try(var.auto_healing_policies.health_check, null)
  )
  instance_group_manager = (
    local.is_regional ?
    google_compute_region_instance_group_manager.default :
    google_compute_instance_group_manager.default
  )
  is_regional = length(split(""-"", var.location)) == 2
}

resource ""google_compute_instance_group_manager"" ""default"" {
  provider                  = google-beta
  count                     = local.is_regional ? 0 : 1
  project                   = var.project_id
  zone                      = var.location
  name                      = var.name
  base_instance_name        = var.name
  description               = var.description
  target_size               = var.target_size
  target_pools              = var.target_pools
  wait_for_instances        = try(var.wait_for_instances.enabled, null)
  wait_for_instances_status = try(var.wait_for_instances.status, null)

  dynamic ""all_instances_config"" {
    for_each = var.all_instances_config == null ? [] : [""""]
    content {
      labels   = try(var.all_instances_config.labels, null)
      metadata = try(var.all_instances_config.metadata, null)
    }
  }

  dynamic ""auto_healing_policies"" {
    for_each = var.auto_healing_policies == null ? [] : [""""]
    iterator = config
    content {
      health_check      = local.health_check
      initial_delay_sec = var.auto_healing_policies.initial_delay_sec
    }
  }

  dynamic ""named_port"" {
    for_each = var.named_ports == null ? {} : var.named_ports
    iterator = config
    content {
      name = config.key
      port = config.value
    }
  }

  dynamic ""stateful_disk"" {
    for_each = var.stateful_disks
    content {
      device_name = stateful_disk.key
      delete_rule = stateful_disk.value ? ""ON_PERMANENT_INSTANCE_DELETION"" : ""NEVER""
    }
  }

  dynamic ""update_policy"" {
    for_each = var.update_policy == null ? [] : [var.update_policy]
    iterator = p
    content {
      minimal_action                 = p.value.minimal_action
      type                           = p.value.type
      max_surge_fixed                = try(p.value.max_surge.fixed, null)
      max_surge_percent              = try(p.value.max_surge.percent, null)
      max_unavailable_fixed          = try(p.value.max_unavailable.fixed, null)
      max_unavailable_percent        = try(p.value.max_unavailable.percent, null)
      min_ready_sec                  = p.value.min_ready_sec
      most_disruptive_allowed_action = p.value.most_disruptive_action
      replacement_method             = p.value.replacement_method
    }
  }

  version {
    instance_template = var.instance_template
    name              = var.default_version_name
  }

  dynamic ""version"" {
    for_each = var.versions
    content {
      name              = version.key
      instance_template = version.value.instance_template
      dynamic ""target_size"" {
        for_each = version.value.target_size == null ? [] : [""""]
        content {
          fixed   = version.value.target_size.fixed
          percent = version.value.target_size.percent
        }
      }
    }
  }
}

resource ""google_compute_region_instance_group_manager"" ""default"" {
  provider           = google-beta
  count              = local.is_regional ? 1 : 0
  project            = var.project_id
  region             = var.location
  name               = var.name
  base_instance_name = var.name
  description        = var.description
  distribution_policy_target_shape = try(
    var.distribution_policy.target_shape, null
  )
  distribution_policy_zones = try(
    var.distribution_policy.zones, null
  )
  target_size               = var.target_size
  target_pools              = var.target_pools
  wait_for_instances        = try(var.wait_for_instances.enabled, null)
  wait_for_instances_status = try(var.wait_for_instances.status, null)

  dynamic ""all_instances_config"" {
    for_each = var.all_instances_config == null ? [] : [""""]
    content {
      labels   = try(var.all_instances_config.labels, null)
      metadata = try(var.all_instances_config.metadata, null)
    }
  }

  dynamic ""auto_healing_policies"" {
    for_each = var.auto_healing_policies == null ? [] : [""""]
    iterator = config
    content {
      health_check      = local.health_check
      initial_delay_sec = var.auto_healing_policies.initial_delay_sec
    }
  }

  dynamic ""named_port"" {
    for_each = var.named_ports == null ? {} : var.named_ports
    iterator = config
    content {
      name = config.key
      port = config.value
    }
  }

  dynamic ""stateful_disk"" {
    for_each = var.stateful_disks
    content {
      device_name = stateful_disk.key
      delete_rule = stateful_disk.value ? ""ON_PERMANENT_INSTANCE_DELETION"" : ""NEVER""
    }
  }

  dynamic ""update_policy"" {
    for_each = var.update_policy == null ? [] : [var.update_policy]
    iterator = p
    content {
      minimal_action                 = p.value.minimal_action
      type                           = p.value.type
      instance_redistribution_type   = p.value.regional_redistribution_type
      max_surge_fixed                = try(p.value.max_surge.fixed, null)
      max_surge_percent              = try(p.value.max_surge.percent, null)
      max_unavailable_fixed          = try(p.value.max_unavailable.fixed, null)
      max_unavailable_percent        = try(p.value.max_unavailable.percent, null)
      min_ready_sec                  = p.value.min_ready_sec
      most_disruptive_allowed_action = p.value.most_disruptive_action
      replacement_method             = p.value.replacement_method
    }
  }

  version {
    instance_template = var.instance_template
    name              = var.default_version_name
  }

  dynamic ""version"" {
    for_each = var.versions
    content {
      name              = version.key
      instance_template = version.value.instance_template
      dynamic ""target_size"" {
        for_each = version.value.target_size == null ? [] : [""""]
        content {
          fixed   = version.value.target_size.fixed
          percent = version.value.target_size.percent
        }
      }
    }
  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""all_instances_config"" {
  description = ""Metadata and labels set to all instances in the group.""
  type = object({
    labels   = optional(map(string))
    metadata = optional(map(string))
  })
  default = null
}

variable ""auto_healing_policies"" {
  description = ""Auto-healing policies for this group.""
  type = object({
    health_check      = optional(string)
    initial_delay_sec = number
  })
  default = null
}

variable ""autoscaler_config"" {
  description = ""Optional autoscaler configuration.""
  type = object({
    max_replicas    = number
    min_replicas    = number
    cooldown_period = optional(number)
    mode            = optional(string) # OFF, ONLY_UP, ON
    scaling_control = optional(object({
      down = optional(object({
        max_replicas_fixed   = optional(number)
        max_replicas_percent = optional(number)
        time_window_sec      = optional(number)
      }))
      in = optional(object({
        max_replicas_fixed   = optional(number)
        max_replicas_percent = optional(number)
        time_window_sec      = optional(number)
      }))
    }), {})
    scaling_signals = optional(object({
      cpu_utilization = optional(object({
        target                = number
        optimize_availability = optional(bool)
      }))
      load_balancing_utilization = optional(object({
        target = number
      }))
      metrics = optional(list(object({
        name                       = string
        type                       = optional(string) # GAUGE, DELTA_PER_SECOND, DELTA_PER_MINUTE
        target_value               = optional(number)
        single_instance_assignment = optional(number)
        time_series_filter         = optional(string)
      })))
      schedules = optional(list(object({
        duration_sec          = number
        name                  = string
        min_required_replicas = number
        cron_schedule         = string
        description           = optional(bool)
        timezone              = optional(string)
        disabled              = optional(bool)
      })))
    }), {})
  })
  default = null
}

variable ""default_version_name"" {
  description = ""Name used for the default version.""
  type        = string
  default     = ""default""
}

variable ""description"" {
  description = ""Optional description used for all resources managed by this module.""
  type        = string
  default     = ""Terraform managed.""
}

variable ""distribution_policy"" {
  description = ""DIstribution policy for regional MIG.""
  type = object({
    target_shape = optional(string)
    zones        = optional(list(string))
  })
  default = null
}

variable ""health_check_config"" {
  description = ""Optional auto-created health check configuration, use the output self-link to set it in the auto healing policy. Refer to examples for usage.""
  type = object({
    check_interval_sec  = optional(number)
    description         = optional(string, ""Terraform managed."")
    enable_logging      = optional(bool, false)
    healthy_threshold   = optional(number)
    timeout_sec         = optional(number)
    unhealthy_threshold = optional(number)
    grpc = optional(object({
      port               = optional(number)
      port_name          = optional(string)
      port_specification = optional(string) # USE_FIXED_PORT USE_NAMED_PORT USE_SERVING_PORT
      service_name       = optional(string)
    }))
    http = optional(object({
      host               = optional(string)
      port               = optional(number)
      port_name          = optional(string)
      port_specification = optional(string) # USE_FIXED_PORT USE_NAMED_PORT USE_SERVING_PORT
      proxy_header       = optional(string)
      request_path       = optional(string)
      response           = optional(string)
    }))
    http2 = optional(object({
      host               = optional(string)
      port               = optional(number)
      port_name          = optional(string)
      port_specification = optional(string) # USE_FIXED_PORT USE_NAMED_PORT USE_SERVING_PORT
      proxy_header       = optional(string)
      request_path       = optional(string)
      response           = optional(string)
    }))
    https = optional(object({
      host               = optional(string)
      port               = optional(number)
      port_name          = optional(string)
      port_specification = optional(string) # USE_FIXED_PORT USE_NAMED_PORT USE_SERVING_PORT
      proxy_header       = optional(string)
      request_path       = optional(string)
      response           = optional(string)
    }))
    tcp = optional(object({
      port               = optional(number)
      port_name          = optional(string)
      port_specification = optional(string) # USE_FIXED_PORT USE_NAMED_PORT USE_SERVING_PORT
      proxy_header       = optional(string)
      request            = optional(string)
      response           = optional(string)
    }))
    ssl = optional(object({
      port               = optional(number)
      port_name          = optional(string)
      port_specification = optional(string) # USE_FIXED_PORT USE_NAMED_PORT USE_SERVING_PORT
      proxy_header       = optional(string)
      request            = optional(string)
      response           = optional(string)
    }))
  })
  default = null
  validation {
    condition = (
      (try(var.health_check_config.grpc, null) == null ? 0 : 1) +
      (try(var.health_check_config.http, null) == null ? 0 : 1) +
      (try(var.health_check_config.http2, null) == null ? 0 : 1) +
      (try(var.health_check_config.https, null) == null ? 0 : 1) +
      (try(var.health_check_config.tcp, null) == null ? 0 : 1) +
      (try(var.health_check_config.ssl, null) == null ? 0 : 1) <= 1
    )
    error_message = ""Only one health check type can be configured at a time.""
  }
}

variable ""instance_template"" {
  description = ""Instance template for the default version.""
  type        = string
}

variable ""location"" {
  description = ""Compute zone or region.""
  type        = string
}

variable ""name"" {
  description = ""Managed group name.""
  type        = string
}

variable ""named_ports"" {
  description = ""Named ports.""
  type        = map(number)
  default     = null
}

variable ""project_id"" {
  description = ""Project id.""
  type        = string
}

variable ""stateful_config"" {
  description = ""Stateful configuration for individual instances.""
  type = map(object({
    minimal_action          = optional(string)
    most_disruptive_action  = optional(string)
    remove_state_on_destroy = optional(bool)
    preserved_state = optional(object({
      disks = optional(map(object({
        source                      = string
        delete_on_instance_deletion = optional(bool)
        read_only                   = optional(bool)
      })))
      metadata = optional(map(string))
    }))
  }))
  default  = {}
  nullable = false
}

variable ""stateful_disks"" {
  description = ""Stateful disk configuration applied at the MIG level to all instances, in device name => on permanent instance delete rule as boolean.""
  type        = map(bool)
  default     = {}
  nullable    = false
}

variable ""target_pools"" {
  description = ""Optional list of URLs for target pools to which new instances in the group are added.""
  type        = list(string)
  default     = []
}

variable ""target_size"" {
  description = ""Group target size, leave null when using an autoscaler.""
  type        = number
  default     = null
}

variable ""update_policy"" {
  description = ""Update policy. Minimal action and type are required.""
  type = object({
    minimal_action = string
    type           = string
    max_surge = optional(object({
      fixed   = optional(number)
      percent = optional(number)
    }))
    max_unavailable = optional(object({
      fixed   = optional(number)
      percent = optional(number)
    }))
    min_ready_sec                = optional(number)
    most_disruptive_action       = optional(string)
    regional_redistribution_type = optional(string)
    replacement_method           = optional(string)
  })
  default = null
}

variable ""versions"" {
  description = ""Additional application versions, target_size is optional.""
  type = map(object({
    instance_template = string
    target_size = optional(object({
      fixed   = optional(number)
      percent = optional(number)
    }))
  }))
  default  = {}
  nullable = false
}

variable ""wait_for_instances"" {
  description = ""Wait for all instances to be created/updated before returning.""
  type = object({
    enabled = bool
    status  = optional(string)
  })
  default = null
}


# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

terraform {
  required_version = "">= 1.5.1""
  required_providers {
    google = {
      source  = ""hashicorp/google""
      version = "">= 5.10.0, < 6.0.0"" # tftest
    }
    google-beta = {
      source  = ""hashicorp/google-beta""
      version = "">= 5.10.0, < 6.0.0"" # tftest
    }
  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

# tfdoc:file:description Autoscaler resource.

locals {
  as_enabled = true
  as_scaling = try(var.autoscaler_config.scaling_control, null)
  as_signals = try(var.autoscaler_config.scaling_signals, null)
}

resource ""google_compute_autoscaler"" ""default"" {
  provider    = google-beta
  count       = local.is_regional || var.autoscaler_config == null ? 0 : 1
  project     = var.project_id
  name        = var.name
  zone        = var.location
  description = var.description
  target      = google_compute_instance_group_manager.default.0.id

  autoscaling_policy {
    max_replicas    = var.autoscaler_config.max_replicas
    min_replicas    = var.autoscaler_config.min_replicas
    cooldown_period = var.autoscaler_config.cooldown_period
    mode            = var.autoscaler_config.mode

    dynamic ""scale_down_control"" {
      for_each = local.as_scaling.down == null ? [] : [""""]
      content {
        time_window_sec = local.as_scaling.down.time_window_sec
        dynamic ""max_scaled_down_replicas"" {
          for_each = (
            local.as_scaling.down.max_replicas_fixed == null &&
            local.as_scaling.down.max_replicas_percent == null
            ? []
            : [""""]
          )
          content {
            fixed   = local.as_scaling.down.max_replicas_fixed
            percent = local.as_scaling.down.max_replicas_percent
          }
        }
      }
    }

    dynamic ""scale_in_control"" {
      for_each = local.as_scaling.in == null ? [] : [""""]
      content {
        time_window_sec = local.as_scaling.in.time_window_sec
        dynamic ""max_scaled_in_replicas"" {
          for_each = (
            local.as_scaling.in.max_replicas_fixed == null &&
            local.as_scaling.in.max_replicas_percent == null
            ? []
            : [""""]
          )
          content {
            fixed   = local.as_scaling.in.max_replicas_fixed
            percent = local.as_scaling.in.max_replicas_percent
          }
        }
      }
    }

    dynamic ""cpu_utilization"" {
      for_each = local.as_signals.cpu_utilization == null ? [] : [""""]
      content {
        target = local.as_signals.cpu_utilization.target
        predictive_method = (
          local.as_signals.cpu_utilization.optimize_availability == true
          ? ""OPTIMIZE_AVAILABILITY""
          : null
        )
      }
    }

    dynamic ""load_balancing_utilization"" {
      for_each = local.as_signals.load_balancing_utilization == null ? [] : [""""]
      content {
        target = local.as_signals.load_balancing_utilization.target
      }
    }

    dynamic ""metric"" {
      for_each = toset(
        local.as_signals.metrics == null ? [] : local.as_signals.metrics
      )
      content {
        name                       = metric.value.name
        type                       = metric.value.type
        target                     = metric.value.target_value
        single_instance_assignment = metric.value.single_instance_assignment
        filter                     = metric.value.time_series_filter
      }
    }

    dynamic ""scaling_schedules"" {
      for_each = toset(
        local.as_signals.schedules == null ? [] : local.as_signals.schedules
      )
      iterator = schedule
      content {
        duration_sec          = schedule.value.duration_sec
        min_required_replicas = schedule.value.min_required_replicas
        name                  = schedule.value.name
        schedule              = schedule.value.cron_schedule
        description           = schedule.value.description
        disabled              = schedule.value.disabled
        time_zone             = schedule.value.timezone
      }
    }

  }
}

resource ""google_compute_region_autoscaler"" ""default"" {
  provider    = google-beta
  count       = local.is_regional && var.autoscaler_config != null ? 1 : 0
  project     = var.project_id
  name        = var.name
  region      = var.location
  description = var.description
  target      = google_compute_region_instance_group_manager.default.0.id

  autoscaling_policy {
    max_replicas    = var.autoscaler_config.max_replicas
    min_replicas    = var.autoscaler_config.min_replicas
    cooldown_period = var.autoscaler_config.cooldown_period
    mode            = var.autoscaler_config.mode

    dynamic ""scale_down_control"" {
      for_each = local.as_scaling.down == null ? [] : [""""]
      content {
        time_window_sec = local.as_scaling.down.time_window_sec
        dynamic ""max_scaled_down_replicas"" {
          for_each = (
            local.as_scaling.down.max_replicas_fixed == null &&
            local.as_scaling.down.max_replicas_percent == null
            ? []
            : [""""]
          )
          content {
            fixed   = local.as_scaling.down.max_replicas_fixed
            percent = local.as_scaling.down.max_replicas_percent
          }
        }
      }
    }

    dynamic ""scale_in_control"" {
      for_each = local.as_scaling.in == null ? [] : [""""]
      content {
        time_window_sec = local.as_scaling.in.time_window_sec
        dynamic ""max_scaled_in_replicas"" {
          for_each = (
            local.as_scaling.in.max_replicas_fixed == null &&
            local.as_scaling.in.max_replicas_percent == null
            ? []
            : [""""]
          )
          content {
            fixed   = local.as_scaling.in.max_replicas_fixed
            percent = local.as_scaling.in.max_replicas_percent
          }
        }
      }
    }

    dynamic ""cpu_utilization"" {
      for_each = local.as_signals.cpu_utilization == null ? [] : [""""]
      content {
        target = local.as_signals.cpu_utilization.target
        predictive_method = (
          local.as_signals.cpu_utilization.optimize_availability == true
          ? ""OPTIMIZE_AVAILABILITY""
          : null
        )
      }
    }

    dynamic ""load_balancing_utilization"" {
      for_each = local.as_signals.load_balancing_utilization == null ? [] : [""""]
      content {
        target = local.as_signals.load_balancing_utilization.target
      }
    }

    dynamic ""metric"" {
      for_each = toset(
        local.as_signals.metrics == null ? [] : local.as_signals.metrics
      )
      content {
        name                       = metric.value.name
        type                       = metric.value.type
        target                     = metric.value.target_value
        single_instance_assignment = metric.value.single_instance_assignment
        filter                     = metric.value.time_series_filter
      }
    }

    dynamic ""scaling_schedules"" {
      for_each = toset(
        local.as_signals.schedules == null ? [] : local.as_signals.schedules
      )
      iterator = schedule
      content {
        duration_sec          = schedule.value.duration_sec
        min_required_replicas = schedule.value.min_required_replicas
        name                  = schedule.value.name
        schedule              = schedule.cron_schedule
        description           = schedule.value.description
        disabled              = schedule.value.disabled
        time_zone             = schedule.value.timezone
      }
    }

  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

# tfdoc:file:description Health check resource.

locals {
  hc       = var.health_check_config
  hc_grpc  = try(local.hc.grpc, null) != null
  hc_http  = try(local.hc.http, null) != null
  hc_http2 = try(local.hc.http2, null) != null
  hc_https = try(local.hc.https, null) != null
  hc_ssl   = try(local.hc.ssl, null) != null
  hc_tcp   = try(local.hc.tcp, null) != null
}

resource ""google_compute_health_check"" ""default"" {
  provider            = google-beta
  count               = local.hc != null ? 1 : 0
  project             = var.project_id
  name                = var.name
  description         = local.hc.description
  check_interval_sec  = local.hc.check_interval_sec
  healthy_threshold   = local.hc.healthy_threshold
  timeout_sec         = local.hc.timeout_sec
  unhealthy_threshold = local.hc.unhealthy_threshold

  dynamic ""grpc_health_check"" {
    for_each = local.hc_grpc ? [""""] : []
    content {
      port               = local.hc.grpc.port
      port_name          = local.hc.grpc.port_name
      port_specification = local.hc.grpc.port_specification
      grpc_service_name  = local.hc.grpc.service_name
    }
  }

  dynamic ""http_health_check"" {
    for_each = local.hc_http ? [""""] : []
    content {
      host               = local.hc.http.host
      port               = local.hc.http.port
      port_name          = local.hc.http.port_name
      port_specification = local.hc.http.port_specification
      proxy_header       = local.hc.http.proxy_header
      request_path       = local.hc.http.request_path
      response           = local.hc.http.response
    }
  }

  dynamic ""http2_health_check"" {
    for_each = local.hc_http2 ? [""""] : []
    content {
      host               = local.hc.http.host
      port               = local.hc.http.port
      port_name          = local.hc.http.port_name
      port_specification = local.hc.http.port_specification
      proxy_header       = local.hc.http.proxy_header
      request_path       = local.hc.http.request_path
      response           = local.hc.http.response
    }
  }

  dynamic ""https_health_check"" {
    for_each = local.hc_https ? [""""] : []
    content {
      host               = local.hc.https.host
      port               = local.hc.https.port
      port_name          = local.hc.https.port_name
      port_specification = local.hc.https.port_specification
      proxy_header       = local.hc.https.proxy_header
      request_path       = local.hc.https.request_path
      response           = local.hc.https.response
    }
  }

  dynamic ""ssl_health_check"" {
    for_each = local.hc_ssl ? [""""] : []
    content {
      port               = local.hc.tcp.port
      port_name          = local.hc.tcp.port_name
      port_specification = local.hc.tcp.port_specification
      proxy_header       = local.hc.tcp.proxy_header
      request            = local.hc.tcp.request
      response           = local.hc.tcp.response
    }
  }

  dynamic ""tcp_health_check"" {
    for_each = local.hc_tcp ? [""""] : []
    content {
      port               = local.hc.tcp.port
      port_name          = local.hc.tcp.port_name
      port_specification = local.hc.tcp.port_specification
      proxy_header       = local.hc.tcp.proxy_header
      request            = local.hc.tcp.request
      response           = local.hc.tcp.response
    }
  }

  dynamic ""log_config"" {
    for_each = try(local.hc.enable_logging, null) == true ? [""""] : []
    content {
      enable = true
    }
  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

# tfdoc:file:description Instance-level stateful configuration resources.

resource ""google_compute_per_instance_config"" ""default"" {
  for_each = local.is_regional ? {} : var.stateful_config
  project  = var.project_id
  zone     = var.location
  name     = each.key
  instance_group_manager = try(
    google_compute_instance_group_manager.default.0.name, null
  )
  minimal_action                   = each.value.minimal_action
  most_disruptive_allowed_action   = each.value.most_disruptive_action
  remove_instance_state_on_destroy = each.value.remove_state_on_destroy

  dynamic ""preserved_state"" {
    for_each = each.value.preserved_state == null ? [] : [""""]
    content {
      metadata = each.value.preserved_state.metadata
      dynamic ""disk"" {
        for_each = (
          each.value.preserved_state.disks == null
          ? {}
          : each.value.preserved_state.disks
        )
        content {
          device_name = disk.key
          source      = disk.value.source
          delete_rule = (
            disk.value.delete_on_instance_deletion == true
            ? ""ON_PERMANENT_INSTANCE_DELETION""
            : ""NEVER""
          )
          mode = disk.value.read_only == true ? ""READ_ONLY"" : ""READ_WRITE""
        }
      }
    }
  }
}

resource ""google_compute_region_per_instance_config"" ""default"" {
  for_each = local.is_regional ? var.stateful_config : {}
  project  = var.project_id
  region   = var.location
  name     = each.key
  region_instance_group_manager = try(
    google_compute_region_instance_group_manager.default.0.name, null
  )
  minimal_action                   = each.value.minimal_action
  most_disruptive_allowed_action   = each.value.most_disruptive_action
  remove_instance_state_on_destroy = each.value.remove_state_on_destroy

  dynamic ""preserved_state"" {
    for_each = each.value.preserved_state == null ? [] : [""""]
    content {
      metadata = each.value.preserved_state.metadata
      dynamic ""disk"" {
        for_each = (
          each.value.preserved_state.disks == null
          ? {}
          : each.value.preserved_state.disks
        )
        content {
          device_name = disk.key
          source      = disk.value.source
          delete_rule = (
            disk.value.delete_on_instance_deletion == true
            ? ""ON_PERMANENT_INSTANCE_DELETION""
            : ""NEVER""
          )
          mode = disk.value.read_only == true ? ""READ_ONLY"" : ""READ_WRITE""
        }
      }
    }
  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""autoscaler"" {
  description = ""Auto-created autoscaler resource.""
  value = var.autoscaler_config == null ? null : try(
    google_compute_autoscaler.default.0,
    google_compute_region_autoscaler.default.0,
    {}
  )
}

output ""group_manager"" {
  description = ""Instance group resource.""
  value = try(
    google_compute_instance_group_manager.default.0,
    google_compute_region_instance_group_manager.default.0,
    {}
  )
",
,,,,,
,,,,,
"outpu""","{
  ""userQuery1"": ""The user wants to create a managed instance group in Google Cloud Platform. The instance group can be either regional or zonal, depending on the location specified by the user. The instance group will have a specified target size, and each instance in the group will be created from a specified instance template. The user also wants to specify a set of named ports for the instance group."",
  ""userQuery2"": ""The user wants to apply an auto-healing policy to the instance group. This policy will use a specified health check to determine the health of instances in the group. If an instance fails the health check, it will be automatically repaired. The user also wants to specify a delay period before the auto-healing policy takes effect."",
  ""userQuery3"": ""The user wants to apply an update policy to the instance group. This policy will determine how instances in the group are updated when the instance template is changed. The user wants to specify the minimal",,,,
73,GoogleCloudPlatform,cloud-foundation-fabric,modules/gke-nodepool,"# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

terraform {
  required_version = "">= 1.5.1""
  required_providers {
    google = {
      source  = ""hashicorp/google""
      version = "">= 5.10.0, < 6.0.0"" # tftest
    }
    google-beta = {
      source  = ""hashicorp/google-beta""
      version = "">= 5.10.0, < 6.0.0"" # tftest
    }
  }
}


/**
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""cluster_id"" {
  description = ""Cluster id. Optional, but providing cluster_id is recommended to prevent cluster misconfiguration in some of the edge cases.""
  type        = string
  default     = null
}

variable ""cluster_name"" {
  description = ""Cluster name.""
  type        = string
}

variable ""gke_version"" {
  description = ""Kubernetes nodes version. Ignored if auto_upgrade is set in management_config.""
  type        = string
  default     = null
}

variable ""labels"" {
  description = ""Kubernetes labels applied to each node.""
  type        = map(string)
  default     = {}
  nullable    = false
}

variable ""location"" {
  description = ""Cluster location.""
  type        = string
}

variable ""max_pods_per_node"" {
  description = ""Maximum number of pods per node.""
  type        = number
  default     = null
}

variable ""name"" {
  description = ""Optional nodepool name.""
  type        = string
  default     = null
}

variable ""node_config"" {
  description = ""Node-level configuration.""
  type = object({
    boot_disk_kms_key   = optional(string)
    disk_size_gb        = optional(number)
    disk_type           = optional(string)
    ephemeral_ssd_count = optional(number)
    gcfs                = optional(bool, false)
    guest_accelerator = optional(object({
      count = number
      type  = string
      gpu_driver = optional(object({
        version                    = string
        partition_size             = optional(string)
        max_shared_clients_per_gpu = optional(number)
      }))
    }))
    local_nvme_ssd_count = optional(number)
    gvnic                = optional(bool, false)
    image_type           = optional(string)
    kubelet_config = optional(object({
      cpu_manager_policy   = string
      cpu_cfs_quota        = optional(bool)
      cpu_cfs_quota_period = optional(string)
      pod_pids_limit       = optional(number)
    }))
    linux_node_config = optional(object({
      sysctls     = optional(map(string))
      cgroup_mode = optional(string)
    }))
    local_ssd_count       = optional(number)
    machine_type          = optional(string)
    metadata              = optional(map(string))
    min_cpu_platform      = optional(string)
    preemptible           = optional(bool)
    sandbox_config_gvisor = optional(bool)
    shielded_instance_config = optional(object({
      enable_integrity_monitoring = optional(bool)
      enable_secure_boot          = optional(bool)
    }))
    spot                          = optional(bool)
    workload_metadata_config_mode = optional(string)
  })
  default = {
    disk_type = ""pd-balanced""
  }
  validation {
    condition = (
      alltrue([
        for k, v in try(var.node_config.guest_accelerator[0].gpu_driver, {}) : contains([
          ""GPU_DRIVER_VERSION_UNSPECIFIED"", ""INSTALLATION_DISABLED"",
          ""DEFAULT"", ""LATEST""
        ], v.version)
      ])
    )
    error_message = ""Invalid GPU driver version.""
  }
}

variable ""node_count"" {
  description = ""Number of nodes per instance group. Initial value can only be changed by recreation, current is ignored when autoscaling is used.""
  type = object({
    current = optional(number)
    initial = number
  })
  default = {
    initial = 1
  }
  nullable = false
}

variable ""node_locations"" {
  description = ""Node locations.""
  type        = list(string)
  default     = null
}

variable ""nodepool_config"" {
  description = ""Nodepool-level configuration.""
  type = object({
    autoscaling = optional(object({
      location_policy = optional(string)
      max_node_count  = optional(number)
      min_node_count  = optional(number)
      use_total_nodes = optional(bool, false)
    }))
    management = optional(object({
      auto_repair  = optional(bool)
      auto_upgrade = optional(bool)
    }))
    # placement_policy = optional(bool)
    upgrade_settings = optional(object({
      max_surge       = number
      max_unavailable = number
    }))
  })
  default = null
}

variable ""pod_range"" {
  description = ""Pod secondary range configuration.""
  type = object({
    secondary_pod_range = object({
      name                 = string
      cidr                 = optional(string)
      create               = optional(bool)
      enable_private_nodes = optional(bool)
    })
  })
  default = null
}

variable ""project_id"" {
  description = ""Cluster project id.""
  type        = string
}

variable ""reservation_affinity"" {
  description = ""Configuration of the desired reservation which instances could take capacity from.""
  type = object({
    consume_reservation_type = string
    key                      = optional(string)
    values                   = optional(list(string))
  })
  default = null
}

variable ""service_account"" {
  description = ""Nodepool service account. If this variable is set to null, the default GCE service account will be used. If set and email is null, a service account will be created. If scopes are null a default will be used.""
  type = object({
    create       = optional(bool, false)
    email        = optional(string)
    oauth_scopes = optional(list(string))
  })
  default  = {}
  nullable = false
}

variable ""sole_tenant_nodegroup"" {
  description = ""Sole tenant node group.""
  type        = string
  default     = null
}

variable ""tags"" {
  description = ""Network tags applied to nodes.""
  type        = list(string)
  default     = null
}

variable ""taints"" {
  description = ""Kubernetes taints applied to all nodes.""
  type = map(object({
    value  = string
    effect = string
  }))
  nullable = false
  default  = {}
  validation {
    condition = alltrue([
      for k, v in var.taints :
      contains([""NO_SCHEDULE"", ""PREFER_NO_SCHEDULE"", ""NO_EXECUTE""], v.effect)
    ])
    error_message = ""Invalid taint effect.""
  }
}


/**
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

locals {
  _image = coalesce(var.node_config.image_type, ""-"")
  image = {
    is_cos = length(regexall(""COS"", local._image)) > 0
    is_cos_containerd = (
      var.node_config.image_type == null
      ||
      length(regexall(""COS_CONTAINERD"", local._image)) > 0
    )
    is_win = length(regexall(""WIN"", local._image)) > 0
  }
  node_metadata = var.node_config.metadata == null ? null : merge(
    var.node_config.metadata,
    { disable-legacy-endpoints = ""true"" }
  )
  # if no attributes passed for service account, use the GCE default
  # if no email specified, create service account
  service_account_email = (
    var.service_account.create
    ? google_service_account.service_account[0].email
    : var.service_account.email
  )
  service_account_scopes = (
    var.service_account.oauth_scopes != null
    ? var.service_account.oauth_scopes
    : [
      ""https://www.googleapis.com/auth/devstorage.read_only"",
      ""https://www.googleapis.com/auth/logging.write"",
      ""https://www.googleapis.com/auth/monitoring"",
      ""https://www.googleapis.com/auth/monitoring.write"",
      ""https://www.googleapis.com/auth/userinfo.email""
    ]
  )
  taints = merge(var.taints, !local.image.is_win ? {} : {
    ""node.kubernetes.io/os"" = {
      value  = ""windows""
      effect = ""NO_EXECUTE""
    }
  })
}

resource ""google_service_account"" ""service_account"" {
  count   = var.service_account.create ? 1 : 0
  project = var.project_id
  account_id = (
    var.service_account.email != null
    ? split(""@"", var.service_account.email)[0]
    : ""tf-gke-${var.name}""
  )
  display_name = ""Terraform GKE ${var.cluster_name} ${var.name}.""
}

resource ""google_container_node_pool"" ""nodepool"" {
  provider           = google-beta
  project            = var.project_id
  cluster            = coalesce(var.cluster_id, var.cluster_name)
  location           = var.location
  name               = var.name
  version            = var.gke_version
  max_pods_per_node  = var.max_pods_per_node
  initial_node_count = var.node_count.initial
  node_count         = var.node_count.current
  node_locations     = var.node_locations
  # placement_policy   = var.nodepool_config.placement_policy

  dynamic ""autoscaling"" {
    for_each = (
      try(var.nodepool_config.autoscaling, null) != null
      &&
      !try(var.nodepool_config.autoscaling.use_total_nodes, false)
      ? [""""] : []
    )
    content {
      location_policy = try(var.nodepool_config.autoscaling.location_policy, null)
      max_node_count  = try(var.nodepool_config.autoscaling.max_node_count, null)
      min_node_count  = try(var.nodepool_config.autoscaling.min_node_count, null)
    }
  }
  dynamic ""autoscaling"" {
    for_each = (
      try(var.nodepool_config.autoscaling.use_total_nodes, false) ? [""""] : []
    )
    content {
      location_policy      = try(var.nodepool_config.autoscaling.location_policy, null)
      total_max_node_count = try(var.nodepool_config.autoscaling.max_node_count, null)
      total_min_node_count = try(var.nodepool_config.autoscaling.min_node_count, null)
    }
  }

  dynamic ""management"" {
    for_each = try(var.nodepool_config.management, null) != null ? [""""] : []
    content {
      auto_repair  = try(var.nodepool_config.management.auto_repair, null)
      auto_upgrade = try(var.nodepool_config.management.auto_upgrade, null)
    }
  }

  dynamic ""network_config"" {
    for_each = var.pod_range != null ? [""""] : []
    content {
      create_pod_range     = var.pod_range.secondary_pod_range.create
      enable_private_nodes = var.pod_range.secondary_pod_range.enable_private_nodes
      pod_ipv4_cidr_block  = var.pod_range.secondary_pod_range.cidr
      pod_range            = var.pod_range.secondary_pod_range.name
    }
  }

  dynamic ""upgrade_settings"" {
    for_each = try(var.nodepool_config.upgrade_settings, null) != null ? [""""] : []
    content {
      max_surge       = try(var.nodepool_config.upgrade_settings.max_surge, null)
      max_unavailable = try(var.nodepool_config.upgrade_settings.max_unavailable, null)
    }
  }

  node_config {
    boot_disk_kms_key = var.node_config.boot_disk_kms_key
    disk_size_gb      = var.node_config.disk_size_gb
    disk_type         = var.node_config.disk_type
    image_type        = var.node_config.image_type
    labels            = var.labels
    local_ssd_count   = var.node_config.local_ssd_count
    machine_type      = var.node_config.machine_type
    metadata          = local.node_metadata
    min_cpu_platform  = var.node_config.min_cpu_platform
    node_group        = var.sole_tenant_nodegroup
    oauth_scopes      = local.service_account_scopes
    preemptible       = var.node_config.preemptible
    service_account   = local.service_account_email
    spot = (
      var.node_config.spot == true && var.node_config.preemptible != true
    )
    tags = var.tags

    dynamic ""ephemeral_storage_config"" {
      for_each = var.node_config.ephemeral_ssd_count != null ? [""""] : []
      content {
        local_ssd_count = var.node_config.ephemeral_ssd_count
      }
    }
    dynamic ""gcfs_config"" {
      for_each = var.node_config.gcfs && local.image.is_cos_containerd ? [""""] : []
      content {
        enabled = true
      }
    }
    dynamic ""guest_accelerator"" {
      for_each = var.node_config.guest_accelerator != null ? [""""] : []
      content {
        count              = var.node_config.guest_accelerator.count
        type               = var.node_config.guest_accelerator.type
        gpu_partition_size = var.node_config.guest_accelerator.gpu_driver == null ? null : var.node_config.guest_accelerator.gpu_driver.partition_size

        dynamic ""gpu_sharing_config"" {
          for_each = try(var.node_config.guest_accelerator.gpu_driver.max_shared_clients_per_gpu, null) != null ? [""""] : []
          content {
            gpu_sharing_strategy       = var.node_config.guest_accelerator.gpu_driver.max_shared_clients_per_gpu != null ? ""TIME_SHARING"" : null
            max_shared_clients_per_gpu = var.node_config.guest_accelerator.gpu_driver.max_shared_clients_per_gpu
          }
        }

        dynamic ""gpu_driver_installation_config"" {
          for_each = var.node_config.guest_accelerator.gpu_driver != null ? [""""] : []
          content {
            gpu_driver_version = var.node_config.guest_accelerator.gpu_driver.version
          }
        }
      }
    }
    dynamic ""local_nvme_ssd_block_config"" {
      for_each = coalesce(var.node_config.local_nvme_ssd_count, 0) > 0 ? [""""] : []
      content {
        local_ssd_count = var.node_config.local_nvme_ssd_count
      }
    }
    dynamic ""gvnic"" {
      for_each = var.node_config.gvnic && local.image.is_cos ? [""""] : []
      content {
        enabled = true
      }
    }
    dynamic ""kubelet_config"" {
      for_each = var.node_config.kubelet_config != null ? [""""] : []
      content {
        cpu_manager_policy   = var.node_config.kubelet_config.cpu_manager_policy
        cpu_cfs_quota        = var.node_config.kubelet_config.cpu_cfs_quota
        cpu_cfs_quota_period = var.node_config.kubelet_config.cpu_cfs_quota_period
        pod_pids_limit       = var.node_config.kubelet_config.pod_pids_limit
      }
    }
    dynamic ""linux_node_config"" {
      for_each = var.node_config.linux_node_config != null ? [""""] : []
      content {
        sysctls     = var.node_config.linux_node_config.sysctls
        cgroup_mode = try(var.node_config.linux_node_config.cgroup_mode, ""CGROUP_MODE_UNSPECIFIED"")
      }
    }
    dynamic ""reservation_affinity"" {
      for_each = var.reservation_affinity != null ? [""""] : []
      content {
        consume_reservation_type = var.reservation_affinity.consume_reservation_type
        key                      = var.reservation_affinity.key
        values                   = var.reservation_affinity.values
      }
    }
    dynamic ""sandbox_config"" {
      for_each = (
        var.node_config.sandbox_config_gvisor == true &&
        local.image.is_cos_containerd != null
        ? [""""]
        : []
      )
      content {
        sandbox_type = ""gvisor""
      }
    }
    dynamic ""shielded_instance_config"" {
      for_each = var.node_config.shielded_instance_config != null ? [""""] : []
      content {
        enable_secure_boot          = var.node_config.shielded_instance_config.enable_secure_boot
        enable_integrity_monitoring = var.node_config.shielded_instance_config.enable_integrity_monitoring
      }
    }
    dynamic ""taint"" {
      for_each = local.taints
      content {
        key    = taint.key
        value  = taint.value.value
        effect = taint.value.effect
      }
    }
    dynamic ""workload_metadata_config"" {
      for_each = var.node_config.workload_metadata_config_mode != null ? [""""] : []
      content {
        mode = var.node_config.workload_metadata_config_mode
      }
    }
  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""id"" {
  description = ""Fully qualified nodepool id.""
  value       = google_container_node_pool.nodepool.id
}

output ""name"" {
  description = ""Nodepool name.""
  value       = google_container_node_pool.nodepool.name
}

output ""service_account_email"" {
  description = ""Service account email.""
  value       = local.service_account_email
}

output ""service_account_iam_email"" {
  description = ""Service account email.""
  value = format(
    ""serviceAccount:%s"",
    local.service_account_email == null ? """" : local.service_account_email
  )
}


","{
  ""userQuery1"": ""The user wants to create a Google Kubernetes Engine (GKE) cluster with a specific version and provider source. The user also wants to specify the required version of Terraform and the version of the Google provider."",
  ""userQuery2"": ""The user wants to define a set of variables for the GKE cluster, such as the cluster id, cluster name, Kubernetes nodes version, Kubernetes labels, cluster location, maximum number of pods per node, nodepool name, node-level configuration, number of nodes per instance group, node locations, nodepool-level configuration, pod secondary range configuration, cluster project id, reservation affinity, nodepool service account, sole tenant node group, network tags, and Kubernetes taints."",
  ""userQuery3"": ""The user wants to create a service account for the GKE cluster and define the node pool for the cluster with specific configurations such as autoscaling, management, network configuration, upgrade settings, and node configurations."
74,airbnb,streamalert,streamalert_cli/_infrastructure/modules/tf_scheduled_queries,"/*
 *
 */
variable ""prefix"" {
  description = ""Namespace under which all AWS resources are named""
  type        = string
}

variable ""destination_kinesis_stream"" {
  description = ""The name of the target Kinesis stream, NOT the full ARN""
  type        = string
}

/*
 * The AWS Account Id is used to generate the ARN of various resources. This configuration
 * ASSUMES that both the Athena and Kinesis streams being accessed belong to the same AWS acccount
 * that StreamQuery is being deployed to.
 */
variable ""account_id"" {
  description = ""The AWS Account Id that StreamQuery is deployed to""
  type        = string
}

variable ""region"" {
  description = ""The AWS Region that StreamQuery is deployed to""
  type        = string
}

variable ""athena_database"" {
  description = ""The target Athena database to query""
  type        = string
}

variable ""athena_results_bucket"" {
  description = ""The destination S3 bucket where Athena query results are saved""
  type        = string
}

variable ""athena_s3_buckets"" {
  description = ""A list of S3 bucket names that the target Athena is built over""
  type        = list(string)
}

variable ""sfn_timeout_secs"" {
  description = ""The maximum time in seconds a state machine will run""
  type        = number
}

variable ""sfn_wait_secs"" {
  description = ""The time interval in seconds to wait between checking whether Athena queries are complete""
  type        = number
}

variable ""query_packs"" {
  description = ""The configuration of each query pack""
  default     = []

  /*
   * The structure of each item in this list is a dictionary with 3 keys:
   *  - name: Name of the query pack. This is passed to the cloudwatch event as a tag
   *  - schedule_expression: CloudWatch event schedule expression (e.g. ""rate(1 hour)"")
   *  - description: A string describing the query pack

  default = [
    {
      ""name"": ""sample"",
      ""schedule_expression"": ""rate(1 hour)"",
      ""description"": ""Placeholder""
    }
  ]

  */
}


#
# Below are all variables proxied to the Lambda module that builds the StreamQuery lambda function
#
variable ""lambda_handler"" {}

variable ""lambda_concurrency_limit"" {
  default = -1
}

variable ""lambda_log_level"" {
  description = ""logging level for the lambda function""
  type        = string
  default     = ""info""
}

/*
 * Due to StreamQuery being designed to run in small bursts of nonblocking operations, this
 * value can be intentionally set low.  Something like 30 seconds should be enough.
 */
variable ""lambda_timeout"" {
  description = ""The timeout in seconds for the StreamQuery lambda""
  type        = number
  default     = 30
}

/*
 * StreamQuery is not a particularly CPU intensive system as it delegates the majority of work
 * to AWS Athena. Currently 128 MB seems to be plenty.
 */
variable ""lambda_memory"" {
  description = ""The memory in megabytes allocated to the StreamQuery lambda function""
  type        = number
  default     = 128
}

variable ""lambda_log_retention_days"" {
  description = ""Number of days to retain CloudWatch logs for the Lambda function""
  type        = number
  default     = 14
}

variable ""lambda_alarms_enabled"" {
  description = ""Whether or not Alarms are enabled""
  type        = string
  default     = true
}

variable ""lambda_alarm_actions"" {
  description = ""List of ARNS""
  default     = []
}

variable ""lambda_error_threshold"" {
  description = ""The number of lambda errors tolerated within the error period before an Alarm triggers""
  type        = number
  default     = 1
}

variable ""lambda_error_period_secs"" {
  description = ""The number of seconds for each Lambda function error period""
  type        = number
  default     = 3600
}

variable ""lambda_error_evaluation_periods"" {
  type    = number
  default = 2
}


/*
 * iam_roles
 *
 *
 *
 *   This file houses all IAM policies relevant to StreamAlert scheduled queries
 *
 *
 *
 * Permissions for Lambda -> Athena, Kinesis, and other stuff
 *
 *   Notably, because we use a reusable Lambda module for the Lambda function, it automatically
 *   creates the IAM Role
 */

# Attach additional permissions to the auto-generated Lambda IAM Role
resource ""aws_iam_role_policy"" ""lambda_permissions"" {
  name   = ""LambdaRequiredPermissions""
  role   = module.scheduled_queries_lambda.role_id
  policy = data.aws_iam_policy_document.lambda_permissions.json
}

# All of the relevant permissions to the StreamQuery Lambda function
data ""aws_iam_policy_document"" ""lambda_permissions"" {
  # Grant Lambda function access to AWS Athena (more complicated than it sounds)
  statement {
    sid    = ""AllowLambdaToAccessAthenaService""
    effect = ""Allow""
    actions = [
      ""athena:StartQueryExecution"",
      ""athena:GetQueryExecution"",
      ""athena:GetQueryResults"",
    ]
    resources = [
      ""arn:aws:athena:${var.region}:${var.account_id}:workgroup/primary"",
    ]
  }

  statement {
    sid    = ""AllowLambdaToAccessAthenaGlue""
    effect = ""Allow""
    actions = [
      ""glue:GetTable"",
      ""glue:GetDatabase"",
      ""glue:GetPartition"",
      ""glue:GetPartitions"",
    ]
    resources = local.athena_glue_resources
  }
  statement {
    sid    = ""AllowLambdaToWriteToAthenaQueryResultsS3Bucket""
    effect = ""Allow""
    actions = [
      ""s3:GetBucketLocation"",
      ""s3:GetObject"",
      ""s3:ListBucket"",
      ""s3:ListBucketMultipartUploads"",
      ""s3:ListMultipartUploadParts"",
      ""s3:AbortMultipartUpload"",
      ""s3:CreateBucket"",
      ""s3:PutObject"",
    ]
    resources = [
      ""arn:aws:s3:::${var.athena_results_bucket}"",
      ""arn:aws:s3:::${var.athena_results_bucket}/*"",
    ]
  }
  statement {
    sid    = ""AllowLambdaToReadFromAthenaS3Buckets""
    effect = ""Allow""
    actions = [
      ""s3:GetObject"",
      ""s3:ListBucket"",
    ]
    resources = local.athena_s3_resources
  }

  # Grant Lambda function to write to AWS Kinesis
  statement {
    sid    = ""AllowLambdaToWriteToKinesis""
    effect = ""Allow""
    actions = [
      ""kinesis:PutRecord*"",
      ""kinesis:ListStreams"",
      ""kinesis:DescribeStream"",
    ]
    resources = [
      ""arn:aws:kinesis:${var.region}:${var.account_id}:stream/${var.destination_kinesis_stream}"",
    ]
  }
}

/*
 * IAM Roles and Permissions for StepFunction -> Lambda
 */

# Setup the IAM Role for the Step Functions
resource ""aws_iam_role"" ""iam_for_step_functions"" {
  name               = ""${var.prefix}_streamalert_scheduled_queries_state_machines""
  path               = ""/streamalert/""
  assume_role_policy = data.aws_iam_policy_document.iam_step_function_assume_role.json

  tags = {
    Name = ""StreamAlert""
  }
}

# Only allow Step Functions to assume this role
data ""aws_iam_policy_document"" ""iam_step_function_assume_role"" {
  statement {
    effect  = ""Allow""
    actions = [""sts:AssumeRole""]
    principals {
      type = ""Service""
      identifiers = [
        ""states.${var.region}.amazonaws.com"",
      ]
    }
  }
}

# Attach an additional policy to the IAM Role
resource ""aws_iam_role_policy"" ""stepfunction_permissions"" {
  name   = ""StepFunctionsInvokeLambda""
  role   = aws_iam_role.iam_for_step_functions.id
  policy = data.aws_iam_policy_document.stepfunction_permissions.json
}

# Permission for StepFunctions to invoke the Lambda function
data ""aws_iam_policy_document"" ""stepfunction_permissions"" {
  # Grant Step Function permission to invoke the Lambda
  statement {
    sid    = ""AllowStateMachineToInvokeLambdaFunction""
    effect = ""Allow""
    actions = [
      ""lambda:InvokeFunction"",
    ]
    resources = [
      module.scheduled_queries_lambda.function_alias_arn,
    ]
  }
}

/*
 * IAM Roles and Permissions for CloudWatch -> Step Functions
 */

# Setup the IAM Role
resource ""aws_iam_role"" ""iam_for_cloudwatch_schedule"" {
  name               = ""${var.prefix}_streamalert_scheduled_queries_cloudwatch_schedule""
  path               = ""/streamalert/""
  assume_role_policy = data.aws_iam_policy_document.iam_cloudwatch_assume_role.json

  tags = {
    Name = ""StreamAlert""
  }
}

# Only allow cloudwatch to assume this role
data ""aws_iam_policy_document"" ""iam_cloudwatch_assume_role"" {
  statement {
    effect  = ""Allow""
    actions = [""sts:AssumeRole""]
    principals {
      type = ""Service""
      identifiers = [
        ""events.amazonaws.com"",
      ]
    }
  }
}

# Attach additional permissions to the IAM Role
resource ""aws_iam_role_policy"" ""cloudwatch_schedule_permissions"" {
  name   = ""StepFunctionsStartViaCWE""
  role   = aws_iam_role.iam_for_cloudwatch_schedule.id
  policy = data.aws_iam_policy_document.cloudwatch_schedule_permission.json
}

# Permission to execute states:StartExecution
data ""aws_iam_policy_document"" ""cloudwatch_schedule_permission"" {
  statement {
    sid = ""AllowCloudWatchScheduleToStartStepFunction""
    actions = [
      ""states:StartExecution"",
    ]
    resources = [
      aws_sfn_state_machine.state_machine.id,
    ]
  }
}

locals {
  # A list of all S3 bucket ARNs and ARN/*'s that the target Athena is built over
  athena_s3_resources = concat(
    formatlist(""arn:aws:s3:::%s"", var.athena_s3_buckets),
    formatlist(""arn:aws:s3:::%s/*"", var.athena_s3_buckets),
  )

  # A list of all glue ARNs that the Athena is built over
  athena_glue_resources = [
    ""arn:aws:glue:${var.region}:${var.account_id}:catalog"",
    ""arn:aws:glue:${var.region}:${var.account_id}:database/${var.athena_database}"",
    ""arn:aws:glue:${var.region}:${var.account_id}:table/${var.athena_database}/*"",
  ]
}


module ""scheduled_queries_lambda"" {
  source = ""../tf_lambda""

  function_name = ""${var.prefix}_streamalert_scheduled_queries_runner""
  description   = ""Lambda function that powers StreamQuery, StreamAlert's scheduled query service""
  runtime       = ""python3.7""
  handler       = var.lambda_handler

  memory_size_mb = var.lambda_memory
  timeout_sec    = var.lambda_timeout

  concurrency_limit = var.lambda_concurrency_limit

  environment_variables = {
    REGION                = var.region
    ATHENA_DATABASE       = var.athena_database
    ATHENA_RESULTS_BUCKET = var.athena_results_bucket
    KINESIS_STREAM        = var.destination_kinesis_stream
    LOGGER_LEVEL          = var.lambda_log_level
  }

  tags = {
    Subcomponent = ""StreamQuery""
  }

  auto_publish_versions = true

  log_retention_days = var.lambda_log_retention_days
  alarm_actions      = var.lambda_alarm_actions

  errors_alarm_enabled            = var.lambda_alarms_enabled
  errors_alarm_evaluation_periods = var.lambda_error_evaluation_periods
  errors_alarm_period_secs        = var.lambda_error_period_secs
  errors_alarm_threshold          = var.lambda_error_threshold
}


/*
 * Builds the StepFunction that powers most of StreamQuery
 * https://www.terraform.io/docs/providers/aws/r/sfn_state_machine.html
 */
resource ""aws_sfn_state_machine"" ""state_machine"" {
  name = ""${var.prefix}_streamalert_scheduled_queries_state_machine""

  role_arn = aws_iam_role.iam_for_step_functions.arn

  # This state machine is largely inspired by the ""job poller"" pattern:
  # https://docs.aws.amazon.com/step-functions/latest/dg/sample-project-job-poller.html
  definition = <<EOF
{
  ""Comment"": ""State Machine definition for StreamAlert scheduled queries"",
  ""StartAt"": ""RunFunction"",
  ""TimeoutSeconds"": ${var.sfn_timeout_secs},
  ""States"": {
    ""RunFunction"": {
      ""Comment"":  ""Call the scheduled queries lambda function to start queries and to report on their statuses"",
      ""Type"": ""Task"",
      ""Resource"": ""${module.scheduled_queries_lambda.function_alias_arn}"",
      ""Next"": ""CheckIfDone"",
      ""TimeoutSeconds"": 60
    },
    ""CheckIfDone"": {
      ""Comment"":  ""Depending on the return value of the Lambda, move to done or retry"",
      ""Type"": ""Choice"",
      ""Choices"": [
        {
          ""Variable"": ""$.done"",
          ""NumericEquals"": 1,
          ""Next"": ""Done""
        },
        {
          ""Variable"": ""$.continue"",
          ""NumericEquals"": 1,
          ""Next"": ""Wait""
        }
      ],
      ""Default"": ""FatalError""
    },
    ""Wait"": {
      ""Comment"": ""Not all queries are completed; this state waits for a specified duration before checking again"",
      ""Type"": ""Wait"",
      ""Seconds"": ${var.sfn_wait_secs},
      ""Next"": ""RunFunction""
    },
    ""Done"": {
      ""Comment"": ""All queries have completed"",
      ""Type"": ""Pass"",
      ""Result"": {
        ""message"": ""StreamQuery Execution completed""
      },
      ""ResultPath"": ""$.System"",
      ""End"": true
    },
    ""FatalError"": {
      ""Comment"": ""Something went wrong that caused the scheduled queries Lambda function to not return properly"",
      ""Type"": ""Fail"",
      ""Cause"": ""Something invalid happened"",
      ""Error"": ""StreamAlert scheduled query execution failed permanently""
    }
  }
}
EOF

  tags = {
    Name = ""StreamAlert""
  }

}


/*
 * CloudWatch schedules
 */
resource ""aws_cloudwatch_event_rule"" ""event"" {
  count = length(var.query_packs)

  name                = ""${var.prefix}_streamalert_scheduled_queries_event_${count.index}""
  description         = var.query_packs[count.index].description
  schedule_expression = var.query_packs[count.index].schedule_expression

  tags = {
    Name = ""StreamAlert""
  }
}

resource ""aws_cloudwatch_event_target"" ""run_step_function"" {
  count = length(var.query_packs)

  rule     = aws_cloudwatch_event_rule.event[count.index].name
  arn      = aws_sfn_state_machine.state_machine.id
  role_arn = aws_iam_role.iam_for_cloudwatch_schedule.arn

  /*
   * The input transformer takes the CloudWatch event, which looks something like this...
   *   {
   *     ""version"": ""0"",
   *     ""id"": ""91190ee0-a078-9c42-15b6-f3d418fae67d"",
   *     ""detail-type"": ""Scheduled Event"",
   *     ""source"": ""aws.events"",
   *     ""account"": ""123456789012"",
   *     ""time"": ""2019-06-14T18:39:21Z"",
   *     ""region"": ""us-east-1"",
   *     ""resources"": [
   *       ""arn:aws:events:us-east-1:123456789012:rule/something_streamalert_schedule_hourly""
   *     ],
   *     ""detail"": {}
   *   }
   *
   * And transforms it into something more like this:
   *   {
   *     ""name"": ""streamalert_scheduled_queries_cloudwatch_trigger"",
   *     ""event_id"": ""9119abcd-abcd-abcd-abcd-f3d418fae67d"",
   *     ""source_arn"": ""arn:aws:events:us-east-1:123456789012:rule/something_streamalert_scheduled_queries"",
   *     ""function_start_time"": ""2019-06-14T18:39:21Z"",
   *     ""tags"": [""tag1"", ""tag2""]
   *   }
   */
  input_transformer {
    input_paths = {
      time       = ""$.time""
      id         = ""$.id""
      source_arn = ""$.resources[0]""
    }
    input_template = <<JSON
{
  ""name"": ""streamalert_scheduled_queries_cloudwatch_trigger"",
  ""event_id"": <id>,
  ""source_arn"": <source_arn>,
  ""streamquery_configuration"": {
    ""clock"": <time>,
    ""tags"": [""${var.query_packs[count.index].name}""]
  }
}
JSON

  }
}


# Role id of the lambda function that runs scheduled queries
output ""lambda_function_role_id"" {
  value = module.scheduled_queries_lambda.role_id
}

","{
  ""userQuery1"": ""The user needs a system to manage scheduled queries in AWS. The system should be able to start queries, check their statuses, and handle errors. The system should also be able to wait for a specified duration before checking the status of the queries again."",
  ""userQuery2"": ""The user needs to set up AWS resources such as Lambda functions, Step Functions, and CloudWatch events. The Lambda function should have access to AWS Athena and Kinesis, and it should be able to write to a specified S3 bucket. The Step Function should be able to invoke the Lambda function, and the CloudWatch event should be able to start the Step Function."",
  ""userQuery3"": ""The user needs to set up IAM roles and permissions for the Lambda function, Step Function, and CloudWatch event. The Lambda function should have permissions to access Athena, Glue, and S3, and to write to Kinesis. The Step Function should have permission to"
75,cncf,demo,provisioning/aws/modules/security,"variable ""allow_ssh_cidr"" {}
variable ""vpc_cidr"" {}
variable ""name"" {}
variable ""vpc_id"" {}

output ""bastion_id"" { value = ""${ aws_security_group.bastion.id }"" }
output ""etcd_id"" { value = ""${ aws_security_group.etcd.id }"" }
output ""external_elb_id"" { value = ""${ aws_security_group.external_elb.id }"" }
output ""worker_id"" { value = ""${ aws_security_group.worker.id }"" }


resource ""aws_security_group"" ""bastion"" {
  description = ""k8s bastion security group""

  egress = {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    cidr_blocks = [ ""0.0.0.0/0"" ]
  }

  ingress = {
    from_port = 22
    to_port = 22
    protocol = ""tcp""
    cidr_blocks = [ ""${ var.allow_ssh_cidr }"" ]
  }

  name = ""bastion-k8s-${ var.name }""

  tags {
    KubernetesCluster = ""${ var.name }""
    Name = ""bastion-k8s-${ var.name }""
    builtWith = ""terraform""
  }

  vpc_id = ""${ var.vpc_id }""
}

resource ""aws_security_group"" ""etcd"" {
  description = ""k8s etcd security group""

  egress = {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    /*self = true*/
    cidr_blocks = [ ""0.0.0.0/0"" ]
  }

  ingress = {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    self = true
    cidr_blocks = [ ""${ var.vpc_cidr }"" ]
  }

  name = ""etcd-k8s-${ var.name }""

  tags {
    KubernetesCluster = ""${ var.name }""
    Name = ""etcd-k8s-${ var.name }""
    builtWith = ""terraform""
  }

  vpc_id = ""${ var.vpc_id }""
}

resource ""aws_security_group"" ""external_elb"" {
  description = ""k8s-${ var.name } master (apiserver) external elb""

  egress {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    /*cidr_blocks = [ ""${ var.vpc_cidr }"" ]*/
    security_groups = [ ""${ aws_security_group.etcd.id }"" ]
  }

  ingress {
    from_port = -1
    to_port = -1
    protocol = ""icmp""
    cidr_blocks = [ ""0.0.0.0/0"" ]
  }

  ingress {
    from_port = 443
    to_port   = 443
    protocol  = ""tcp""
    cidr_blocks = [ ""0.0.0.0/0"" ]
  }

  name = ""master-external-elb-k8s-${ var.name }""

  tags {
    KubernetesCluster = ""${ var.name }""
    Name = ""master-external-elb-k8s-${ var.name }""
    builtWith = ""terraform""
  }

  vpc_id = ""${ var.vpc_id }""
}

resource ""aws_security_group"" ""worker"" {
  description = ""k8s worker security group""

  egress = {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    /*self = true*/
    cidr_blocks = [ ""0.0.0.0/0"" ]
  }

  ingress = {
    from_port = 0
    to_port = 0
    protocol = ""-1""
    self = true
    cidr_blocks = [ ""${ var.vpc_cidr }"" ]
  }

  name = ""worker-k8s-${ var.name }""

  tags {
    KubernetesCluster = ""${ var.name }""
    Name = ""worker-k8s-${ var.name }""
    builtWith = ""terraform""
  }

  vpc_id = ""${ var.vpc_id }""
}


","{
  ""userQuery1"": ""The user wants to create a Kubernetes cluster in an AWS environment. The cluster name should be customizable."",
  ""userQuery2"": ""The user needs to set up four different security groups within a specified Virtual Private Cloud (VPC). The VPC ID should be customizable. The security groups are: 'bastion', 'etcd', 'external_elb', and 'worker'. Each security group should have its own set of ingress and egress rules, and should be tagged with the Kubernetes cluster name, its own name, and the tool used for creation (Terraform)."",
  ""userQuery3"": ""The user wants to allow SSH access to the 'bastion' security group from a customizable CIDR block. The 'etcd' and 'worker' security groups should allow all traffic from within the VPC. The 'external_elb' security group should allow ICMP and HTTPS traffic from any source."",
  ""userQuery4"":"
76,apparentlymart,terraform,terraform/testdata/static-validate-refs,"terraform {
  required_providers {
    boop = {
      source = ""foobar/beep"" # intentional mismatch between local name and type
    }
  }
}

resource ""aws_instance"" ""no_count"" {
}

resource ""aws_instance"" ""count"" {
  count = 1
}

resource ""boop_instance"" ""yep"" {
}

resource ""boop_whatever"" ""nope"" {
}


","{
  ""userQuery1"": ""The user needs to create an AWS instance without specifying the number of instances to be created."",
  ""userQuery2"": ""The user intends to create another AWS instance, this time specifying that only one instance should be created."",
  ""userQuery3"": ""The user requires the creation of instances using a provider named 'boop', which is sourced from 'foobar/beep'. Two types of 'boop' instances are needed: 'boop_instance' and 'boop_whatever'.""
}"
77,ashinohara,terraform-provider-aws,examples/networking/subnet,"../numbering/variables.tf

variable ""vpc_id"" {}

variable ""availability_zone"" {}

data ""aws_availability_zone"" ""target"" {
  name = ""${var.availability_zone}""
}

data ""aws_vpc"" ""target"" {
  id = ""${var.vpc_id}""
}


resource ""aws_security_group"" ""az"" {
  name        = ""az-${data.aws_availability_zone.target.name}""
  description = ""Open access within the AZ ${data.aws_availability_zone.target.name}""
  vpc_id      = ""${var.vpc_id}""

  ingress {
    from_port   = 0
    to_port     = 0
    protocol    = -1
    cidr_blocks = [""${aws_subnet.main.cidr_block}""]
  }
}


resource ""aws_subnet"" ""main"" {
  cidr_block = ""${cidrsubnet(data.aws_vpc.target.cidr_block, 4, lookup(var.az_numbers, data.aws_availability_zone.target.name_suffix))}""
  vpc_id     = ""${var.vpc_id}""
  availability_zone = ""${var.availability_zone}""
}

resource ""aws_route_table"" ""main"" {
  vpc_id = ""${var.vpc_id}""
}

resource ""aws_route_table_association"" ""main"" {
  subnet_id      = ""${aws_subnet.main.id}""
  route_table_id = ""${aws_route_table.main.id}""
}


output ""subnet_id"" {
  value = ""${aws_subnet.main.id}""
}


","{
  ""userQuery1"": ""The user needs to specify a Virtual Private Cloud (VPC) in which they want to create resources. The ID of this VPC is required as an input."",
  ""userQuery2"": ""The user wants to create a subnet within the specified VPC. The subnet should be in a specific availability zone, which is also required as an input. The CIDR block for the subnet is calculated based on the CIDR block of the VPC and a lookup table of availability zone numbers."",
  ""userQuery3"": ""The user wants to create a security group within the specified VPC. This security group should allow all traffic within the subnet. The name and description of the security group should reflect the availability zone in which it is created."",
  ""userQuery4"": ""The user wants to create a route table associated with the subnet. The route table is also within the specified VPC."",
  ""userQuery5"": ""The user wants to"
78,ev3rt-git,ev3rt-hrp2-base,arch/arm_gcc/common,"$ ======================================================================
$
$   TOPPERS/HRP Kernel
$       Toyohashi Open Platform for Embedded Real-Time Systems/
$       High Reliable system Profile Kernel
$
$   Copyright (C) 2011-2015 by Embedded and Real-Time Systems Laboratory
$               Graduate School of Information Science, Nagoya Univ., JAPAN
$  
$   (1)(4)
$   
$   
$   (1) 
$       
$       
$   (2) 
$       
$       
$       
$   (3) 
$       
$       
$     (a) 
$         
$     (b) TOPPERS
$         
$   (4) 
$       TOPPERS
$       
$       TOPPERS
$       
$  
$   
$   TOPPERS
$   
$   
$   
$
$   $Id: core.tf 1032 2015-05-09 19:58:03Z ertl-hiro $
$  
$ =====================================================================

$
$     2ARM
$

$
$  CPU
$
$EXCNO_VALID = { 1,2,3,4,6,7,8 }$

$
$  DEF_EXCCPU
$
$EXCNO_DEFEXC_VALID = EXCNO_VALID$

$
$  
$

$ 
$DOMINICTXB_KERNEL= ""{ 0, 0 }""$

$ 
$FUNCTION GENERATE_DOMINICTXB$
	{ $ARGV[1]$, _kernel_section_table[INDEX_DOM($ARGV[1]$)] }
$END$

$
$  
$
$FUNCTION SECTION_USTACK$
	$RESULT = FORMAT("".ustack_%1%"", ARGV[1])$
$END$

$FUNCTION ALLOC_USTACK$
	$ustksz = (ARGV[2] + CHECK_USTKSZ_ALIGN - 1) & ~(CHECK_USTKSZ_ALIGN - 1)$
	static STK_T _kernel_ustack_$ARGV[1]$[COUNT_STK_T($ustksz$)]
	$SPC$__attribute__((section("".ustack_$ARGV[1]$""),nocommon));$NL$
	$TSK.TINIB_USTKSZ[ARGV[1]] = FORMAT(""ROUND_STK_T(%1%)"", ustksz)$
	$TSK.TINIB_USTK[ARGV[1]] = CONCAT(""_kernel_ustack_"", ARGV[1])$
$END$

$ 
$FUNCTION ALLOC_USTACK_DUMMY$
$	// static
$	// static
	$ustksz = (ARGV[2] + CHECK_USTKSZ_ALIGN - 1) & ~(CHECK_USTKSZ_ALIGN - 1)$
	STK_T _kernel_ustack_$ARGV[1]$[COUNT_STK_T($ustksz$)]
	$SPC$__attribute__((section("".ustack_$ARGV[1]$""),nocommon));$NL$
$END$

$
$  
$
$FUNCTION ALLOC_SSTACK$
	static STK_T $ARGV[1]$[COUNT_STK_T($ARGV[2]$)]
	$SPC$__attribute__((section("".prsv_kernel""),nocommon));$NL$
	$RESULT = FORMAT(""ROUND_STK_T(%1%)"", ARGV[2])$
$END$

$
$  
$
$FUNCTION SECTION_UMPF$
	$RESULT = FORMAT("".mpf_%1%"", ARGV[1])$
$END$

$FUNCTION ALLOC_UMPF$
	static MPF_T _kernel_mpf_$ARGV[1]$[($ARGV[3]$) * COUNT_MPF_T($ARGV[4]$)]
	$SPC$__attribute__((section("".mpf_$ARGV[1]$""),nocommon));$NL$
$END$

$
$  
$
$DSEC.ORDER_LIST = { 1, 2, 3, 4, 5 }$

$DSEC.SECTION[1] = "".text""$
$DSEC.MEMATR[1] = MEMATR_TEXT$
$DSEC.MEMREG[1] = 1$

$DSEC.SECTION[2] = "".rodata""$
$DSEC.MEMATR[2] = MEMATR_RODATA$
$DSEC.MEMREG[2] = 1$

$DSEC.SECTION[3] = "".data""$
$DSEC.MEMATR[3] = MEMATR_DATA$
$DSEC.MEMREG[3] = 2$

$DSEC.SECTION[4] = "".bss""$
$DSEC.MEMATR[4] = MEMATR_BSS$
$DSEC.MEMREG[4] = 2$

$DSEC.SECTION[5] = "".prsv""$
$DSEC.MEMATR[5] = MEMATR_PRSV$
$DSEC.MEMREG[5] = 2$

$DSEC_SECTION_LIST = { "".rodata.str1.4"", ""COMMON"" }$

$
$  
$
$FUNCTION SECTION_DESCRIPTION$
	$IF EQ(ARGV[1], "".rodata"")$
		$RESULT = "".rodata .rodata.str1.4""$
	$ELIF EQ(ARGV[1], "".bss"")$
		$RESULT = "".bss COMMON""$
	$ELSE$
		$RESULT = ARGV[1]$
	$END$
$END$

$END_LABEL_HOOK_LABELS = { ""rodata_shared"", ""rodata_shared__std"" }$

$FUNCTION END_LABEL_HOOK$
	$TAB$.preinit_array ALIGN(4) : {$NL$
	$TAB$$TAB$PROVIDE_HIDDEN (__preinit_array_start = .);$NL$
	$TAB$$TAB$KEEP (*(.preinit_array))$NL$
	$TAB$$TAB$PROVIDE_HIDDEN (__preinit_array_end = .);$NL$
	$TAB$} > $REG.REGNAME[STANDARD_ROM]$$NL$

	$TAB$.init_array ALIGN(4) : {$NL$
	$TAB$$TAB$PROVIDE_HIDDEN (__init_array_start = .);$NL$
	$TAB$$TAB$KEEP (*(SORT(.init_array.*)))$NL$
	$TAB$$TAB$KEEP (*(.init_array))$NL$
	$TAB$$TAB$PROVIDE_HIDDEN (__init_array_end = .);$NL$
	$TAB$} > $REG.REGNAME[STANDARD_ROM]$$NL$

	$TAB$.fini_array ALIGN(4) : {$NL$
	$TAB$$TAB$PROVIDE_HIDDEN (__fini_array_start = .);$NL$
	$TAB$$TAB$KEEP (*(SORT(.fini_array.*)))$NL$
	$TAB$$TAB$KEEP (*(.fini_array))$NL$
	$TAB$$TAB$PROVIDE_HIDDEN (__fini_array_end = .);$NL$
	$TAB$} > $REG.REGNAME[STANDARD_ROM]$$NL$

	$TAB$.ARM.exidx ALIGN(4) : {$NL$
	$TAB$$TAB$__exidx_start = .;$NL$
	$TAB$$TAB$*(.ARM.exidx* .gnu.linkonce.armexidx.*)$NL$
	$TAB$$TAB$__exidx_end = .;$NL$
	$TAB$} > $REG.REGNAME[STANDARD_ROM]$$NL$

	$TAB$__end_rodata_shared__std = .;$NL$
	$TAB$__end_rodata_shared = .;$NL$
$END$

$
$  ATT_REG
$
$FUNCTION HOOK_ERRORCHECK_REG$
$	// baseE_PAR
	$IF (REG.BASE[ARGV[1]] & (ARM_PAGE_SIZE - 1)) != 0$
		$ERROR REG.TEXT_LINE[ARGV[1]]$E_PAR: 
			$FORMAT(_(""%1% `%2%\' in %3% is not aligned to the page size""),
				""base"", REG.BASE[ARGV[1]], ""ATT_REG"")$
		$END$
	$END$

$	// sizeE_PAR
	$IF (REG.SIZE[ARGV[1]] & (ARM_PAGE_SIZE - 1)) != 0$
		$ERROR REG.TEXT_LINE[ARGV[1]]$E_PAR: 
			$FORMAT(_(""%1% `%2%\' in %3% is not aligned to the page size""),
				""size"", REG.SIZE[ARGV[1]], ""ATT_REG"")$
		$END$
	$END$
$END$

$
$  ATT_SECATA_SEC
$
$FUNCTION HOOK_ERRORCHECK_SEC$
$	// mematrTA_NOREAD
	$IF (SEC.MEMATR[ARGV[1]] & TA_NOREAD) != 0$
		$WARNING SEC.TEXT_LINE[ARGV[1]]$
			$FORMAT(_(""%1% `%2%' in %3% is ignored on this target""), ""mematr"", ""TA_NOREAD"", SEC.APINAME[ARGV[1]])$
		$END$
		$SEC.MEMATR[ARGV[1]] = SEC.MEMATR[ARGV[1]] & ~TA_NOREAD$
	$END$

$	// 
	$IF LENGTH(SEC.ACPTN1[ARGV[1]])
			&& (SEC.ACPTN1[ARGV[1]] & ~(SEC.ACPTN2[ARGV[1]])) != 0$
		$WARNING SEC.TEXT_LINE[ARGV[1]]$
			$FORMAT(_(""write only memory object registered with %1% is not supported on this target""), SEC.APINAME[ARGV[1]])$
		$END$
	$END$
$END$

$
$  ATT_MEMATA_MEMATT_PMAATA_PMA
$
$FUNCTION HOOK_ERRORCHECK_MEM$
$	// mematrTA_NOREAD
	$IF (MEM.MEMATR[ARGV[1]] & TA_NOREAD) != 0$
		$WARNING MEM.TEXT_LINE[ARGV[1]]$
			$FORMAT(_(""%1% is ignored on this target""), ""TA_NOREAD"")$
		$END$
		$MEM.MEMATR[ARGV[1]] = MEM.MEMATR[ARGV[1]] & ~TA_NOREAD$
	$END$

$	// sizeE_PAR
	$IF (MEM.SIZE[ARGV[1]] & (ARM_PAGE_SIZE - 1)) != 0$
		$ERROR MEM.TEXT_LINE[ARGV[1]]$E_PAR: 
			$FORMAT(_(""%1% `%2%\' in %3% is not aligned to the page size""),
				""size"", MEM.SIZE[ARGV[1]], MEM.APINAME[ARGV[1]])$
		$END$
	$END$

$	// paddrE_PAR
	$IF LENGTH(MEM.PADDR[ARGV[1]]) && (MEM.PADDR[ARGV[1]] & (ARM_PAGE_SIZE - 1)) != 0$
		$ERROR MEM.TEXT_LINE[ARGV[1]]$E_PAR: 
			$FORMAT(_(""%1% `%2%\' in %3% is not aligned to the page size""),
				""paddr"", MEM.PADDR[ARGV[1]], MEM.APINAME[ARGV[1]])$
		$END$
	$END$

$	// 
	$IF LENGTH(MEM.ACPTN1[ARGV[1]])
			&& (MEM.ACPTN1[ARGV[1]] & ~(MEM.ACPTN2[ARGV[1]])) != 0$
		$WARNING MEM.TEXT_LINE[ARGV[1]]$
			$FORMAT(_(""write only memory object is not supported on this target""))$
		$END$
	$END$
$END$

$
$  
$
$ .page_table
$
$FUNCTION HOOK_ADDITIONAL_MO$
	$nummo = nummo + 1$
	$MO.TYPE[nummo] = TOPPERS_ATTSEC$
	$MO.LINKER[nummo] = 1$
	$MO.DOMAIN[nummo] = TDOM_KERNEL$
	$MO.MEMREG[nummo] = STANDARD_ROM$
	$MO.SECTION[nummo] = "".page_table""$
	$MO.MEMATR[nummo] = MEMATR_RODATA$

	$domptn = DEFAULT_ACPTN[TDOM_KERNEL]$
	$MO.ACPTN1[nummo] = domptn$
	$MO.ACPTN2[nummo] = domptn$
	$MO.ACPTN4[nummo] = domptn$
$END$

$
$  OUTPUT
$
$FUNCTION GENERATE_OUTPUT$
	OUTPUT_FORMAT(""elf32-littlearm"", ""elf32-bigarm"",""elf32-littlearm"")$NL$
	OUTPUT_ARCH(arm)$NL$
	$NL$
$END$

$
$  PROVIDE
$
$FUNCTION GENERATE_PROVIDE$
	PROVIDE(_gp = 0);$NL$
	PROVIDE(hardware_init_hook = 0);$NL$
	PROVIDE(software_init_hook = 0);$NL$
	PROVIDE(software_term_hook = 0);$NL$
	$NL$
$END$

$
$  
$
$FUNCTION GENERATE_SECTION_FIRST$
	$TAB$vector : {$NL$
	$TAB$$TAB$__start_text_kernel = .;$NL$
	$omit_start_slabel = ""text_kernel""$
	$TAB$$TAB$__start_text_kernel__std = .;$NL$
	$omit_start_mlabel = ""text_kernel__std""$
	$TAB$$TAB$*(.vector)$NL$
	$TAB$} > $REG.REGNAME[STANDARD_ROM]$$NL$
	$NL$
$END$

$
$  
$
$INCLUDE ""kernel/kernel.tf""$

$
$  
$
const FP _kernel_exch_tbl[TNUM_EXCH] = {$NL$
$FOREACH excno {0,1,...,8}$
	$IF LENGTH(EXC.EXCNO[excno])$
		$TAB$(FP)($EXC.EXCHDR[excno]$),
	$ELSE$
		$TAB$(FP)(_kernel_default_exc_handler),
	$END$
	$SPC$$FORMAT(""/* %d */"", +excno)$$NL$
$END$
$NL$};$NL$
$NL$

$
$  
$
$FILE ""kernel_mem2.c""$

$ 
$max_dom_page_table = 0$
$prev_limit = 0$
$FOREACH reg REG_ORDER$
	$base = REG.BASE[reg] / ARM_SECTION_SIZE$
	$limit = (REG.BASE[reg] + REG.SIZE[reg] + ARM_SECTION_SIZE - 1) / ARM_SECTION_SIZE$
	$IF prev_limit < base$
		$max_dom_page_table = max_dom_page_table + (limit - base)$
	$ELSE$
		$max_dom_page_table = max_dom_page_table + (limit - prev_limit)$
	$END$
	$prev_limit = limit$
$END$

$ 
#define ARM_MAX_DOM_PAGE_TABLE	$max_dom_page_table$$NL$
$NL$
#ifndef ARM_PAGE_TABLE_RATIO$NL$
#define ARM_PAGE_TABLE_RATIO	100$NL$
#endif /* ARM_PAGE_TABLE_RATIO */$NL$
$NL$
#define ARM_PAGE_TABLE_NUM		(ARM_MAX_DOM_PAGE_TABLE * ARM_PAGE_TABLE_RATIO / 100)$NL$
$NL$

const uint32_t _kernel_section_table
$IF LENGTH(DOM.ID_LIST)$
	[TNUM_DOMID][ARM_SECTION_TABLE_ENTRY]
$ELSE$
	[1][ARM_SECTION_TABLE_ENTRY]
$END$
$SPC$__attribute__((aligned(ARM_SECTION_TABLE_ALIGN),
section("".page_table""),nocommon)) = {{ 0U }};$NL$
$NL$

const uint32_t _kernel_page_table
$IF LENGTH(DOM.ID_LIST)$
	[TNUM_DOMID * ARM_PAGE_TABLE_NUM][ARM_PAGE_TABLE_ENTRY]
$ELSE$
	[ARM_PAGE_TABLE_NUM][ARM_PAGE_TABLE_ENTRY]
$END$
$SPC$__attribute__((aligned(ARM_PAGE_TABLE_ALIGN),
section("".page_table""),nocommon)) = {{ 0U }};$NL$
$NL$

$
$  3
$
$FILE ""cfg2_out.tf""$

$ max_dom_page_table
$$max_dom_page_table = $max_dom_page_table$$$$NL$
$NL$

$FILE ""kernel_cfg.c""$


$ ======================================================================
$
$   TOPPERS/HRP Kernel
$       Toyohashi Open Platform for Embedded Real-Time Systems/
$       High Reliable system Profile Kernel
$
$   Copyright (C) 2011-2012 by Embedded and Real-Time Systems Laboratory
$               Graduate School of Information Science, Nagoya Univ., JAPAN
$  
$   (1)(4)
$   
$   
$   (1) 
$       
$       
$   (2) 
$       
$       
$       
$   (3) 
$       
$       
$     (a) 
$         
$     (b) TOPPERS
$         
$   (4) 
$       TOPPERS
$       
$       TOPPERS
$       
$  
$   
$   TOPPERS
$   
$   
$   
$
$   $Id: core_mem.tf 707 2012-07-27 09:16:31Z ertl-hiro $
$  
$ =====================================================================

$
$     4ARM
$

$
$  
$
$GENERATE_MP_INFO = 1$

$
$  
$
$INCLUDE ""kernel/kernel_mem.tf""$
$NL$

$
$  
$
$error_flag = 0$
$FOREACH mpid RANGE(1, nummp)$
$	// ATT_MEMATA_MEM
	$moid = MP.MOID[mpid]$
	$IF LENGTH(moid) && MO.TYPE[moid] == TOPPERS_ATTMEM
						&& (MP.BASEADDR[mpid] & (ARM_PAGE_SIZE - 1)) != 0$
		$ERROR MO.TEXT_LINE[moid]$E_PAR: 
			$FORMAT(_(""%1% `%2%\' in %3% is not aligned to the page size""),
				""base"", MO.BASE[moid], MO.APINAME[moid])$
		$END$
		$error_flag = 1$
	$END$
$END$
$IF !error_flag$
$	// 
$	// E_SYS
	$FOREACH mpid RANGE(1, nummp)$
$		// 
		$IF (MP.BASEADDR[mpid] & (ARM_PAGE_SIZE - 1)) != 0
					|| (MP.LIMITADDR[mpid] & (ARM_PAGE_SIZE - 1)) != 0$
			$ERROR$E_SYS: 
				$FORMAT(_(""unaligned memory protection boundary [%x %x]""),
					MP.BASEADDR[mpid], MP.LIMITADDR[mpid])$
			$END$
		$END$
	$END$
$END$

$ =====================================================================
$ 
$ =====================================================================

#define ARM_MAX_DOM_PAGE_TABLE	$max_dom_page_table$$NL$
$NL$
#ifndef ARM_PAGE_TABLE_RATIO$NL$
#define ARM_PAGE_TABLE_RATIO	100$NL$
#endif /* ARM_PAGE_TABLE_RATIO */$NL$
$NL$
#define ARM_PAGE_TABLE_NUM		(ARM_MAX_DOM_PAGE_TABLE * ARM_PAGE_TABLE_RATIO / 100)$NL$
$NL$

$
$  ARM1MB
$
$ ARMSEC.PT_ENTRY[s_entry]
$							
$							-1
$ ARMSEC.GLOBAL[s_entry]
$ ARMSEC.PRIVATE[s_entry]
$ ARMSEC.DOMAIN[s_entry]
$						  

$FUNCTION CLEAR_GLOBAL_PRIVATE$
	$IF LENGTH(MP.MEMATR[mpid])$
		$IF !LENGTH(MP.GLOBAL[mpid])$
$			// 
$			// 
			$ARMSEC.GLOBAL[s_entry] = 0$

			$IF MP.DOMAIN[mpid] > 0 && LENGTH(MP.PRIVATE[mpid])$
				$IF domain > 0$
					$IF MP.DOMAIN[mpid] != domain$
$						// 
						$ARMSEC.PRIVATE[s_entry] = 0$
					$END$
				$ELSE$
					$domain = MP.DOMAIN[mpid]$
				$END$
			$ELSE$
				$ARMSEC.PRIVATE[s_entry] = 0$
			$END$
		$END$
	$END$
$END$

$mpid = 1$
$pt_entry = 0$
$FOREACH s_entry RANGE(1, ARM_SECTION_TABLE_ENTRY)$
	$limitaddr = s_entry * ARM_SECTION_SIZE$
	$baseaddr = limitaddr - ARM_SECTION_SIZE$

	$IF MP.LIMITADDR[mpid] == 0 || MP.LIMITADDR[mpid] >= limitaddr$
$		// 1
		$ARMSEC.PT_ENTRY[s_entry] = -1$
	$ELSE$
$		// 
		$ARMSEC.GLOBAL[s_entry] = 1$
		$ARMSEC.PRIVATE[s_entry] = 1$
		$domain = TDOM_NONE$
		$WHILE MP.LIMITADDR[mpid] != 0 && MP.LIMITADDR[mpid] < limitaddr$
			$CLEAR_GLOBAL_PRIVATE()$
			$mpid = mpid + 1$
		$END$
		$CLEAR_GLOBAL_PRIVATE()$

$		// 
		$ARMSEC.PT_ENTRY[s_entry] = pt_entry$
		$IF !LENGTH(DOM.ID_LIST)$
$			// 
			$pt_entry = pt_entry + 1$
		$ELIF ARMSEC.GLOBAL[s_entry]$
$			// 
			$pt_entry = pt_entry + 1$
		$ELIF ARMSEC.PRIVATE[s_entry]$
$			// 
			$ARMSEC.DOMAIN[s_entry] = domain$
			$IF LENGTH(DOM.ID_LIST) > 1$
				$pt_entry = pt_entry + 2$
			$ELSE$
				$pt_entry = pt_entry + 1$
			$END$
		$ELSE$
$			// 
			$IF LENGTH(DOM.ID_LIST)$
				$pt_entry = pt_entry + LENGTH(DOM.ID_LIST)$
			$ELSE$
				$pt_entry = pt_entry + 1$
			$END$
		$END$
	$END$
	$IF MP.LIMITADDR[mpid] == limitaddr$
		$mpid = mpid + 1$
	$END$
$END$

$
$  
$

$ 
$IF LENGTH(ARM_PAGE_TABLE_RATIO)$
	$page_table_size = max_dom_page_table * ARM_PAGE_TABLE_RATIO / 100$
$ELSE$
	$page_table_size = max_dom_page_table$
$END$
$IF LENGTH(DOM.ID_LIST)$
	$page_table_size = LENGTH(DOM.ID_LIST) * page_table_size$
$END$

$ 
$WARNING$
	$FORMAT(_(""%1%%% of the allocated page table area is used""),
								pt_entry * 100 / page_table_size)$
$END$

$ 
$IF pt_entry > page_table_size$
	$ERROR$
		$FORMAT(_(""increase ARM_PAGE_TABLE_RATIO and build again""))$
	$END$
$END$

$ 
$page_table = SYMBOL(""_kernel_page_table"")$

$
$  
$
$ ARGV[1]DSCR1 or DSCR2
$ ARGV[2]DSCR1 or DSCR2S or DSCR2L
$
$FUNCTION GENERATE_ENTRY$
$	// nG
	$IF !LENGTH(MP.GLOBAL[mpid])$
		ARMV6_MMU_$ARGV[1]$_NONGLOBAL|
	$END$

$	// APXAP
	$IF (MP.MEMATR[mpid] & TA_NOWRITE) != 0$
		$IF (MP.ACPTN2[mpid] & domptn) != 0$
			ARMV6_MMU_$ARGV[1]$_APX1|ARMV6_MMU_$ARGV[1]$_AP10|
		$ELSE$
			ARMV6_MMU_$ARGV[1]$_APX1|ARMV6_MMU_$ARGV[1]$_AP01|
		$END$
	$ELSE$
		$IF (MP.ACPTN1[mpid] & domptn) != 0$
			ARMV6_MMU_$ARGV[1]$_APX0|ARMV6_MMU_$ARGV[1]$_AP11|
		$ELIF (MP.ACPTN2[mpid] & domptn) != 0$
			ARMV6_MMU_$ARGV[1]$_APX0|ARMV6_MMU_$ARGV[1]$_AP10|
		$ELSE$
			ARMV6_MMU_$ARGV[1]$_APX0|ARMV6_MMU_$ARGV[1]$_AP01|
		$END$
	$END$

$	// TEXCB
	$IF (MP.MEMATR[mpid] & TA_SORDER) != 0$
		ARMV6_MMU_$ARGV[2]$_TEX000|ARMV6_MMU_$ARGV[1]$_CB00|
	$ELIF (MP.MEMATR[mpid] & TA_IODEV) != 0$
		ARMV6_MMU_$ARGV[2]$_TEX000|ARMV6_MMU_$ARGV[1]$_CB01|
	$ELIF (MP.MEMATR[mpid] & TA_UNCACHE) != 0$
		ARMV6_MMU_$ARGV[2]$_TEX001|ARMV6_MMU_$ARGV[1]$_CB00|
	$ELIF (MP.MEMATR[mpid] & TA_WTHROUGH) != 0$
		ARMV6_MMU_$ARGV[2]$_TEX000|ARMV6_MMU_$ARGV[1]$_CB10|
	$ELSE$
		ARMV6_MMU_$ARGV[2]$_TEX001|ARMV6_MMU_$ARGV[1]$_CB11|
	$END$

$	// XN
	$IF (MP.MEMATR[mpid] & TA_EXEC) == 0$
		ARMV6_MMU_$ARGV[2]$_NOEXEC|
	$END$

$	// S
	$IF TOPPERS_MPCORE && (MP.MEMATR[mpid] & TA_NONSHARED) == 0$
		ARMV6_MMU_$ARGV[1]$_SHARED|
	$END$
$END$

$
$  
$

$ 
$FUNCTION GENERATE_SECTION_ENTRY$
	ARMV6_MMU_DSCR1_SECTION|
	$GENERATE_ENTRY(""DSCR1"", ""DSCR1"")$
	$FORMAT(""0x%08xU"", baseaddr + MP.POFFSET[mpid])$
$END$

$ 
$FUNCTION GENERATE_SSECTION_ENTRY$
	ARMV6_MMU_DSCR1_SSECTION|
	$GENERATE_ENTRY(""DSCR1"", ""DSCR1"")$
	$FORMAT(""0x%08xU"", (baseaddr + MP.POFFSET[mpid]) & ~(ARM_SSECTION_SIZE - 1))$
$END$

$ 1
$FUNCTION GENERATE_SECTION_TABLE$
	$mpid = 1$
	$TAB${$NL$
	$FOREACH s_entry RANGE(1, ARM_SECTION_TABLE_ENTRY)$
		$limitaddr = s_entry * ARM_SECTION_SIZE$
		$baseaddr = limitaddr - ARM_SECTION_SIZE$
		$TAB$$TAB$
		$IF ARMSEC.PT_ENTRY[s_entry] >= 0$
			ARMV6_MMU_DSCR1_PAGETABLE|
			$IF !LENGTH(DOM.ID_LIST)$
$				// 
				$pt_entry = ARMSEC.PT_ENTRY[s_entry]$
			$ELIF ARMSEC.GLOBAL[s_entry]$
$				// 
				$pt_entry = ARMSEC.PT_ENTRY[s_entry]$
			$ELIF ARMSEC.PRIVATE[s_entry]$
$				// 
				$IF ARMSEC.DOMAIN[s_entry] == domid$
					$pt_entry = ARMSEC.PT_ENTRY[s_entry]$
				$ELSE$
					$pt_entry = ARMSEC.PT_ENTRY[s_entry] + 1$
				$END$
			$ELSE$
$				// 
				$pt_entry = ARMSEC.PT_ENTRY[s_entry] + (domid - 1)$
			$END$
			$FORMAT(""0x%08xU"", page_table + ARM_PAGE_TABLE_SIZE * pt_entry)$
			$SPC$/* page_table[$pt_entry$] */
		$ELSE$
			$IF LENGTH(MP.MEMATR[mpid])$
				$ss_baseaddr = baseaddr & ~(ARM_SSECTION_SIZE - 1)$
				$IF MP.BASEADDR[mpid] <= ss_baseaddr
					&& ss_baseaddr + ARM_SSECTION_SIZE <= MP.LIMITADDR[mpid]
					&& (MP.POFFSET[mpid] & (ARM_SSECTION_SIZE - 1)) == 0$
					$GENERATE_SSECTION_ENTRY()$
				$ELSE$
					$GENERATE_SECTION_ENTRY()$
				$END$
			$ELSE$
				ARMV6_MMU_DSCR1_FAULT
			$END$
		$END$
		$WHILE MP.LIMITADDR[mpid] != 0 && MP.LIMITADDR[mpid] <= limitaddr$
			$mpid = mpid + 1$
		$END$
		,$SPC$/* $FORMAT(""0x%08x"", +baseaddr)$ */$NL$
	$END$$NL$
	$TAB$}
$END$

$ 
$page_table_offset = 0$
$IF LENGTH(DOM.ID_LIST)$
	const uint32_t _kernel_section_table[TNUM_DOMID][ARM_SECTION_TABLE_ENTRY]
	$SPC$__attribute__((aligned(ARM_SECTION_TABLE_ALIGN),
	section("".page_table""),nocommon)) =$NL$
	{$NL$
	$JOINEACH domid DOM.ID_LIST "",\n""$
		$domptn = 1 << (domid - 1)$
		$GENERATE_SECTION_TABLE()$
	$END$$NL$
	};$NL$
$ELSE$
	const uint32_t _kernel_section_table[1][ARM_SECTION_TABLE_ENTRY]
	$SPC$__attribute__((aligned(ARM_SECTION_TABLE_ALIGN),
	section("".page_table""),nocommon)) =$NL$
	{$NL$
	$domptn = 0$
	$GENERATE_SECTION_TABLE()$
	};$NL$
$END$$NL$

$
$  
$

$ 
$FUNCTION GENERATE_PAGE_ENTRY$
	ARMV6_MMU_DSCR2_SMALL|
	$GENERATE_ENTRY(""DSCR2"", ""DSCR2S"")$
	$FORMAT(""0x%08xU"", baseaddr + MP.POFFSET[mpid])$
$END$

$ 
$FUNCTION GENERATE_LPAGE_ENTRY$
	ARMV6_MMU_DSCR2_LARGE|
	$GENERATE_ENTRY(""DSCR2"", ""DSCR2L"")$
	$FORMAT(""0x%08xU"", (baseaddr + MP.POFFSET[mpid]) & ~(ARM_LPAGE_SIZE - 1))$
$END$

$ 1
$FUNCTION GENERATE_PAGE_TABLE$
	$mpid = s_mpid$
	$TAB${$NL$
	$FOREACH entry RANGE(1, ARM_PAGE_TABLE_ENTRY)$
		$limitaddr = s_baseaddr + entry * ARM_PAGE_SIZE$
		$baseaddr = limitaddr - ARM_PAGE_SIZE$
		$TAB$$TAB$
		$IF LENGTH(MP.MEMATR[mpid])$
			$lp_baseaddr = baseaddr & ~(ARM_LPAGE_SIZE - 1)$
			$IF MP.BASEADDR[mpid] <= lp_baseaddr
					&& lp_baseaddr + ARM_LPAGE_SIZE <= MP.LIMITADDR[mpid]
					&& (MP.POFFSET[mpid] & (ARM_LPAGE_SIZE - 1)) == 0$
				$GENERATE_LPAGE_ENTRY()$
			$ELSE$
				$GENERATE_PAGE_ENTRY()$
			$END$
		$ELSE$
			ARMV6_MMU_DSCR2_FAULT
		$END$
		$IF MP.LIMITADDR[mpid] == limitaddr$
			$mpid = mpid + 1$
		$END$
		,$SPC$/* $FORMAT(""0x%08x"", +baseaddr)$ */$NL$
	$END$
	$TAB$},$NL$
$END$

$ 
const uint32_t _kernel_page_table
$IF LENGTH(DOM.ID_LIST)$
	[TNUM_DOMID * ARM_PAGE_TABLE_NUM][ARM_PAGE_TABLE_ENTRY]
$ELSE$
	[ARM_PAGE_TABLE_NUM][ARM_PAGE_TABLE_ENTRY]
$END$
$SPC$__attribute__((aligned(ARM_PAGE_TABLE_ALIGN),
section("".page_table""),nocommon)) =$NL$
{$NL$

$s_mpid = 1$
$FOREACH s_entry RANGE(1, ARM_SECTION_TABLE_ENTRY)$
	$s_limitaddr = s_entry * ARM_SECTION_SIZE$
	$s_baseaddr = s_limitaddr - ARM_SECTION_SIZE$

	$IF ARMSEC.PT_ENTRY[s_entry] >= 0$
		$IF !LENGTH(DOM.ID_LIST)$
$			// 
			$domptn = 0$
			$GENERATE_PAGE_TABLE()$
		$ELIF ARMSEC.GLOBAL[s_entry]$
$			// 
			$domptn = 0x01$
			$GENERATE_PAGE_TABLE()$
		$ELIF ARMSEC.PRIVATE[s_entry]$
$			// 
$			// 
			$domptn = 1 << (ARMSEC.DOMAIN[s_entry] - 1)$
			$GENERATE_PAGE_TABLE()$

$			// 
			$IF LENGTH(DOM.ID_LIST) > 1$
$				// domptn
				$IF domptn == 0x01$
					$domptn = 0x02$
				$ELSE$
					$domptn = 0x01$
				$END$
				$GENERATE_PAGE_TABLE()$
			$END$
		$ELSE$
$			// 
			$FOREACH domid DOM.ID_LIST$
				$domptn = 1 << (domid - 1)$
				$GENERATE_PAGE_TABLE()$
			$END$
		$END$
	$END$
	$WHILE MP.LIMITADDR[s_mpid] != 0 && MP.LIMITADDR[s_mpid] <= s_limitaddr$
		$s_mpid = s_mpid + 1$
	$END$
$END$
};$NL$


$ ======================================================================
$
$   TOPPERS/HRP Kernel
$       Toyohashi Open Platform for Embedded Real-Time Systems/
$       High Reliable system Profile Kernel
$
$   Copyright (C) 2011 by Embedded and Real-Time Systems Laboratory
$               Graduate School of Information Science, Nagoya Univ., JAPAN
$  
$   (1)(4)
$   
$   
$   (1) 
$       
$       
$   (2) 
$       
$       
$       
$   (3) 
$       
$       
$     (a) 
$         
$     (b) TOPPERS
$         
$   (4) 
$       TOPPERS
$       
$       TOPPERS
$       
$  
$   
$   TOPPERS
$   
$   
$   
$
$   $Id: core_offset.tf 656 2012-06-17 02:40:59Z ertl-hiro $
$
$ =====================================================================

$
$     offset.hARM
$

$
$  
$
$INCLUDE ""kernel/genoffset.tf""$

$
$  
$
$DEFINE(""TCB_p_tinib"", offsetof_TCB_p_tinib)$
$DEFINE(""TCB_texptn"", offsetof_TCB_texptn)$
$DEFINE(""TCB_svclevel"", offsetof_TCB_svclevel)$
$DEFINE(""TCB_sp"", offsetof_TCB_sp)$
$DEFINE(""TCB_pc"", offsetof_TCB_pc)$
$DEFINE(""TCB_priv"", offsetof_TCB_priv)$
$DEFINE(""TINIB_p_dominib"", offsetof_TINIB_p_dominib)$
$DEFINE(""TINIB_exinf"", offsetof_TINIB_exinf)$
$DEFINE(""TINIB_task"", offsetof_TINIB_task)$
$DEFINE(""TINIB_sstk"", offsetof_TINIB_sstk)$
$DEFINE(""TINIB_sstksz"", offsetof_TINIB_sstksz)$
$DEFINE(""TINIB_ustk"", offsetof_TINIB_ustk)$
$DEFINE(""TINIB_ustksz"", offsetof_TINIB_ustksz)$
$DEFINE(""TINIB_texrtn"", offsetof_TINIB_texrtn)$
$DEFINE(""DOMINIB_domptn"", offsetof_DOMINIB_domptn)$
$DEFINE(""DOMINIB_domid"", offsetof_DOMINIB_domid)$
$DEFINE(""DOMINIB_p_section_table"", offsetof_DOMINIB_p_section_table)$
$DEFINE(""ACVCT_acptn1"", offsetof_ACVCT_acptn1)$
$DEFINE(""ACVCT_acptn2"", offsetof_ACVCT_acptn2)$

$
$  
$
$DEFINE_BIT(""TCB_enatex"", sizeof_TCB, ""B"")$
$DEFINE_BIT(""TCB_waifbd"", sizeof_TCB, ""B"")$


$
$     3ARM
$

$
$  
$
$OPTIMI",
E_MEMINIB = 1$,,,,,
$OPTIMIZE_DATASEC_LIST = 1$,,,,,
$OPTIMIZE_BSSSEC_LIST = 1$,,,,,
,,,,,
$,,,,,
$  ,,,,,
$,,,,,
"$INCLUDE """"kernel/kernel_opt.tf""""$",,,,,
,,,,,
$,,,,,
$  ,,,,,
$,,,,,
"$FILE """"kernel_mem3.c""""$",,,,,
,,,,,
$ ,,,,,
"#define ARM_MAX_DOM_PAGE_TABLE	$max_dom_page_table$$NL$",,,,,
$NL$,,,,,
#ifndef ARM_PAGE_TABLE_RATIO$NL$,,,,,
"#define ARM_PAGE_TABLE_RATIO	100$NL$",,,,,
#endif /* ARM_PAGE_TABLE_RATIO */$NL$,,,,,
$NL$,,,,,
"#define ARM_PAGE_TABLE_NUM		(ARM_MAX_DOM_PAGE_TABLE * ARM_PAGE_TABLE_RATIO / 100)$NL$",,,,,
$NL$,,,,,
,,,,,
const uint32_t _kernel_section_table,,,,,
$IF LENGTH(DOM.ID_LIST)$,,,,,
"	[TNUM_DOMID][ARM_SECTION_TABLE_ENTRY]",,,,,
$ELSE$,,,,,
"	[1][ARM_SECTION_TABLE_ENTRY]",,,,,
$END$,,,,,
$SPC$__attribute__((aligned(ARM_SECTION_TABLE_ALIGN),,,,,
"section("""".page_table"""")",nocommon)) = {{ 0U }};$NL$,,,,
$NL$,,,,,
,,,,,
const uint32_t _kernel_page_table,,,,,
$IF LENGTH(DOM.ID_LIST)$,,,,,
"	[TNUM_DOMID * ARM_PAGE_TABLE_NUM][ARM_PAGE_TABLE_ENTRY]",,,,,
$ELSE$,,,,,
"	[ARM_PAGE_TABLE_NUM][ARM_PAGE_TABLE_ENTRY]",,,,,
$END$,,,,,
$SPC$__attribute__((aligned(ARM_PAGE_TABLE_ALIGN),,,,,
"section("""".page_table"""")",nocommon)) = {{ 0U }};$NL$,,,,
$NL$,,,,,
,,,,,
,,,,,
",An error occurred: Error code: 400 - {'error': {'message': """"This model's maximum context length is 8192 tokens. However"," your messages resulted in 12971 tokens. Please reduce the length of the messages.""""", 'type': 'invalid_request_error', 'param': 'messages'," 'code': 'context_length_exceeded'}}""",
79,quintilesims,layer0,setup/module/api,"data ""aws_caller_identity"" ""current"" {}

data ""aws_subnet_ids"" ""public"" {
  vpc_id = ""${var.vpc_id}""

  tags {
    Tier = ""Public""
  }
}

data ""aws_subnet_ids"" ""private"" {
  vpc_id = ""${var.vpc_id}""

  tags {
    Tier = ""Private""
  }
}

resource ""aws_s3_bucket"" ""mod"" {
  bucket        = ""layer0-${var.name}-${data.aws_caller_identity.current.account_id}""
  region        = ""${var.region}""
  force_destroy = true
  request_payer = ""BucketOwner""
}

resource ""aws_s3_bucket_object"" ""dockercfg"" {
  bucket  = ""${aws_s3_bucket.mod.id}""
  key     = ""bootstrap/dockercfg""
  content = ""${var.dockercfg}""
}

resource ""aws_cloudwatch_log_group"" ""mod"" {
  name = ""l0-${var.name}""
}

data ""template_file"" ""ecs_assume_role_policy"" {
  template = ""${file(""${path.module}/policies/ecs_assume_role_policy.json"")}""
}

resource ""aws_iam_role"" ""ecs"" {
  name               = ""l0-${var.name}-ecs-role""
  path               = ""/l0/l0-${var.name}/""
  assume_role_policy = ""${data.template_file.ecs_assume_role_policy.rendered}""
}

data ""template_file"" ""ecs_role_policy"" {
  template = ""${file(""${path.module}/policies/ecs_role_policy.json"")}""

  vars {
    name       = ""${var.name}""
    region     = ""${var.region}""
    s3_bucket  = ""${aws_s3_bucket.mod.id}""
    account_id = ""${data.aws_caller_identity.current.account_id}""
  }
}

resource ""aws_iam_role_policy"" ""ecs"" {
  name   = ""l0-${var.name}-ecs-role-policy""
  role   = ""${aws_iam_role.ecs.id}""
  policy = ""${data.template_file.ecs_role_policy.rendered}""
}

resource ""aws_iam_instance_profile"" ""ecs"" {
  name = ""l0-${var.name}-ecs-instance-profile""
  path = ""/l0/l0-${var.name}/""
  role = ""${aws_iam_role.ecs.name}""
}

resource ""aws_iam_user"" ""mod"" {
  name = ""l0-${var.name}-user""
  path = ""/l0/l0-${var.name}/""
}

resource ""aws_iam_access_key"" ""mod"" {
  user = ""${aws_iam_user.mod.name}""
}

resource ""aws_iam_group_membership"" ""mod"" {
  name  = ""l0-${var.name}-group-membership""
  group = ""${aws_iam_group.mod.name}""
  users = [""${aws_iam_user.mod.name}""]
}

resource ""aws_iam_group"" ""mod"" {
  name = ""l0-${var.name}""
  path = ""/l0/l0-${var.name}/""
}

data ""template_file"" ""group_policy"" {
  count    = ""${length(var.group_policies)}""
  template = ""${file(""${path.module}/policies/${var.group_policies[count.index]}_group_policy.json"")}""

  vars {
    name       = ""${var.name}""
    region     = ""${var.region}""
    account_id = ""${data.aws_caller_identity.current.account_id}""
    s3_bucket  = ""${aws_s3_bucket.mod.id}""
    vpc_id     = ""${var.vpc_id}""
  }
}

resource ""aws_iam_group_policy"" ""mod"" {
  count  = ""${length(var.group_policies)}""
  name   = ""l0-${var.name}-${var.group_policies[count.index]}""
  group  = ""${aws_iam_group.mod.id}""
  policy = ""${element(data.template_file.group_policy.*.rendered, count.index)}""
}

data ""aws_ami"" ""linux"" {
  owners = [""amazon""]
  most_recent = true

  filter {
    name   = ""name""
    values = [""amzn-ami-2018.03.20200813-amazon-ecs-optimized""]
  }
}

data ""aws_ami"" ""windows"" {
  owners = [""amazon""]
  most_recent = true

  filter {
    name   = ""name""
    values = [""Windows_Server-2016-English-Full-ECS_Optimized-2017.11.24""]
  }
}


# todo: descriptions

variable ""name"" {}

variable ""region"" {}

variable ""layer0_version"" {}

variable ""vpc_id"" {}

variable ""username"" {}

variable ""password"" {}

variable ""ssh_key_pair"" {}

variable ""dockercfg"" {}

variable ""tags"" {
  description = ""A map of tags to add to all resources""
  default     = {}
}

variable ""group_policies"" {
  default = [
    ""autoscaling"",
    ""dynamodb"",
    ""ec2"",
    ""ecs"",
    ""elb"",
    ""iam"",
    ""logs"",
    ""s3"",
  ]
}


resource ""aws_ecs_cluster"" ""api"" {
  name = ""l0-${var.name}-api""
}

resource ""aws_security_group"" ""api_env"" {
  name        = ""l0-${var.name}-api-env""
  description = ""Auto-generated Layer0 Environment Security Group""
  vpc_id      = ""${var.vpc_id}""
  tags        = ""${var.tags}""

  ingress {
    self      = ""true""
    from_port = 0
    to_port   = 0
    protocol  = ""-1""
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}

data ""template_file"" ""user_data"" {
  template = ""${file(""${path.module}/user_data.sh"")}""

  vars {
    cluster_id = ""${aws_ecs_cluster.api.id}""
    s3_bucket  = ""${aws_s3_bucket.mod.id}""
  }
}

resource ""aws_launch_configuration"" ""api"" {
  name_prefix          = ""l0-${var.name}-api-""
  image_id             = ""${data.aws_ami.linux.id}""
  instance_type        = ""t2.medium""
  security_groups      = [""${aws_security_group.api_env.id}""]
  iam_instance_profile = ""${aws_iam_instance_profile.ecs.id}""
  user_data            = ""${data.template_file.user_data.rendered}""
  key_name             = ""${var.ssh_key_pair}""

  lifecycle {
    create_before_destroy = true
  }
}

resource ""aws_autoscaling_group"" ""api"" {
  name                 = ""l0-${var.name}-api""
  launch_configuration = ""${aws_launch_configuration.api.name}""
  vpc_zone_identifier  = [""${data.aws_subnet_ids.private.ids}""]
  min_size             = ""2""
  desired_capacity     = ""2""
  max_size             = ""2""

  tag {
    key                 = ""Name""
    value               = ""l0-${var.name}-api""
    propagate_at_launch = true
  }

  tag {
    key                 = ""layer0""
    value               = ""${var.name}""
    propagate_at_launch = true
  }

  lifecycle {
    create_before_destroy = true
  }
}


resource ""aws_dynamodb_table"" ""tags"" {
  name           = ""l0-${var.name}-tags""
  read_capacity  = 5
  write_capacity = 5
  hash_key       = ""EntityType""
  range_key      = ""EntityID""
  tags           = ""${var.tags}""

  attribute {
    name = ""EntityType""
    type = ""S""
  }

  attribute {
    name = ""EntityID""
    type = ""S""
  }
  
  ttl {
    attribute_name = ""TimeToExist""
    enabled        = true
  }
}

resource ""aws_dynamodb_table"" ""jobs"" {
  name           = ""l0-${var.name}-jobs""
  read_capacity  = 5
  write_capacity = 10
  hash_key       = ""JobID""

  attribute {
    name = ""JobID""
    type = ""S""
  }
  ttl {
    attribute_name = ""TimeToExist""
    enabled        = true
  }
}

resource ""aws_appautoscaling_target"" ""tags_table_read_target"" {
  max_capacity       = 250
  min_capacity       = 5
  resource_id        = ""table/${aws_dynamodb_table.tags.name}""
  scalable_dimension = ""dynamodb:table:ReadCapacityUnits""
  service_namespace  = ""dynamodb""
}

resource ""aws_appautoscaling_policy"" ""tags_table_read_policy"" {
  name               = ""l0-${var.name}-tags-table-read-capacity-utilization:${aws_appautoscaling_target.tags_table_read_target.resource_id}""
  policy_type        = ""TargetTrackingScaling""
  resource_id        = ""${aws_appautoscaling_target.tags_table_read_target.resource_id}""
  scalable_dimension = ""${aws_appautoscaling_target.tags_table_read_target.scalable_dimension}""
  service_namespace  = ""${aws_appautoscaling_target.tags_table_read_target.service_namespace}""

  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = ""DynamoDBReadCapacityUtilization""
    }

    target_value = 70
  }
}

resource ""aws_appautoscaling_target"" ""jobs_table_read_target"" {
  max_capacity       = 250
  min_capacity       = 5
  resource_id        = ""table/${aws_dynamodb_table.jobs.name}""
  scalable_dimension = ""dynamodb:table:ReadCapacityUnits""
  service_namespace  = ""dynamodb""
}

resource ""aws_appautoscaling_policy"" ""jobs_table_read_policy"" {
  name               = ""l0-${var.name}-jobs-table-read-capacity-utilization:${aws_appautoscaling_target.jobs_table_read_target.resource_id}""
  policy_type        = ""TargetTrackingScaling""
  resource_id        = ""${aws_appautoscaling_target.jobs_table_read_target.resource_id}""
  scalable_dimension = ""${aws_appautoscaling_target.jobs_table_read_target.scalable_dimension}""
  service_namespace  = ""${aws_appautoscaling_target.jobs_table_read_target.service_namespace}""

  target_tracking_scaling_policy_configuration {
    predefined_metric_specification {
      predefined_metric_type = ""DynamoDBReadCapacityUtilization""
    }

    target_value = 70
  }
}

resource ""aws_security_group"" ""api_lb"" {
  name        = ""l0-${var.name}-api-lb""
  description = ""Auto-generated Layer0 Load Balancer Security Group""
  vpc_id      = ""${var.vpc_id}""
  tags        = ""${var.tags}""

  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = ""tcp""
    cidr_blocks = [""0.0.0.0/0""]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}

resource ""tls_private_key"" ""api"" {
  algorithm = ""RSA""
}

resource ""tls_self_signed_cert"" ""api"" {
  key_algorithm   = ""${tls_private_key.api.algorithm}""
  private_key_pem = ""${tls_private_key.api.private_key_pem}""

  subject {
    common_name = ""example.com""
  }

  validity_period_hours = 8760

  allowed_uses = [
    ""key_encipherment"",
    ""digital_signature"",
    ""server_auth"",
  ]
}

resource ""aws_iam_server_certificate"" ""api"" {
  name             = ""l0-${var.name}-api""
  path             = ""/l0/l0-${var.name}/""
  certificate_body = ""${tls_self_signed_cert.api.cert_pem}""
  private_key      = ""${tls_private_key.api.private_key_pem}""
}

resource ""aws_elb"" ""api"" {
  name            = ""l0-${var.name}-api""
  subnets         = [""${data.aws_subnet_ids.public.ids}""]
  security_groups = [""${aws_security_group.api_env.id}"", ""${aws_security_group.api_lb.id}""]
  tags            = ""${var.tags}""

  listener {
    instance_port      = 80
    instance_protocol  = ""http""
    lb_port            = 443
    lb_protocol        = ""https""
    ssl_certificate_id = ""${aws_iam_server_certificate.api.arn}""
  }

  health_check {
    healthy_threshold   = 2
    unhealthy_threshold = 2
    timeout             = 5
    target              = ""HTTP:80/health""
    interval            = 6
  }
}


resource ""aws_ecs_service"" ""api"" {
  name                               = ""l0-${var.name}-api""
  cluster                            = ""${aws_ecs_cluster.api.id}""
  task_definition                    = ""${aws_ecs_task_definition.api.arn}""
  desired_count                      = 1
  iam_role                           = ""${aws_iam_role.ecs.arn}""
  depends_on                         = [""aws_iam_role_policy.ecs""]
  deployment_minimum_healthy_percent = 100
  deployment_maximum_percent         = 200

  load_balancer {
    elb_name       = ""${aws_elb.api.name}""
    container_name = ""api""
    container_port = 9090
  }
}


resource ""aws_ecs_task_definition"" ""api"" {
  family                = ""l0-${var.name}-api""
  container_definitions = ""${data.template_file.container_definitions.rendered}""
}

data ""template_file"" ""container_definitions"" {
  template = ""${file(""${path.module}/Dockerrun.aws.json"")}""

  vars {
    api_auth_token       = ""${base64encode(""${var.username}:${var.password}"")}""
    layer0_version       = ""${var.layer0_version}""
    access_key           = ""${aws_iam_access_key.mod.id}""
    secret_key           = ""${aws_iam_access_key.mod.secret}""
    region               = ""${var.region}""
    public_subnets       = ""${join("","", data.aws_subnet_ids.public.ids)}""
    private_subnets      = ""${join("","", data.aws_subnet_ids.private.ids)}""
    ecs_role             = ""${aws_iam_role.ecs.id}""
    ecs_instance_profile = ""${aws_iam_instance_profile.ecs.id}""
    vpc_id               = ""${var.vpc_id}""
    s3_bucket            = ""${aws_s3_bucket.mod.id}""
    linux_service_ami    = ""${data.aws_ami.linux.id}""
    windows_service_ami  = ""${data.aws_ami.windows.id}""
    l0_prefix            = ""${var.name}""
    account_id           = ""${data.aws_caller_identity.current.account_id}""
    ssh_key_pair         = ""${var.ssh_key_pair}""
    log_group_name       = ""${aws_cloudwatch_log_group.mod.id}""
    dynamo_tag_table     = ""${aws_dynamodb_table.tags.id}""
    dynamo_job_table     = ""${aws_dynamodb_table.jobs.id}""
  }
}


output ""load_balancer_url"" {
  value = ""${aws_elb.api.dns_name}""
}

output ""token"" {
  value = ""${base64encode(""${var.username}:${var.password}"")}""
}

output ""public_subnets"" {
  value = ""${join("","", data.aws_subnet_ids.public.ids)}""
}

output ""private_subnets"" {
  value = ""${join("","", data.aws_subnet_ids.private.ids)}""
}

output ""linux_service_ami"" {
  value = ""${data.aws_ami.linux.id}""
}

output ""windows_service_ami"" {
  value = ""${data.aws_ami.windows.id}""
}

output ""bucket_name"" {
  value = ""${aws_s3_bucket.mod.id}""
}

output ""instance_profile"" {
  value = ""${aws_iam_instance_profile.ecs.id}""
}

output ""iam_role"" {
  value = ""${aws_iam_role.ecs.id}""
}

output ""log_group"" {
  value = ""${aws_cloudwatch_log_group.mod.id}""
}

output ""user_access_key"" {
  value = ""${aws_iam_access_key.mod.id}""
}

output ""user_secret_key"" {
  value = ""${aws_iam_access_key.mod.secret}""
}

output ""dynamo_tag_table"" {
  value = ""${aws_dynamodb_table.tags.id}""
}

output ""dynamo_job_table"" {
  value = ""${aws_dynamodb_table.jobs.id}""
}


","{
  ""userQuery1"": ""The user wants to create an AWS infrastructure for a Layer0 application. This includes setting up a VPC, subnets, security groups, an ECS cluster, an S3 bucket, a DynamoDB table, and an Elastic Load Balancer. The user also wants to set up autoscaling for the DynamoDB tables."",
  ""userQuery2"": ""The user wants to manage IAM roles, policies, and access keys for the Layer0 application. This includes creating an IAM role for ECS, an IAM user, and an IAM group with specific policies. The user also wants to create an IAM server certificate."",
  ""userQuery3"": ""The user wants to deploy an ECS service and task definition for the Layer0 application. This includes setting up a launch configuration and an autoscaling group for the ECS service. The user also wants to create a CloudWatch log group for the ECS service."",
  ""userQuery4"": ""The user wants to use specific"
80,pdh,kops,tests/integration/update_cluster/ha_gce,"output ""cluster_name"" {
  value = ""ha-gce.example.com""
}

output ""project"" {
  value = ""us-test1""
}

output ""region"" {
  value = ""us-test1""
}

provider ""google"" {
  project = ""us-test1""
  region  = ""us-test1""
}

resource ""google_compute_disk"" ""a-etcd-events-ha-gce-example-com"" {
  name = ""a-etcd-events-ha-gce-example-com""
  type = ""pd-ssd""
  size = 20
  zone = ""us-test1-a""
}

resource ""google_compute_disk"" ""a-etcd-main-ha-gce-example-com"" {
  name = ""a-etcd-main-ha-gce-example-com""
  type = ""pd-ssd""
  size = 20
  zone = ""us-test1-a""
}

resource ""google_compute_disk"" ""b-etcd-events-ha-gce-example-com"" {
  name = ""b-etcd-events-ha-gce-example-com""
  type = ""pd-ssd""
  size = 20
  zone = ""us-test1-b""
}

resource ""google_compute_disk"" ""b-etcd-main-ha-gce-example-com"" {
  name = ""b-etcd-main-ha-gce-example-com""
  type = ""pd-ssd""
  size = 20
  zone = ""us-test1-b""
}

resource ""google_compute_disk"" ""c-etcd-events-ha-gce-example-com"" {
  name = ""c-etcd-events-ha-gce-example-com""
  type = ""pd-ssd""
  size = 20
  zone = ""us-test1-c""
}

resource ""google_compute_disk"" ""c-etcd-main-ha-gce-example-com"" {
  name = ""c-etcd-main-ha-gce-example-com""
  type = ""pd-ssd""
  size = 20
  zone = ""us-test1-c""
}

resource ""google_compute_firewall"" ""cidr-to-master-ha-gce-example-com"" {
  name    = ""cidr-to-master-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
    ports    = [""443""]
  }

  allow = {
    protocol = ""tcp""
    ports    = [""4194""]
  }

  source_ranges = [""100.64.0.0/10""]
  target_tags   = [""ha-gce-example-com-k8s-io-role-master""]
}

resource ""google_compute_firewall"" ""cidr-to-node-ha-gce-example-com"" {
  name    = ""cidr-to-node-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
  }

  allow = {
    protocol = ""udp""
  }

  allow = {
    protocol = ""icmp""
  }

  allow = {
    protocol = ""esp""
  }

  allow = {
    protocol = ""ah""
  }

  allow = {
    protocol = ""sctp""
  }

  source_ranges = [""100.64.0.0/10""]
  target_tags   = [""ha-gce-example-com-k8s-io-role-node""]
}

resource ""google_compute_firewall"" ""kubernetes-master-https-ha-gce-example-com"" {
  name    = ""kubernetes-master-https-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
    ports    = [""443""]
  }

  source_ranges = [""0.0.0.0/0""]
  target_tags   = [""ha-gce-example-com-k8s-io-role-master""]
}

resource ""google_compute_firewall"" ""master-to-master-ha-gce-example-com"" {
  name    = ""master-to-master-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
  }

  allow = {
    protocol = ""udp""
  }

  allow = {
    protocol = ""icmp""
  }

  allow = {
    protocol = ""esp""
  }

  allow = {
    protocol = ""ah""
  }

  allow = {
    protocol = ""sctp""
  }

  target_tags = [""ha-gce-example-com-k8s-io-role-master""]
}

resource ""google_compute_firewall"" ""master-to-node-ha-gce-example-com"" {
  name    = ""master-to-node-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
  }

  allow = {
    protocol = ""udp""
  }

  allow = {
    protocol = ""icmp""
  }

  allow = {
    protocol = ""esp""
  }

  allow = {
    protocol = ""ah""
  }

  allow = {
    protocol = ""sctp""
  }

  target_tags = [""ha-gce-example-com-k8s-io-role-node""]
}

resource ""google_compute_firewall"" ""node-to-master-ha-gce-example-com"" {
  name    = ""node-to-master-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
    ports    = [""443""]
  }

  allow = {
    protocol = ""tcp""
    ports    = [""4194""]
  }

  target_tags = [""ha-gce-example-com-k8s-io-role-master""]
}

resource ""google_compute_firewall"" ""node-to-node-ha-gce-example-com"" {
  name    = ""node-to-node-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
  }

  allow = {
    protocol = ""udp""
  }

  allow = {
    protocol = ""icmp""
  }

  allow = {
    protocol = ""esp""
  }

  allow = {
    protocol = ""ah""
  }

  allow = {
    protocol = ""sctp""
  }

  target_tags = [""ha-gce-example-com-k8s-io-role-node""]
}

resource ""google_compute_firewall"" ""nodeport-external-to-node-ha-gce-example-com"" {
  name    = ""nodeport-external-to-node-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
    ports    = [""30000-32767""]
  }

  allow = {
    protocol = ""udp""
    ports    = [""30000-32767""]
  }

  target_tags = [""ha-gce-example-com-k8s-io-role-node""]
}

resource ""google_compute_firewall"" ""ssh-external-to-master-ha-gce-example-com"" {
  name    = ""ssh-external-to-master-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
    ports    = [""22""]
  }

  source_ranges = [""0.0.0.0/0""]
  target_tags   = [""ha-gce-example-com-k8s-io-role-master""]
}

resource ""google_compute_firewall"" ""ssh-external-to-node-ha-gce-example-com"" {
  name    = ""ssh-external-to-node-ha-gce-example-com""
  network = ""${google_compute_network.default.name}""

  allow = {
    protocol = ""tcp""
    ports    = [""22""]
  }

  source_ranges = [""0.0.0.0/0""]
  target_tags   = [""ha-gce-example-com-k8s-io-role-node""]
}

resource ""google_compute_instance_group_manager"" ""a-master-us-test1-a-ha-gce-example-com"" {
  name               = ""a-master-us-test1-a-ha-gce-example-com""
  zone               = ""us-test1-a""
  base_instance_name = ""master-us-test1-a""
  instance_template  = ""${google_compute_instance_template.master-us-test1-a-ha-gce-example-com.self_link}""
  target_size        = 1
}

resource ""google_compute_instance_group_manager"" ""a-nodes-ha-gce-example-com"" {
  name               = ""a-nodes-ha-gce-example-com""
  zone               = ""us-test1-a""
  base_instance_name = ""nodes""
  instance_template  = ""${google_compute_instance_template.nodes-ha-gce-example-com.self_link}""
  target_size        = 1
}

resource ""google_compute_instance_group_manager"" ""b-master-us-test1-b-ha-gce-example-com"" {
  name               = ""b-master-us-test1-b-ha-gce-example-com""
  zone               = ""us-test1-b""
  base_instance_name = ""master-us-test1-b""
  instance_template  = ""${google_compute_instance_template.master-us-test1-b-ha-gce-example-com.self_link}""
  target_size        = 1
}

resource ""google_compute_instance_group_manager"" ""b-nodes-ha-gce-example-com"" {
  name               = ""b-nodes-ha-gce-example-com""
  zone               = ""us-test1-b""
  base_instance_name = ""nodes""
  instance_template  = ""${google_compute_instance_template.nodes-ha-gce-example-com.self_link}""
  target_size        = 1
}

resource ""google_compute_instance_group_manager"" ""c-master-us-test1-c-ha-gce-example-com"" {
  name               = ""c-master-us-test1-c-ha-gce-example-com""
  zone               = ""us-test1-c""
  base_instance_name = ""master-us-test1-c""
  instance_template  = ""${google_compute_instance_template.master-us-test1-c-ha-gce-example-com.self_link}""
  target_size        = 1
}

resource ""google_compute_instance_group_manager"" ""c-nodes-ha-gce-example-com"" {
  name               = ""c-nodes-ha-gce-example-com""
  zone               = ""us-test1-c""
  base_instance_name = ""nodes""
  instance_template  = ""${google_compute_instance_template.nodes-ha-gce-example-com.self_link}""
  target_size        = 0
}

resource ""google_compute_instance_template"" ""master-us-test1-a-ha-gce-example-com"" {
  can_ip_forward = true
  machine_type   = ""n1-standard-1""

  service_account = {
    scopes = [""https://www.googleapis.com/auth/compute"", ""https://www.googleapis.com/auth/monitoring"", ""https://www.googleapis.com/auth/logging.write"", ""https://www.googleapis.com/auth/devstorage.read_only"", ""https://www.googleapis.com/auth/ndev.clouddns.readwrite""]
  }

  scheduling = {
    automatic_restart   = true
    on_host_maintenance = ""MIGRATE""
    preemptible         = false
  }

  disk = {
    auto_delete  = true
    device_name  = ""persistent-disks-0""
    type         = ""PERSISTENT""
    boot         = true
    source_image = ""https://www.googleapis.com/compute/v1/projects/cos-cloud/global/images/cos-stable-57-9202-64-0""
    mode         = ""READ_WRITE""
    disk_type    = ""pd-standard""
    disk_size_gb = 64
  }

  network_interface = {
    network       = ""${google_compute_network.default.name}""
    access_config = {}
  }

  metadata = {
    cluster-name   = ""${file(""${path.module}/data/google_compute_instance_template_master-us-test1-a-ha-gce-example-com_metadata_cluster-name"")}""
    startup-script = ""${file(""${path.module}/data/google_compute_instance_template_master-us-test1-a-ha-gce-example-com_metadata_startup-script"")}""
  }

  tags        = [""ha-gce-example-com-k8s-io-role-master""]
  name_prefix = ""master-us-test1-a-ha-gce-example-com-""
}

resource ""google_compute_instance_template"" ""master-us-test1-b-ha-gce-example-com"" {
  can_ip_forward = true
  machine_type   = ""n1-standard-1""

  service_account = {
    scopes = [""https://www.googleapis.com/auth/compute"", ""https://www.googleapis.com/auth/monitoring"", ""https://www.googleapis.com/auth/logging.write"", ""https://www.googleapis.com/auth/devstorage.read_only"", ""https://www.googleapis.com/auth/ndev.clouddns.readwrite""]
  }

  scheduling = {
    automatic_restart   = true
    on_host_maintenance = ""MIGRATE""
    preemptible         = false
  }

  disk = {
    auto_delete  = true
    device_name  = ""persistent-disks-0""
    type         = ""PERSISTENT""
    boot         = true
    source_image = ""https://www.googleapis.com/compute/v1/projects/cos-cloud/global/images/cos-stable-57-9202-64-0""
    mode         = ""READ_WRITE""
    disk_type    = ""pd-standard""
    disk_size_gb = 64
  }

  network_interface = {
    network       = ""${google_compute_network.default.name}""
    access_config = {}
  }

  metadata = {
    cluster-name   = ""${file(""${path.module}/data/google_compute_instance_template_master-us-test1-b-ha-gce-example-com_metadata_cluster-name"")}""
    startup-script = ""${file(""${path.module}/data/google_compute_instance_template_master-us-test1-b-ha-gce-example-com_metadata_startup-script"")}""
  }

  tags        = [""ha-gce-example-com-k8s-io-role-master""]
  name_prefix = ""master-us-test1-b-ha-gce-example-com-""
}

resource ""google_compute_instance_template"" ""master-us-test1-c-ha-gce-example-com"" {
  can_ip_forward = true
  machine_type   = ""n1-standard-1""

  service_account = {
    scopes = [""https://www.googleapis.com/auth/compute"", ""https://www.googleapis.com/auth/monitoring"", ""https://www.googleapis.com/auth/logging.write"", ""https://www.googleapis.com/auth/devstorage.read_only"", ""https://www.googleapis.com/auth/ndev.clouddns.readwrite""]
  }

  scheduling = {
    automatic_restart   = true
    on_host_maintenance = ""MIGRATE""
    preemptible         = false
  }

  disk = {
    auto_delete  = true
    device_name  = ""persistent-disks-0""
    type         = ""PERSISTENT""
    boot         = true
    source_image = ""https://www.googleapis.com/compute/v1/projects/cos-cloud/global/images/cos-stable-57-9202-64-0""
    mode         = ""READ_WRITE""
    disk_type    = ""pd-standard""
    disk_size_gb = 64
  }

  network_interface = {
    network       = ""${google_compute_network.default.name}""
    access_config = {}
  }

  metadata = {
    cluster-name   = ""${file(""${path.module}/data/google_compute_instance_template_master-us-test1-c-ha-gce-example-com_metadata_cluster-name"")}""
    startup-script = ""${file(""${path.module}/data/google_compute_instance_template_master-us-test1-c-ha-gce-example-com_metadata_startup-script"")}""
  }

  tags        = [""ha-gce-example-com-k8s-io-role-master""]
  name_prefix = ""master-us-test1-c-ha-gce-example-com-""
}

resource ""google_compute_instance_template"" ""nodes-ha-gce-example-com"" {
  can_ip_forward = true
  machine_type   = ""n1-standard-2""

  service_account = {
    scopes = [""https://www.googleapis.com/auth/compute"", ""https://www.googleapis.com/auth/monitoring"", ""https://www.googleapis.com/auth/logging.write"", ""https://www.googleapis.com/auth/devstorage.read_only""]
  }

  scheduling = {
    automatic_restart   = true
    on_host_maintenance = ""MIGRATE""
    preemptible         = false
  }

  disk = {
    auto_delete  = true
    device_name  = ""persistent-disks-0""
    type         = ""PERSISTENT""
    boot         = true
    source_image = ""https://www.googleapis.com/compute/v1/projects/cos-cloud/global/images/cos-stable-57-9202-64-0""
    mode         = ""READ_WRITE""
    disk_type    = ""pd-standard""
    disk_size_gb = 128
  }

  network_interface = {
    network       = ""${google_compute_network.default.name}""
    access_config = {}
  }

  metadata = {
    cluster-name   = ""${file(""${path.module}/data/google_compute_instance_template_nodes-ha-gce-example-com_metadata_cluster-name"")}""
    startup-script = ""${file(""${path.module}/data/google_compute_instance_template_nodes-ha-gce-example-com_metadata_startup-script"")}""
  }

  tags        = [""ha-gce-example-com-k8s-io-role-node""]
  name_prefix = ""nodes-ha-gce-example-com-""
}

resource ""google_compute_network"" ""default"" {
  name                    = ""default""
  auto_create_subnetworks = true
}

terraform = {
  required_version = "">= 0.9.3""
}


","{
  ""userQuery1"": ""The user wants to create a Google Cloud project named 'us-test1' and set the region to 'us-test1'."",
  ""userQuery2"": ""The user intends to create multiple Google Compute Disks of type 'pd-ssd' with a size of 20GB in different zones ('us-test1-a', 'us-test1-b', 'us-test1-c'). The disks are named following a specific pattern ('a-etcd-events-ha-gce-example-com', 'a-etcd-main-ha-gce-example-com', etc.)."",
  ""userQuery3"": ""The user plans to set up several firewall rules for different purposes, such as allowing specific protocols (TCP, UDP, ICMP, ESP, AH, SCTP) and ports, and targeting specific tags. The firewall rules are named following a specific pattern ('cidr-to-master-ha-gce-example-com', 'cidr-to-node-ha-gce-example"
81,oracle,terraform-provider-baremetal,examples/kms,"// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

provider ""oci"" {
  tenancy_ocid     = var.tenancy_ocid
  user_ocid        = var.user_ocid
  fingerprint      = var.fingerprint
  private_key_path = var.private_key_path
  region           = var.region
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

variable ""tenancy_ocid"" {
}

variable ""user_ocid"" {
}

variable ""fingerprint"" {
}

variable ""private_key_path"" {
}

variable ""region"" {
}

variable ""destination_region"" {
}

variable ""compartment_id"" {
}

variable ""vault_id"" {
}

variable ""key_id"" {
}

variable ""key_display_name"" {
  default = ""Key C""
}

variable ""vault_display_name"" {
  default = ""Vault C""
}

variable ""key_key_shape_algorithm"" {
  default = ""AES""
}

variable ""key_key_shape_length"" {
  default = 32
}

variable ""crypto_endpoint"" {
}

variable ""test_rsa_key_id"" {
}

variable ""test_rsa_key_version"" {
}

# Refer https://docs.us-phoenix-1.oraclecloud.com/Content/Compute/Tasks/managingkeypairs.htm on how to setup SSH key pairs for compute instances
variable ""ssh_public_key"" {
}

variable ""ssh_private_key"" {
}

variable ""instance_shape"" {
  default = ""VM.Standard2.1""
}

variable ""volume_size"" {
  default = ""50""
}

variable ""vault_type"" {
  type    = list(string)
  default = [""DEFAULT"", ""VIRTUAL_PRIVATE""]
}

variable ""instance_image_ocid"" {
  type = map(string)

  default = {
    # See https://docs.us-phoenix-1.oraclecloud.com/images/
    # Oracle-provided image ""Oracle-Linux-7.5-2018.10.16-0""
    us-phoenix-1   = ""ocid1.image.oc1.phx.aaaaaaaaoqj42sokaoh42l76wsyhn3k2beuntrh5maj3gmgmzeyr55zzrwwa""
    us-ashburn-1   = ""ocid1.image.oc1.iad.aaaaaaaageeenzyuxgia726xur4ztaoxbxyjlxogdhreu3ngfj2gji3bayda""
    eu-frankfurt-1 = ""ocid1.image.oc1.eu-frankfurt-1.aaaaaaaaitzn6tdyjer7jl34h2ujz74jwy5nkbukbh55ekp6oyzwrtfa4zma""
    uk-london-1    = ""ocid1.image.oc1.uk-london-1.aaaaaaaa32voyikkkzfxyo4xbdmadc2dmvorfxxgdhpnk6dw64fa3l4jh7wa""
  }
}

variable ""virtual_vault_ids"" {
  type = map(string)

  default = {
    us-phoenix-1 = """"
    us-ashburn-1 = """"
  }
}

variable ""destination"" {
  type    = list(string)
  default = [""BUCKET"", ""PRE_AUTHENTICATED_REQUEST_URI""]
}

variable ""key_restore_trigger"" {
  default = false
}

variable ""vault_restore_trigger"" {
  default = false
}


// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

data ""oci_identity_availability_domain"" ""ad"" {
  compartment_id = var.tenancy_ocid
  ad_number      = 1
}

// Gets the detail of the vault.
data ""oci_kms_vault"" ""test_vault"" {
  #Required
  vault_id = var.vault_id
}

/*
//create a new vault
resource ""oci_kms_vault"" ""test_vault"" {
	#Required
	compartment_id = var.compartment_id
	display_name = var.vault_display_name
	vault_type = var.vault_vault_type
}
*/

// Gets the list of keys in the compartment and vault.
data ""oci_kms_keys"" ""test_keys"" {
  #Required
  compartment_id      = var.compartment_id
  management_endpoint = data.oci_kms_vault.test_vault.management_endpoint

  filter {
    name   = ""display_name""
    values = [var.key_display_name]
  }
}

data ""oci_core_volumes"" ""test_volumes"" {
  compartment_id = var.compartment_id

  filter {
    name   = ""id""
    values = [oci_core_volume.my_volume.id]
  }
}

// Get replication status of a vault.
// Currently only support virtual private vault.
/*data ""oci_kms_replication_status"" ""test_replication_status"" {
  # Required
  management_endpoint = data.oci_kms_vault.test_vault.management_endpoint
  replication_id = data.oci_kms_vault.test_vault.replica_details[0].replication_id
}*/

// List replicas of a vault.
// Currently only support virtual private vault.
/*data ""oci_kms_vault_replicas"" ""test_vault_replicas"" {
  # Required
  vault_id = data.oci_kms_vault.test_vault.id
}*/

//bucket object details where key was backed up
/*data ""oci_objectstorage_object"" ""key_backup_object"" {
  #Required
  bucket    = ""bucket-name""
  namespace = ""namespace""
  object    = ""object""
}*/
//bucket object details where vault was backed up
/*data ""oci_objectstorage_object"" ""vault_backup_object"" {
  #Required
  bucket    = ""bucket-name""
  namespace = ""namespace""
  object    = ""object""
}*/
//Pre-authenticated-request details for key backup
/*data ""oci_objectstorage_preauthrequest"" ""key_backup_preauthenticated_request"" {
  #Required
  bucket    = ""bucket-name""
  namespace = ""namespace""
  par_id    = ""par_id""
}*/
//Pre-authenticated-request for vault backup
/*data ""oci_objectstorage_preauthrequest"" ""vault_backup_preauthenticated_request"" {
  #Required
  bucket    = ""bucket-name""
  namespace = ""namespace""
  par_id    = ""par_id""
}*/


// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

resource ""oci_core_vcn"" ""my_vcn"" {
  cidr_block     = ""10.1.0.0/16""
  compartment_id = var.compartment_id
  display_name   = ""myvcn""
  dns_label      = ""myvcn""
}

resource ""oci_core_internet_gateway"" ""my_internet_gateway"" {
  compartment_id = var.compartment_id
  display_name   = ""my internet gateway""
  vcn_id         = oci_core_vcn.my_vcn.id
}

resource ""oci_core_route_table"" ""my_route_table"" {
  compartment_id = var.compartment_id
  vcn_id         = oci_core_vcn.my_vcn.id
  display_name   = ""my route table""

  route_rules {
    destination       = ""0.0.0.0/0""
    destination_type  = ""CIDR_BLOCK""
    network_entity_id = oci_core_internet_gateway.my_internet_gateway.id
  }
}

resource ""oci_core_subnet"" ""my_subnet"" {
  availability_domain = data.oci_identity_availability_domain.ad.name
  cidr_block          = ""10.1.20.0/24""
  display_name        = ""mysubnet""
  dns_label           = ""mysubnet""
  compartment_id      = var.compartment_id
  vcn_id              = oci_core_vcn.my_vcn.id
  security_list_ids   = [oci_core_vcn.my_vcn.default_security_list_id]
  route_table_id      = oci_core_route_table.my_route_table.id
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

resource ""oci_kms_key"" ""test_key"" {
  #Required
  compartment_id      = var.compartment_id
  display_name        = var.key_display_name
  management_endpoint = data.oci_kms_vault.test_vault.management_endpoint

  key_shape {
    #Required
    algorithm = var.key_key_shape_algorithm
    length    = var.key_key_shape_length
  }

}




resource ""oci_kms_key_version"" ""test_key_version"" {
  #Required
  key_id = oci_kms_key.test_key.id
  management_endpoint = data.oci_kms_vault.test_vault.management_endpoint
}

resource ""oci_kms_vault"" ""private-vault-kms"" {

  compartment_id = var.compartment_id

  display_name = var.vault_display_name
  vault_type   = var.vault_type[0]
}




// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

resource ""oci_kms_sign"" ""test_sign"" {
  crypto_endpoint      = var.crypto_endpoint
  key_id               = var.test_rsa_key_id
  message              = ""message""
  signing_algorithm    = ""SHA_224_RSA_PKCS1_V1_5""
}

output ""kms_test_sign_signature"" {
  value = oci_kms_sign.test_sign.signature
}


// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

resource ""oci_kms_verify"" ""test_verify"" {
  crypto_endpoint      = var.crypto_endpoint
  key_id               = var.test_rsa_key_id
  key_version_id       = var.test_rsa_key_version
  message              = ""message""
  signing_algorithm    = ""SHA_224_RSA_PKCS1_V1_5""
  signature            = oci_kms_sign.test_sign.signature
}


// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

resource ""oci_core_instance"" ""my_instance"" {
  availability_domain = data.oci_identity_availability_domain.ad.name
  compartment_id      = var.compartment_id
  display_name        = ""my instance with FSS access""
  shape               = var.instance_shape

  metadata = {
    ssh_authorized_keys = var.ssh_public_key
  }

  create_vnic_details {
    subnet_id      = oci_core_subnet.my_subnet.id
    hostname_label = ""myinstance""
  }

  source_details {
    source_type = ""image""
    source_id   = var.instance_image_ocid[var.region]
    kms_key_id  = oci_kms_key.test_key.id
  }

  timeouts {
    create = ""60m""
  }
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

resource ""oci_core_volume"" ""my_volume"" {
  availability_domain = data.oci_identity_availability_domain.ad.name
  compartment_id      = var.compartment_id
  display_name        = ""-tf-volume""
  size_in_gbs         = var.volume_size
  kms_key_id          = oci_kms_key.test_key.id
}



// Copyright (c) 2017, 2023, Oracle and/or its affiliates. All rights reserved.
// Licensed under the Mozilla Public License v2.0

output ""key_id"" {
  value = oci_kms_key.test_key.id
}

output ""volumes"" {
  value = data.oci_core_volumes.test_volumes.volumes
}



","{
  ""userQuery1"": ""The user wants to set up a cloud infrastructure on Oracle Cloud Infrastructure (OCI) with specific configurations. This includes setting up a Virtual Cloud Network (VCN), an internet gateway, a route table, and a subnet. The user also wants to specify the availability domain, CIDR block, display name, DNS label, compartment ID, and VCN ID for the subnet."",
  ""userQuery2"": ""The user intends to create a Key Management Service (KMS) key and a KMS key version in OCI. The user wants to specify the compartment ID, display name, management endpoint, algorithm, and length for the key. The user also wants to create a KMS vault with a specific display name and vault type."",
  ""userQuery3"": ""The user wants to create an instance in OCI with specific configurations. This includes specifying the availability domain, compartment ID, display name, shape, SSH authorized keys, subnet ID, hostname label,"
82,GoogleCloudPlatform,cloud-foundation-fabric,modules/net-vpn-ha,"# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

terraform {
  required_version = "">= 1.5.1""
  required_providers {
    google = {
      source  = ""hashicorp/google""
      version = "">= 5.10.0, < 6.0.0"" # tftest
    }
    google-beta = {
      source  = ""hashicorp/google-beta""
      version = "">= 5.10.0, < 6.0.0"" # tftest
    }
  }
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""name"" {
  description = ""VPN Gateway name (if an existing VPN Gateway is not used), and prefix used for dependent resources.""
  type        = string
}

variable ""network"" {
  description = ""VPC used for the gateway and routes.""
  type        = string
}

variable ""peer_gateways"" {
  description = ""Configuration of the (external or GCP) peer gateway.""
  type = map(object({
    external = optional(object({
      redundancy_type = string
      interfaces      = list(string)
      description     = optional(string, ""Terraform managed external VPN gateway"")
    }))
    gcp = optional(string)
  }))
  nullable = false
  default  = {}
  validation {
    condition = alltrue([
      for k, v in var.peer_gateways : (v.external != null) != (v.gcp != null)
    ])
    error_message = ""Peer gateway configuration must define exactly one between `external` and `gcp`.""
  }
}

variable ""project_id"" {
  description = ""Project where resources will be created.""
  type        = string
}

variable ""region"" {
  description = ""Region used for resources.""
  type        = string
}

variable ""router_config"" {
  description = ""Cloud Router configuration for the VPN. If you want to reuse an existing router, set create to false and use name to specify the desired router.""
  type = object({
    create    = optional(bool, true)
    asn       = number
    name      = optional(string)
    keepalive = optional(number)
    custom_advertise = optional(object({
      all_subnets = bool
      ip_ranges   = map(string)
    }))
  })
  nullable = false
}

variable ""tunnels"" {
  description = ""VPN tunnel configurations.""
  type = map(object({
    bgp_peer = object({
      address        = string
      asn            = number
      route_priority = optional(number, 1000)
      custom_advertise = optional(object({
        all_subnets          = bool
        all_vpc_subnets      = bool
        all_peer_vpc_subnets = bool
        ip_ranges            = map(string)
      }))
      ipv6 = optional(object({
        nexthop_address      = optional(string)
        peer_nexthop_address = optional(string)
      }))
    })
    # each BGP session on the same Cloud Router must use a unique /30 CIDR
    # from the 169.254.0.0/16 block.
    bgp_session_range               = string
    ike_version                     = optional(number, 2)
    peer_external_gateway_interface = optional(number)
    peer_gateway                    = optional(string, ""default"")
    router                          = optional(string)
    shared_secret                   = optional(string)
    vpn_gateway_interface           = number
  }))
  default  = {}
  nullable = false
}

variable ""vpn_gateway"" {
  description = ""HA VPN Gateway Self Link for using an existing HA VPN Gateway. Ignored if `vpn_gateway_create` is set to `true`.""
  type        = string
  default     = null
}

variable ""vpn_gateway_create"" {
  description = ""Create HA VPN Gateway. Set to null to avoid creation.""
  type = object({
    description = optional(string, ""Terraform managed external VPN gateway"")
    ipv6        = optional(bool, false)
  })
  default = {}
}



/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

locals {
  peer_gateways_external = {
    for k, v in var.peer_gateways : k => v.external if v.external != null
  }
  peer_gateways_gcp = {
    for k, v in var.peer_gateways : k => v.gcp if v.gcp != null
  }
  router = (
    var.router_config.create
    ? try(google_compute_router.router[0].name, null)
    : var.router_config.name
  )
  vpn_gateway = (
    var.vpn_gateway_create != null
    ? try(google_compute_ha_vpn_gateway.ha_gateway[0].self_link, null)
    : var.vpn_gateway
  )
  secret = random_id.secret.b64_url
}

resource ""google_compute_ha_vpn_gateway"" ""ha_gateway"" {
  count       = var.vpn_gateway_create != null ? 1 : 0
  name        = var.name
  description = var.vpn_gateway_create.description
  project     = var.project_id
  region      = var.region
  network     = var.network
  stack_type  = var.vpn_gateway_create.ipv6 ? ""IPV4_IPV6"" : ""IPV4_ONLY""
}

resource ""google_compute_external_vpn_gateway"" ""external_gateway"" {
  for_each        = local.peer_gateways_external
  name            = ""${var.name}-${each.key}""
  project         = var.project_id
  redundancy_type = each.value.redundancy_type
  description     = each.value.description
  dynamic ""interface"" {
    for_each = each.value.interfaces
    content {
      id         = interface.key
      ip_address = interface.value
    }
  }
}

resource ""google_compute_router"" ""router"" {
  count   = var.router_config.create ? 1 : 0
  name    = coalesce(var.router_config.name, ""vpn-${var.name}"")
  project = var.project_id
  region  = var.region
  network = var.network
  bgp {
    advertise_mode = (
      var.router_config.custom_advertise != null
      ? ""CUSTOM""
      : ""DEFAULT""
    )
    advertised_groups = (
      try(var.router_config.custom_advertise.all_subnets, false)
      ? [""ALL_SUBNETS""]
      : []
    )
    dynamic ""advertised_ip_ranges"" {
      for_each = try(var.router_config.custom_advertise.ip_ranges, {})
      iterator = range
      content {
        range       = range.key
        description = range.value
      }
    }
    keepalive_interval = try(var.router_config.keepalive, null)
    asn                = var.router_config.asn
  }
}

resource ""google_compute_router_peer"" ""bgp_peer"" {
  for_each                  = var.tunnels
  region                    = var.region
  project                   = var.project_id
  name                      = ""${var.name}-${each.key}""
  router                    = coalesce(each.value.router, local.router)
  peer_ip_address           = each.value.bgp_peer.address
  peer_asn                  = each.value.bgp_peer.asn
  advertised_route_priority = each.value.bgp_peer.route_priority
  advertise_mode = (
    try(each.value.bgp_peer.custom_advertise, null) != null
    ? ""CUSTOM""
    : ""DEFAULT""
  )
  advertised_groups = concat(
    try(each.value.bgp_peer.custom_advertise.all_subnets, false) ? [""ALL_SUBNETS""] : [],
    try(each.value.bgp_peer.custom_advertise.all_vpc_subnets, false) ? [""ALL_VPC_SUBNETS""] : [],
    try(each.value.bgp_peer.custom_advertise.all_peer_vpc_subnets, false) ? [""ALL_PEER_VPC_SUBNETS""] : []
  )
  dynamic ""advertised_ip_ranges"" {
    for_each = try(each.value.bgp_peer.custom_advertise.ip_ranges, {})
    iterator = range
    content {
      range       = range.key
      description = range.value
    }
  }
  enable_ipv6               = try(each.value.bgp_peer.ipv6, null) == null ? false : true
  interface                 = google_compute_router_interface.router_interface[each.key].name
  ipv6_nexthop_address      = try(each.value.bgp_peer.ipv6.nexthop_address, null)
  peer_ipv6_nexthop_address = try(each.value.bgp_peer.ipv6.peer_nexthop_address, null)
}

resource ""google_compute_router_interface"" ""router_interface"" {
  for_each = var.tunnels
  project  = var.project_id
  region   = var.region
  name     = ""${var.name}-${each.key}""
  router   = local.router
  # FIXME: can bgp_session_range be null?
  ip_range   = each.value.bgp_session_range == """" ? null : each.value.bgp_session_range
  vpn_tunnel = google_compute_vpn_tunnel.tunnels[each.key].name
}

resource ""google_compute_vpn_tunnel"" ""tunnels"" {
  for_each = var.tunnels
  project  = var.project_id
  region   = var.region
  name     = ""${var.name}-${each.key}""
  router   = local.router
  peer_external_gateway = try(
    google_compute_external_vpn_gateway.external_gateway[each.value.peer_gateway].id,
    null
  )
  peer_external_gateway_interface = each.value.peer_external_gateway_interface
  peer_gcp_gateway = lookup(
    local.peer_gateways_gcp, each.value.peer_gateway, null
  )
  vpn_gateway_interface = each.value.vpn_gateway_interface
  ike_version           = each.value.ike_version
  shared_secret         = coalesce(each.value.shared_secret, local.secret)
  vpn_gateway           = local.vpn_gateway
}

resource ""random_id"" ""secret"" {
  byte_length = 8
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


output ""bgp_peers"" {
  description = ""BGP peer resources.""
  value = {
    for k, v in google_compute_router_peer.bgp_peer : k => v
  }
}

output ""external_gateway"" {
  description = ""External VPN gateway resource.""
  value       = one(google_compute_external_vpn_gateway.external_gateway[*])
}

output ""gateway"" {
  description = ""VPN gateway resource (only if auto-created).""
  value       = one(google_compute_ha_vpn_gateway.ha_gateway[*])
}

output ""id"" {
  description = ""Fully qualified VPN gateway id.""
  value = (
    ""projects/${var.project_id}/regions/${var.region}/vpnGateways/${var.name}""
  )
}

output ""name"" {
  description = ""VPN gateway name (only if auto-created). .""
  value       = one(google_compute_ha_vpn_gateway.ha_gateway[*].name)
}

output ""random_secret"" {
  description = ""Generated secret.""
  value       = local.secret
}

output ""router"" {
  description = ""Router resource (only if auto-created).""
  value       = one(google_compute_router.router[*])
}

output ""router_name"" {
  description = ""Router name.""
  value       = local.router
}

output ""self_link"" {
  description = ""HA VPN gateway self link.""
  value       = local.vpn_gateway
}

output ""tunnel_names"" {
  description = ""VPN tunnel names.""
  value = {
    for name in keys(var.tunnels) :
    name => try(google_compute_vpn_tunnel.tunnels[name].name, null)
  }
}

output ""tunnel_self_links"" {
  description = ""VPN tunnel self links.""
  value = {
    for name in keys(var.tunnels) :
    name => try(google_compute_vpn_tunnel.tunnels[name].self_link, null)
  }
}

output ""tunnels"" {
  description = ""VPN tunnel resources.""
  value = {
    for name in keys(var.tunnels) :
    name => try(google_compute_vpn_tunnel.tunnels[name], null)
  }
}


","{
  ""userQuery1"": ""The user wants to create a High Availability (HA) VPN Gateway in a specific Google Cloud Project and Region. The user has the option to specify the name of the VPN Gateway, the network it should be associated with, and whether it should support IPv6. If the user does not provide a name, a default one will be generated."",
  ""userQuery2"": ""The user wants to set up VPN tunnels with specific configurations. Each tunnel has a BGP peer with its own configuration, including address, ASN, route priority, and custom advertisement settings. The user can also specify the BGP session range, IKE version, peer external gateway interface, peer gateway, router, shared secret, and VPN gateway interface for each tunnel."",
  ""userQuery3"": ""The user wants to create an external VPN gateway with a specific redundancy type and interfaces. The user can also specify the description of the external VPN gateway. If the user does not provide a description"
83,yifan-gu,tectonic-installer,modules/openstack/secgroups,"variable ""cluster_name"" {
  type = ""string""
}

variable ""tectonic_experimental"" {
  default = false
}

variable ""cluster_cidr"" {
  type = ""string""
}


resource ""openstack_networking_secgroup_v2"" ""base"" {
  name        = ""${var.cluster_name}_base""
  description = ""SSH and ICMP""
}

module ""default"" {
  source      = ""rules/default""
  secgroup_id = ""${openstack_networking_secgroup_v2.base.id}""
}

resource ""openstack_networking_secgroup_v2"" ""k8s"" {
  name                 = ""${var.cluster_name}_k8s""
  description          = ""Ports needed by Kubernetes""
  delete_default_rules = true
}

module ""k8s"" {
  source       = ""rules/k8s""
  secgroup_id  = ""${openstack_networking_secgroup_v2.k8s.id}""
  cluster_cidr = ""${var.cluster_cidr}""
}

resource ""openstack_networking_secgroup_v2"" ""k8s_nodes"" {
  name                 = ""${var.cluster_name}_k8s_nodes""
  description          = ""Ports needed by Kubernetes nodes""
  delete_default_rules = true
}

module ""k8s_nodes"" {
  source       = ""rules/k8s_nodes""
  secgroup_id  = ""${openstack_networking_secgroup_v2.k8s_nodes.id}""
  cluster_cidr = ""${var.cluster_cidr}""
}

resource ""openstack_networking_secgroup_v2"" ""etcd"" {
  name                 = ""${var.cluster_name}_etcd""
  description          = ""Ports needed by etcd""
  delete_default_rules = true
}

module ""etcd"" {
  source       = ""rules/etcd""
  secgroup_id  = ""${openstack_networking_secgroup_v2.etcd.id}""
  self_hosted  = ""${var.tectonic_experimental}""
  cluster_cidr = ""${var.cluster_cidr}""
}


output ""secgroup_master_names"" {
  value = [
    ""${openstack_networking_secgroup_v2.base.name}"",
    ""${openstack_networking_secgroup_v2.k8s.name}"",
    ""${openstack_networking_secgroup_v2.etcd.name}"",
  ]
}

output ""secgroup_master_ids"" {
  value = [
    ""${openstack_networking_secgroup_v2.base.id}"",
    ""${openstack_networking_secgroup_v2.k8s.id}"",
    ""${openstack_networking_secgroup_v2.etcd.id}"",
  ]
}

output ""secgroup_node_names"" {
  value = [
    ""${openstack_networking_secgroup_v2.base.name}"",
    ""${openstack_networking_secgroup_v2.k8s.name}"",
  ]
}

output ""secgroup_node_ids"" {
  value = [
    ""${openstack_networking_secgroup_v2.base.id}"",
    ""${openstack_networking_secgroup_v2.k8s.id}"",
    ""${openstack_networking_secgroup_v2.k8s_nodes.id}"",
  ]
}

output ""secgroup_etcd_names"" {
  value = [
    ""${openstack_networking_secgroup_v2.base.name}"",
    ""${openstack_networking_secgroup_v2.etcd.name}"",
  ]
}

output ""secgroup_etcd_ids"" {
  value = [
    ""${openstack_networking_secgroup_v2.base.id}"",
    ""${openstack_networking_secgroup_v2.etcd.id}"",
  ]
}


","{
  ""userQuery1"": ""The user needs to create a Kubernetes cluster with a specific name, which is provided as a variable 'cluster_name'."",
  ""userQuery2"": ""The user wants to set up security groups for different components of the Kubernetes cluster, including the base cluster, Kubernetes-specific services, Kubernetes nodes, and etcd services. Each security group has a unique name derived from the cluster name and its function. The user also wants to delete the default rules for the Kubernetes, Kubernetes nodes, and etcd security groups."",
  ""userQuery3"": ""The user wants to use specific modules to define the rules for each security group. The modules are sourced from 'rules/default', 'rules/k8s', 'rules/k8s_nodes', and 'rules/etcd'. The 'cluster_cidr' variable is passed to the 'k8s', 'k8s_nodes', and 'etcd' modules. The 'tectonic_experimental' variable"
84,aknuds1,tectonic-installer,modules/gcp/network,"/*
Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

## A single GCP network
resource ""google_compute_network"" ""network"" {
  name                    = ""${var.cluster_name}-network""
  auto_create_subnetworks = ""false""
}

## Two subnetworks (masters, workers)
resource ""google_compute_subnetwork"" ""master-subnet"" {
  name          = ""${var.cluster_name}-master-subnet""
  ip_cidr_range = ""${var.master_ip_cidr_range}""
  network       = ""${google_compute_network.network.self_link}""
  region        = ""${var.gcp_region}""
}

resource ""google_compute_subnetwork"" ""worker-subnet"" {
  name          = ""${var.cluster_name}-worker-subnet""
  ip_cidr_range = ""${var.worker_ip_cidr_range}""
  network       = ""${google_compute_network.network.self_link}""
  region        = ""${var.gcp_region}""
}


resource ""google_compute_firewall"" ""etcd-ingress"" {
  name    = ""${var.cluster_name}-etcd-ingress""
  network = ""${google_compute_network.network.name}""

  # ICMP
  allow {
    protocol = ""icmp""
  }

  allow {
    protocol = ""tcp""
    ports    = [""22""] # ssh
  }

  source_ranges = [""0.0.0.0/0""]
  target_tags   = [""tectonic-etcd""]
}

resource ""google_compute_firewall"" ""etcd"" {
  name    = ""${var.cluster_name}-etcd""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""2379"", ""2380"", ""12379""] # etcd and bootstrap-etcd
  }

  source_tags = [""tectonic-etcd""]
  target_tags = [""tectonic-etcd""]
}


resource ""google_compute_firewall"" ""master-ingress"" {
  name    = ""${var.cluster_name}-master-ingress""
  network = ""${google_compute_network.network.name}""

  # ICMP
  allow {
    protocol = ""icmp""
  }

  allow {
    protocol = ""tcp""
    ports    = [""22"", ""80"", ""443""] # ssh, http, https
  }

  source_ranges = [""0.0.0.0/0""]
  target_tags   = [""tectonic-masters""]
}

resource ""google_compute_firewall"" ""master-ingress-heapster"" {
  name    = ""${var.cluster_name}-master-ingress-heapster""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""4194""]
  }

  source_tags = [""tectonic-masters"", ""tectonic-workers""]
  target_tags = [""tectonic-masters""]
}

resource ""google_compute_firewall"" ""master-ingress-flannel"" {
  name    = ""${var.cluster_name}-master-ingress-flannel""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""udp""
    ports    = [""4789""]
  }

  source_tags = [""tectonic-masters"", ""tectonic-workers""]
  target_tags = [""tectonic-masters""]
}

resource ""google_compute_firewall"" ""master-ingress-node-exporter"" {
  name    = ""${var.cluster_name}-master-ingress-node-exporter""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""9100""]
  }

  source_tags = [""tectonic-masters"", ""tectonic-workers""]
  target_tags = [""tectonic-masters""]
}

resource ""google_compute_firewall"" ""master-ingress-kubelet"" {
  name    = ""${var.cluster_name}-master-ingress-kubelet""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""10250"", ""10255""] # insecure and secure ports
  }

  source_tags = [""tectonic-masters"", ""tectonic-workers""]
  target_tags = [""tectonic-masters""]
}

resource ""google_compute_firewall"" ""master-ingress-etcd"" {
  name    = ""${var.cluster_name}-master-ingress-etcd""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""2379"", ""12379""] # etcd and bootstrap-etcd
  }

  source_tags = [""tectonic-masters""]
  target_tags = [""tectonic-masters"", ""tectonic-etcd""]
}

resource ""google_compute_firewall"" ""master-ingress-services"" {
  name    = ""${var.cluster_name}-master-ingress-services""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""30000-32767""]
  }

  source_tags = [""tectonic-masters""]
  target_tags = [""tectonic-masters""]
}


resource ""google_compute_firewall"" ""worker-ingress"" {
  name    = ""${var.cluster_name}-worker-ingress""
  network = ""${google_compute_network.network.name}""

  # ICMP
  allow {
    protocol = ""icmp""
  }

  allow {
    protocol = ""tcp""
    ports    = [""22"", ""80"", ""443""] # ssh, http, https
  }

  source_ranges = [""0.0.0.0/0""]
  target_tags   = [""tectonic-workers""]
}

resource ""google_compute_firewall"" ""worker-ingress-heapster"" {
  name    = ""${var.cluster_name}-worker-ingress-heapster""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""4194""]
  }

  source_tags = [""tectonic-masters"", ""tectonic-workers""]
  target_tags = [""tectonic-workers""]
}

resource ""google_compute_firewall"" ""worker-ingress-flannel"" {
  name    = ""${var.cluster_name}-worker-ingress-flannel""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""udp""
    ports    = [""4789""]
  }

  source_tags = [""tectonic-masters"", ""tectonic-workers""]
  target_tags = [""tectonic-workers""]
}

resource ""google_compute_firewall"" ""worker-ingress-node-exporter"" {
  name    = ""${var.cluster_name}-worker-ingress-node-exporter""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""9100""]
  }

  source_tags = [""tectonic-masters"", ""tectonic-workers""]
  target_tags = [""tectonic-workers""]
}

resource ""google_compute_firewall"" ""worker-ingress-kubelet"" {
  name    = ""${var.cluster_name}-worker-ingress-kubelet""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""10250"", ""10255""] # insecure and secure ports
  }

  source_tags = [""tectonic-masters"", ""tectonic-workers""]
  target_tags = [""tectonic-workers""]
}

resource ""google_compute_firewall"" ""worker-ingress-services"" {
  name    = ""${var.cluster_name}-worker-ingress-services""
  network = ""${google_compute_network.network.name}""

  allow {
    protocol = ""tcp""
    ports    = [""30000-32767""]
  }

  source_tags = [""tectonic-workers""]
  target_tags = [""tectonic-workers""]
}


resource ""google_compute_target_pool"" ""master-targetpool"" {
  name             = ""${var.cluster_name}-master-targetpool""
  session_affinity = ""CLIENT_IP_PROTO""
}

resource ""google_compute_target_pool"" ""worker-targetpool"" {
  name = ""${var.cluster_name}-worker-targetpool""

  health_checks = [
    ""${google_compute_http_health_check.worker-hc.name}"",
  ]
}

resource ""google_compute_http_health_check"" ""worker-hc"" {
  name         = ""${var.cluster_name}-worker-hc""
  request_path = ""/""

  timeout_sec        = 1
  check_interval_sec = 1
}

// api-server/masters lb
// We need to use a global lb for bootstraping
// because of https://issuetracker.google.com/issues/67366622
resource ""google_compute_global_address"" ""masters-ip"" {
  name = ""${var.cluster_name}-masters-ip""
}

resource ""google_compute_global_forwarding_rule"" ""api-external-fwd-rule"" {
  name       = ""${var.cluster_name}-api-external-fwd-rule""
  target     = ""${google_compute_target_tcp_proxy.api-external-tcp-proxy.self_link}""
  ip_address = ""${google_compute_global_address.masters-ip.address}""
  port_range = ""443""
}

resource ""google_compute_target_tcp_proxy"" ""api-external-tcp-proxy"" {
  name            = ""${var.cluster_name}-api-external-tcp-proxy""
  backend_service = ""${google_compute_backend_service.api-backend-service.self_link}""
}

resource ""google_compute_backend_service"" ""api-backend-service"" {
  name             = ""${var.cluster_name}-api-backend-service""
  protocol         = ""TCP""
  port_name        = ""https""
  timeout_sec      = 10
  session_affinity = ""NONE""

  backend {
    group = ""${var.master_instance_group[0]}""
  }

  health_checks = [""${google_compute_health_check.api-health-check.self_link}""]
}

resource ""google_compute_health_check"" ""api-health-check"" {
  name               = ""${var.cluster_name}-api-health-check""
  timeout_sec        = 1
  check_interval_sec = 1

  ssl_health_check {
    port = ""443""
  }
}

resource ""google_compute_address"" ""ingress-ip"" {
  name = ""${var.cluster_name}-ingress-ip""
}

resource ""google_compute_forwarding_rule"" ""ingress-external-http-fwd-rule"" {
  load_balancing_scheme = ""EXTERNAL""
  name                  = ""${var.cluster_name}-ingress-external-http-fwd-rule""
  ip_address            = ""${google_compute_address.ingress-ip.address}""
  region                = ""${var.gcp_region}""
  target                = ""${google_compute_target_pool.worker-targetpool.self_link}""
  port_range            = ""80""
}

resource ""google_compute_forwarding_rule"" ""ingress-external-https-fwd-rule"" {
  load_balancing_scheme = ""EXTERNAL""
  name                  = ""${var.cluster_name}-ingress-external-https-fwd-rule""
  ip_address            = ""${google_compute_address.ingress-ip.address}""
  region                = ""${var.gcp_region}""
  target                = ""${google_compute_target_pool.worker-targetpool.self_link}""
  port_range            = ""443""
}


/*
Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

variable ""gcp_region"" {
  type = ""string""
}

variable ""master_ip_cidr_range"" {
  type = ""string""
}

variable ""worker_ip_cidr_range"" {
  type = ""string""
}

variable ""managed_zone_name"" {
  type = ""string""
}

variable ""cluster_name"" {
  type = ""string""
}

variable ""base_domain"" {
  type = ""string""
}

variable ""master_instance_group"" {
  type = ""list""
}


/*
Copyright 2017 Google Inc.

Licensed under the Apache License, Version 2.0 (the ""License"");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an ""AS IS"" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

output ""master_ip"" {
  value = ""${google_compute_global_address.masters-ip.address}""
}

output ""ingress_ip"" {
  value = ""${google_compute_address.ingress-ip.address}""
}

output ""master_targetpool_self_link"" {
  value = ""${google_compute_target_pool.master-targetpool.self_link}""
}

output ""worker_targetpool_self_link"" {
  value = ""${google_compute_target_pool.worker-targetpool.self_link}""
}

output ""master_subnetwork_name"" {
  value = ""${google_compute_subnetwork.master-subnet.name}""
}

output ""worker_subnetwork_name"" {
  value = ""${google_compute_subnetwork.worker-subnet.name}""
}

output ""tectonic_network_name"" {
  value = ""${google_compute_network.network.name}""
}


","{
  ""userQuery1"": ""The user wants to create a Google Cloud Platform (GCP) network with a specific name that does not automatically create subnetworks."",
  ""userQuery2"": ""The user intends to create two subnetworks within the GCP network, one for masters and one for workers. Each subnetwork should have a specific name, IP CIDR range, and be associated with the previously created network and a specific GCP region."",
  ""userQuery3"": ""The user needs to set up firewall rules for different components of the network, including etcd, master, and worker nodes. These rules should specify the allowed protocols, ports, source ranges, and target tags."",
  ""userQuery4"": ""The user wants to create target pools for master and worker nodes, with specific names and session affinities. The worker target pool should also have a health check associated with it."",
  ""userQuery5"": ""The user intends to set up load"
85,haklop,terraform,examples/aws-two-tier,"# Specify the provider and access details
provider ""aws"" {
    region = ""${var.aws_region}""
}

# Our default security group to access
# the instances over SSH and HTTP
resource ""aws_security_group"" ""default"" {
    name = ""terraform_example""
    description = ""Used in the terraform""

    # SSH access from anywhere
    ingress {
        from_port = 22
        to_port = 22
        protocol = ""tcp""
        cidr_blocks = [""0.0.0.0/0""]
    }

    # HTTP access from anywhere
    ingress {
        from_port = 80
        to_port = 80
        protocol = ""tcp""
        cidr_blocks = [""0.0.0.0/0""]
    }
}


resource ""aws_elb"" ""web"" {
  name = ""terraform-example-elb""

  # The same availability zone as our instance
  availability_zones = [""${aws_instance.web.availability_zone}""]

  listener {
    instance_port = 80
    instance_protocol = ""http""
    lb_port = 80
    lb_protocol = ""http""
  }

  # The instance is registered automatically
  instances = [""${aws_instance.web.id}""]
}


resource ""aws_instance"" ""web"" {
  # The connection block tells our provisioner how to
  # communicate with the resource (instance)
  connection {
    # The default username for our AMI
    user = ""ubuntu""

    # The path to your keyfile
    key_file = ""${var.key_path}""
  }

  instance_type = ""m1.small""

  # Lookup the correct AMI based on the region
  # we specified
  ami = ""${lookup(var.aws_amis, var.aws_region)}""

  # The name of our SSH keypair you've created and downloaded
  # from the AWS console.
  #
  # https://console.aws.amazon.com/ec2/v2/home?region=us-west-2#KeyPairs:
  #
  key_name = ""${var.key_name}""

  # Our Security group to allow HTTP and SSH access
  security_groups = [""${aws_security_group.default.name}""]

  # We run a remote provisioner on the instance after creating it.
  # In this case, we just install nginx and start it. By default,
  # this should be on port 80
  provisioner ""remote-exec"" {
    inline = [
        ""sudo apt-get -y update"",
        ""sudo apt-get -y install nginx"",
        ""sudo service nginx start""
    ]
  }
}


variable ""key_name"" {
    description = ""Name of the SSH keypair to use in AWS.""
}

variable ""key_path"" {
    description = ""Path to the private portion of the SSH key specified.""
}

variable ""aws_region"" {
    description = ""AWS region to launch servers.""
    default = ""us-west-2""
}

# Ubuntu Precise 12.04 LTS (x64)
variable ""aws_amis"" {
    default = {
        eu-west-1 = ""ami-b1cf19c6""
        us-east-1 = ""ami-de7ab6b6""
        us-west-1 = ""ami-3f75767a""
        us-west-2 = ""ami-21f78e11""
    }
}


output ""address"" {
  value = ""${aws_elb.web.dns_name}""
}


","{
""userQuery1"": ""The user wants to set up an AWS instance in a specific region, with the ability to specify the region. The default region is 'us-west-2'."",
""userQuery2"": ""The user wants to create a security group that allows SSH and HTTP access from any location. The security group is named 'terraform_example'."",
""userQuery3"": ""The user wants to create an Elastic Load Balancer (ELB) that listens on port 80 for HTTP traffic and is associated with the created AWS instance."",
""userQuery4"": ""The user wants to create an AWS instance of type 'm1.small' with a specific AMI ID based on the region. The instance should be associated with the created security group and the specified SSH keypair."",
""userQuery5"": ""The user wants to run a provisioner on the created AWS instance that updates the system, installs nginx, and starts the nginx service."",
""userQuery6"": ""The user wants to output the"
86,bashtoni,terraform,examples/aws-ecs-alb,"# Specify the provider and access details
provider ""aws"" {
  region = ""${var.aws_region}""
}

## EC2

### Network

data ""aws_availability_zones"" ""available"" {}

resource ""aws_vpc"" ""main"" {
  cidr_block = ""10.10.0.0/16""
}

resource ""aws_subnet"" ""main"" {
  count             = ""${var.az_count}""
  cidr_block        = ""${cidrsubnet(aws_vpc.main.cidr_block, 8, count.index)}""
  availability_zone = ""${data.aws_availability_zones.available.names[count.index]}""
  vpc_id            = ""${aws_vpc.main.id}""
}

resource ""aws_internet_gateway"" ""gw"" {
  vpc_id = ""${aws_vpc.main.id}""
}

resource ""aws_route_table"" ""r"" {
  vpc_id = ""${aws_vpc.main.id}""

  route {
    cidr_block = ""0.0.0.0/0""
    gateway_id = ""${aws_internet_gateway.gw.id}""
  }
}

resource ""aws_route_table_association"" ""a"" {
  count          = ""${var.az_count}""
  subnet_id      = ""${element(aws_subnet.main.*.id, count.index)}""
  route_table_id = ""${aws_route_table.r.id}""
}

### Compute

resource ""aws_autoscaling_group"" ""app"" {
  name                 = ""tf-test-asg""
  vpc_zone_identifier  = [""${aws_subnet.main.*.id}""]
  min_size             = ""${var.asg_min}""
  max_size             = ""${var.asg_max}""
  desired_capacity     = ""${var.asg_desired}""
  launch_configuration = ""${aws_launch_configuration.app.name}""
}

data ""template_file"" ""cloud_config"" {
  template = ""${file(""${path.module}/cloud-config.yml"")}""

  vars {
    aws_region         = ""${var.aws_region}""
    ecs_cluster_name   = ""${aws_ecs_cluster.main.name}""
    ecs_log_level      = ""info""
    ecs_agent_version  = ""latest""
    ecs_log_group_name = ""${aws_cloudwatch_log_group.ecs.name}""
  }
}

data ""aws_ami"" ""stable_coreos"" {
  most_recent = true

  filter {
    name   = ""description""
    values = [""CoreOS stable *""]
  }

  filter {
    name   = ""architecture""
    values = [""x86_64""]
  }

  filter {
    name   = ""virtualization-type""
    values = [""hvm""]
  }

  owners = [""595879546273""] # CoreOS
}

resource ""aws_launch_configuration"" ""app"" {
  security_groups = [
    ""${aws_security_group.instance_sg.id}"",
  ]

  key_name                    = ""${var.key_name}""
  image_id                    = ""${data.aws_ami.stable_coreos.id}""
  instance_type               = ""${var.instance_type}""
  iam_instance_profile        = ""${aws_iam_instance_profile.app.name}""
  user_data                   = ""${data.template_file.cloud_config.rendered}""
  associate_public_ip_address = true

  lifecycle {
    create_before_destroy = true
  }
}

### Security

resource ""aws_security_group"" ""lb_sg"" {
  description = ""controls access to the application ELB""

  vpc_id = ""${aws_vpc.main.id}""
  name   = ""tf-ecs-lbsg""

  ingress {
    protocol    = ""tcp""
    from_port   = 80
    to_port     = 80
    cidr_blocks = [""0.0.0.0/0""]
  }

  egress {
    from_port = 0
    to_port   = 0
    protocol  = ""-1""

    cidr_blocks = [
      ""0.0.0.0/0"",
    ]
  }
}

resource ""aws_security_group"" ""instance_sg"" {
  description = ""controls direct access to application instances""
  vpc_id      = ""${aws_vpc.main.id}""
  name        = ""tf-ecs-instsg""

  ingress {
    protocol  = ""tcp""
    from_port = 22
    to_port   = 22

    cidr_blocks = [
      ""${var.admin_cidr_ingress}"",
    ]
  }

  ingress {
    protocol  = ""tcp""
    from_port = 8080
    to_port   = 8080

    security_groups = [
      ""${aws_security_group.lb_sg.id}"",
    ]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = ""-1""
    cidr_blocks = [""0.0.0.0/0""]
  }
}

## ECS

resource ""aws_ecs_cluster"" ""main"" {
  name = ""terraform_example_ecs_cluster""
}

data ""template_file"" ""task_definition"" {
  template = ""${file(""${path.module}/task-definition.json"")}""

  vars {
    image_url        = ""ghost:latest""
    container_name   = ""ghost""
    log_group_region = ""${var.aws_region}""
    log_group_name   = ""${aws_cloudwatch_log_group.app.name}""
  }
}

resource ""aws_ecs_task_definition"" ""ghost"" {
  family                = ""tf_example_ghost_td""
  container_definitions = ""${data.template_file.task_definition.rendered}""
}

resource ""aws_ecs_service"" ""test"" {
  name            = ""tf-example-ecs-ghost""
  cluster         = ""${aws_ecs_cluster.main.id}""
  task_definition = ""${aws_ecs_task_definition.ghost.arn}""
  desired_count   = 1
  iam_role        = ""${aws_iam_role.ecs_service.name}""

  load_balancer {
    target_group_arn = ""${aws_alb_target_group.test.id}""
    container_name   = ""ghost""
    container_port   = ""2368""
  }

  depends_on = [
    ""aws_iam_role_policy.ecs_service"",
    ""aws_alb_listener.front_end"",
  ]
}

## IAM

resource ""aws_iam_role"" ""ecs_service"" {
  name = ""tf_example_ecs_role""

  assume_role_policy = <<EOF
{
  ""Version"": ""2008-10-17"",
  ""Statement"": [
    {
      ""Sid"": """",
      ""Effect"": ""Allow"",
      ""Principal"": {
        ""Service"": ""ecs.amazonaws.com""
      },
      ""Action"": ""sts:AssumeRole""
    }
  ]
}
EOF
}

resource ""aws_iam_role_policy"" ""ecs_service"" {
  name = ""tf_example_ecs_policy""
  role = ""${aws_iam_role.ecs_service.name}""

  policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Statement"": [
    {
      ""Effect"": ""Allow"",
      ""Action"": [
        ""ec2:Describe*"",
        ""elasticloadbalancing:DeregisterInstancesFromLoadBalancer"",
        ""elasticloadbalancing:DeregisterTargets"",
        ""elasticloadbalancing:Describe*"",
        ""elasticloadbalancing:RegisterInstancesWithLoadBalancer"",
        ""elasticloadbalancing:RegisterTargets""
      ],
      ""Resource"": ""*""
    }
  ]
}
EOF
}

resource ""aws_iam_instance_profile"" ""app"" {
  name  = ""tf-ecs-instprofile""
  role = ""${aws_iam_role.app_instance.name}""
}

resource ""aws_iam_role"" ""app_instance"" {
  name = ""tf-ecs-example-instance-role""

  assume_role_policy = <<EOF
{
  ""Version"": ""2012-10-17"",
  ""Statement"": [
    {
      ""Sid"": """",
      ""Effect"": ""Allow"",
      ""Principal"": {
        ""Service"": ""ec2.amazonaws.com""
      },
      ""Action"": ""sts:AssumeRole""
    }
  ]
}
EOF
}

data ""template_file"" ""instance_profile"" {
  template = ""${file(""${path.module}/instance-profile-policy.json"")}""

  vars {
    app_log_group_arn = ""${aws_cloudwatch_log_group.app.arn}""
    ecs_log_group_arn = ""${aws_cloudwatch_log_group.ecs.arn}""
  }
}

resource ""aws_iam_role_policy"" ""instance"" {
  name   = ""TfEcsExampleInstanceRole""
  role   = ""${aws_iam_role.app_instance.name}""
  policy = ""${data.template_file.instance_profile.rendered}""
}

## ALB

resource ""aws_alb_target_group"" ""test"" {
  name     = ""tf-example-ecs-ghost""
  port     = 80
  protocol = ""HTTP""
  vpc_id   = ""${aws_vpc.main.id}""
}

resource ""aws_alb"" ""main"" {
  name            = ""tf-example-alb-ecs""
  subnets         = [""${aws_subnet.main.*.id}""]
  security_groups = [""${aws_security_group.lb_sg.id}""]
}

resource ""aws_alb_listener"" ""front_end"" {
  load_balancer_arn = ""${aws_alb.main.id}""
  port              = ""80""
  protocol          = ""HTTP""

  default_action {
    target_group_arn = ""${aws_alb_target_group.test.id}""
    type             = ""forward""
  }
}

## CloudWatch Logs

resource ""aws_cloudwatch_log_group"" ""ecs"" {
  name = ""tf-ecs-group/ecs-agent""
}

resource ""aws_cloudwatch_log_group"" ""app"" {
  name = ""tf-ecs-group/app-ghost""
}


variable ""aws_region"" {
  description = ""The AWS region to create things in.""
  default     = ""us-west-2""
}

variable ""az_count"" {
  description = ""Number of AZs to cover in a given AWS region""
  default     = ""2""
}

variable ""key_name"" {
  description = ""Name of AWS key pair""
}

variable ""instance_type"" {
  default     = ""t2.small""
  description = ""AWS instance type""
}

variable ""asg_min"" {
  description = ""Min numbers of servers in ASG""
  default     = ""1""
}

variable ""asg_max"" {
  description = ""Max numbers of servers in ASG""
  default     = ""2""
}

variable ""asg_desired"" {
  description = ""Desired numbers of servers in ASG""
  default     = ""1""
}

variable ""admin_cidr_ingress"" {
  description = ""CIDR to allow tcp/22 ingress to EC2 instance""
}


output ""instance_security_group"" {
  value = ""${aws_security_group.instance_sg.id}""
}

output ""launch_configuration"" {
  value = ""${aws_launch_configuration.app.id}""
}

output ""asg_name"" {
  value = ""${aws_autoscaling_group.app.id}""
}

output ""elb_hostname"" {
  value = ""${aws_alb.main.dns_name}""
}


","{
  ""userQuery1"": ""The user wants to create a network infrastructure on AWS, which includes a Virtual Private Cloud (VPC) with a specific CIDR block, subnets, an internet gateway, and a route table. The number of subnets is determined by the variable 'az_count'."",
  ""userQuery2"": ""The user intends to set up an auto-scaling group of EC2 instances in the AWS region specified by the variable 'aws_region'. The instances will be of the type specified by the variable 'instance_type', and the minimum, maximum, and desired number of instances are determined by the variables 'asg_min', 'asg_max', and 'asg_desired' respectively. The instances will be launched with a specific AWS key pair, specified by the variable 'key_name'."",
  ""userQuery3"": ""The user wants to set up an Elastic Container Service (ECS) with a specific task definition and service. The ECS cluster"
87,pdh,kops,tests/integration/update_cluster/lifecycle_phases,"output ""cluster_name"" {
  value = ""privateweave.example.com""
}

output ""region"" {
  value = ""us-test-1""
}

output ""vpc_id"" {
  value = ""${aws_vpc.privateweave-example-com.id}""
}

provider ""aws"" {
  region = ""us-test-1""
}

resource ""aws_eip"" ""us-test-1a-privateweave-example-com"" {
  vpc = true
}

resource ""aws_internet_gateway"" ""privateweave-example-com"" {
  vpc_id = ""${aws_vpc.privateweave-example-com.id}""

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""privateweave.example.com""
  }
}

resource ""aws_nat_gateway"" ""us-test-1a-privateweave-example-com"" {
  allocation_id = ""${aws_eip.us-test-1a-privateweave-example-com.id}""
  subnet_id     = ""${aws_subnet.utility-us-test-1a-privateweave-example-com.id}""
}

resource ""aws_route"" ""0-0-0-0--0"" {
  route_table_id         = ""${aws_route_table.privateweave-example-com.id}""
  destination_cidr_block = ""0.0.0.0/0""
  gateway_id             = ""${aws_internet_gateway.privateweave-example-com.id}""
}

resource ""aws_route"" ""private-us-test-1a-0-0-0-0--0"" {
  route_table_id         = ""${aws_route_table.private-us-test-1a-privateweave-example-com.id}""
  destination_cidr_block = ""0.0.0.0/0""
  nat_gateway_id         = ""${aws_nat_gateway.us-test-1a-privateweave-example-com.id}""
}

resource ""aws_route_table"" ""private-us-test-1a-privateweave-example-com"" {
  vpc_id = ""${aws_vpc.privateweave-example-com.id}""

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""private-us-test-1a.privateweave.example.com""
  }
}

resource ""aws_route_table"" ""privateweave-example-com"" {
  vpc_id = ""${aws_vpc.privateweave-example-com.id}""

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""privateweave.example.com""
  }
}

resource ""aws_route_table_association"" ""private-us-test-1a-privateweave-example-com"" {
  subnet_id      = ""${aws_subnet.us-test-1a-privateweave-example-com.id}""
  route_table_id = ""${aws_route_table.private-us-test-1a-privateweave-example-com.id}""
}

resource ""aws_route_table_association"" ""utility-us-test-1a-privateweave-example-com"" {
  subnet_id      = ""${aws_subnet.utility-us-test-1a-privateweave-example-com.id}""
  route_table_id = ""${aws_route_table.privateweave-example-com.id}""
}

resource ""aws_subnet"" ""us-test-1a-privateweave-example-com"" {
  vpc_id            = ""${aws_vpc.privateweave-example-com.id}""
  cidr_block        = ""172.20.32.0/19""
  availability_zone = ""us-test-1a""

  tags = {
    KubernetesCluster                                = ""privateweave.example.com""
    Name                                             = ""us-test-1a.privateweave.example.com""
    ""kubernetes.io/cluster/privateweave.example.com"" = ""owned""
    ""kubernetes.io/role/internal-elb""                = ""1""
  }
}

resource ""aws_subnet"" ""utility-us-test-1a-privateweave-example-com"" {
  vpc_id            = ""${aws_vpc.privateweave-example-com.id}""
  cidr_block        = ""172.20.4.0/22""
  availability_zone = ""us-test-1a""

  tags = {
    KubernetesCluster                                = ""privateweave.example.com""
    Name                                             = ""utility-us-test-1a.privateweave.example.com""
    ""kubernetes.io/cluster/privateweave.example.com"" = ""owned""
    ""kubernetes.io/role/elb""                         = ""1""
  }
}

resource ""aws_vpc"" ""privateweave-example-com"" {
  cidr_block           = ""172.20.0.0/16""
  enable_dns_hostnames = true
  enable_dns_support   = true

  tags = {
    KubernetesCluster                                = ""privateweave.example.com""
    Name                                             = ""privateweave.example.com""
    ""kubernetes.io/cluster/privateweave.example.com"" = ""owned""
  }
}

resource ""aws_vpc_dhcp_options"" ""privateweave-example-com"" {
  domain_name         = ""us-test-1.compute.internal""
  domain_name_servers = [""AmazonProvidedDNS""]

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""privateweave.example.com""
  }
}

resource ""aws_vpc_dhcp_options_association"" ""privateweave-example-com"" {
  vpc_id          = ""${aws_vpc.privateweave-example-com.id}""
  dhcp_options_id = ""${aws_vpc_dhcp_options.privateweave-example-com.id}""
}

terraform = {
  required_version = "">= 0.9.3""
}


output ""bastions_role_arn"" {
  value = ""${aws_iam_role.bastions-privateweave-example-com.arn}""
}

output ""bastions_role_name"" {
  value = ""${aws_iam_role.bastions-privateweave-example-com.name}""
}

output ""cluster_name"" {
  value = ""privateweave.example.com""
}

output ""masters_role_arn"" {
  value = ""${aws_iam_role.masters-privateweave-example-com.arn}""
}

output ""masters_role_name"" {
  value = ""${aws_iam_role.masters-privateweave-example-com.name}""
}

output ""nodes_role_arn"" {
  value = ""${aws_iam_role.nodes-privateweave-example-com.arn}""
}

output ""nodes_role_name"" {
  value = ""${aws_iam_role.nodes-privateweave-example-com.name}""
}

output ""region"" {
  value = ""us-test-1""
}

provider ""aws"" {
  region = ""us-test-1""
}

resource ""aws_iam_instance_profile"" ""bastions-privateweave-example-com"" {
  name = ""bastions.privateweave.example.com""
  role = ""${aws_iam_role.bastions-privateweave-example-com.name}""
}

resource ""aws_iam_instance_profile"" ""masters-privateweave-example-com"" {
  name = ""masters.privateweave.example.com""
  role = ""${aws_iam_role.masters-privateweave-example-com.name}""
}

resource ""aws_iam_instance_profile"" ""nodes-privateweave-example-com"" {
  name = ""nodes.privateweave.example.com""
  role = ""${aws_iam_role.nodes-privateweave-example-com.name}""
}

resource ""aws_iam_role"" ""bastions-privateweave-example-com"" {
  name               = ""bastions.privateweave.example.com""
  assume_role_policy = ""${file(""${path.module}/data/aws_iam_role_bastions.privateweave.example.com_policy"")}""
}

resource ""aws_iam_role"" ""masters-privateweave-example-com"" {
  name               = ""masters.privateweave.example.com""
  assume_role_policy = ""${file(""${path.module}/data/aws_iam_role_masters.privateweave.example.com_policy"")}""
}

resource ""aws_iam_role"" ""nodes-privateweave-example-com"" {
  name               = ""nodes.privateweave.example.com""
  assume_role_policy = ""${file(""${path.module}/data/aws_iam_role_nodes.privateweave.example.com_policy"")}""
}

resource ""aws_iam_role_policy"" ""bastions-privateweave-example-com"" {
  name   = ""bastions.privateweave.example.com""
  role   = ""${aws_iam_role.bastions-privateweave-example-com.name}""
  policy = ""${file(""${path.module}/data/aws_iam_role_policy_bastions.privateweave.example.com_policy"")}""
}

resource ""aws_iam_role_policy"" ""masters-privateweave-example-com"" {
  name   = ""masters.privateweave.example.com""
  role   = ""${aws_iam_role.masters-privateweave-example-com.name}""
  policy = ""${file(""${path.module}/data/aws_iam_role_policy_masters.privateweave.example.com_policy"")}""
}

resource ""aws_iam_role_policy"" ""nodes-privateweave-example-com"" {
  name   = ""nodes.privateweave.example.com""
  role   = ""${aws_iam_role.nodes-privateweave-example-com.name}""
  policy = ""${file(""${path.module}/data/aws_iam_role_policy_nodes.privateweave.example.com_policy"")}""
}

resource ""aws_key_pair"" ""kubernetes-privateweave-example-com-c4a6ed9aa889b9e2c39cd663eb9c7157"" {
  key_name   = ""kubernetes.privateweave.example.com-c4:a6:ed:9a:a8:89:b9:e2:c3:9c:d6:63:eb:9c:71:57""
  public_key = ""${file(""${path.module}/data/aws_key_pair_kubernetes.privateweave.example.com-c4a6ed9aa889b9e2c39cd663eb9c7157_public_key"")}""
}

resource ""aws_security_group"" ""api-elb-privateweave-example-com"" {
  name        = ""api-elb.privateweave.example.com""
  vpc_id      = ""${aws_vpc.privateweave-example-com.id}""
  description = ""Security group for api ELB""

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""api-elb.privateweave.example.com""
  }
}

resource ""aws_security_group"" ""bastion-elb-privateweave-example-com"" {
  name        = ""bastion-elb.privateweave.example.com""
  vpc_id      = ""${aws_vpc.privateweave-example-com.id}""
  description = ""Security group for bastion ELB""

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""bastion-elb.privateweave.example.com""
  }
}

resource ""aws_security_group"" ""bastion-privateweave-example-com"" {
  name        = ""bastion.privateweave.example.com""
  vpc_id      = ""${aws_vpc.privateweave-example-com.id}""
  description = ""Security group for bastion""

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""bastion.privateweave.example.com""
  }
}

resource ""aws_security_group"" ""masters-privateweave-example-com"" {
  name        = ""masters.privateweave.example.com""
  vpc_id      = ""${aws_vpc.privateweave-example-com.id}""
  description = ""Security group for masters""

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""masters.privateweave.example.com""
  }
}

resource ""aws_security_group"" ""nodes-privateweave-example-com"" {
  name        = ""nodes.privateweave.example.com""
  vpc_id      = ""${aws_vpc.privateweave-example-com.id}""
  description = ""Security group for nodes""

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""nodes.privateweave.example.com""
  }
}

resource ""aws_security_group_rule"" ""all-master-to-master"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.masters-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.masters-privateweave-example-com.id}""
  from_port                = 0
  to_port                  = 0
  protocol                 = ""-1""
}

resource ""aws_security_group_rule"" ""all-master-to-node"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.nodes-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.masters-privateweave-example-com.id}""
  from_port                = 0
  to_port                  = 0
  protocol                 = ""-1""
}

resource ""aws_security_group_rule"" ""all-node-to-node"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.nodes-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.nodes-privateweave-example-com.id}""
  from_port                = 0
  to_port                  = 0
  protocol                 = ""-1""
}

resource ""aws_security_group_rule"" ""api-elb-egress"" {
  type              = ""egress""
  security_group_id = ""${aws_security_group.api-elb-privateweave-example-com.id}""
  from_port         = 0
  to_port           = 0
  protocol          = ""-1""
  cidr_blocks       = [""0.0.0.0/0""]
}

resource ""aws_security_group_rule"" ""bastion-egress"" {
  type              = ""egress""
  security_group_id = ""${aws_security_group.bastion-privateweave-example-com.id}""
  from_port         = 0
  to_port           = 0
  protocol          = ""-1""
  cidr_blocks       = [""0.0.0.0/0""]
}

resource ""aws_security_group_rule"" ""bastion-elb-egress"" {
  type              = ""egress""
  security_group_id = ""${aws_security_group.bastion-elb-privateweave-example-com.id}""
  from_port         = 0
  to_port           = 0
  protocol          = ""-1""
  cidr_blocks       = [""0.0.0.0/0""]
}

resource ""aws_security_group_rule"" ""bastion-to-master-ssh"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.masters-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.bastion-privateweave-example-com.id}""
  from_port                = 22
  to_port                  = 22
  protocol                 = ""tcp""
}

resource ""aws_security_group_rule"" ""bastion-to-node-ssh"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.nodes-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.bastion-privateweave-example-com.id}""
  from_port                = 22
  to_port                  = 22
  protocol                 = ""tcp""
}

resource ""aws_security_group_rule"" ""https-api-elb-0-0-0-0--0"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.api-elb-privateweave-example-com.id}""
  from_port         = 443
  to_port           = 443
  protocol          = ""tcp""
  cidr_blocks       = [""0.0.0.0/0""]
}

resource ""aws_security_group_rule"" ""https-elb-to-master"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.masters-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.api-elb-privateweave-example-com.id}""
  from_port                = 443
  to_port                  = 443
  protocol                 = ""tcp""
}

resource ""aws_security_group_rule"" ""master-egress"" {
  type              = ""egress""
  security_group_id = ""${aws_security_group.masters-privateweave-example-com.id}""
  from_port         = 0
  to_port           = 0
  protocol          = ""-1""
  cidr_blocks       = [""0.0.0.0/0""]
}

resource ""aws_security_group_rule"" ""node-egress"" {
  type              = ""egress""
  security_group_id = ""${aws_security_group.nodes-privateweave-example-com.id}""
  from_port         = 0
  to_port           = 0
  protocol          = ""-1""
  cidr_blocks       = [""0.0.0.0/0""]
}

resource ""aws_security_group_rule"" ""node-to-master-tcp-1-4000"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.masters-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.nodes-privateweave-example-com.id}""
  from_port                = 1
  to_port                  = 4000
  protocol                 = ""tcp""
}

resource ""aws_security_group_rule"" ""node-to-master-tcp-4003-65535"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.masters-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.nodes-privateweave-example-com.id}""
  from_port                = 4003
  to_port                  = 65535
  protocol                 = ""tcp""
}

resource ""aws_security_group_rule"" ""node-to-master-udp-1-65535"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.masters-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.nodes-privateweave-example-com.id}""
  from_port                = 1
  to_port                  = 65535
  protocol                 = ""udp""
}

resource ""aws_security_group_rule"" ""ssh-elb-to-bastion"" {
  type                     = ""ingress""
  security_group_id        = ""${aws_security_group.bastion-privateweave-example-com.id}""
  source_security_group_id = ""${aws_security_group.bastion-elb-privateweave-example-com.id}""
  from_port                = 22
  to_port                  = 22
  protocol                 = ""tcp""
}

resource ""aws_security_group_rule"" ""ssh-external-to-bastion-elb-0-0-0-0--0"" {
  type              = ""ingress""
  security_group_id = ""${aws_security_group.bastion-elb-privateweave-example-com.id}""
  from_port         = 22
  to_port           = 22
  protocol          = ""tcp""
  cidr_blocks       = [""0.0.0.0/0""]
}

terraform = {
  required_version = "">= 0.9.3""
}


output ""bastion_security_group_ids"" {
  value = [""${aws_security_group.bastion-privateweave-example-com.id}""]
}

output ""bastions_role_arn"" {
  value = ""${aws_iam_role.bastions-privateweave-example-com.arn}""
}

output ""bastions_role_name"" {
  value = ""${aws_iam_role.bastions-privateweave-example-com.name}""
}

output ""cluster_name"" {
  value = ""privateweave.example.com""
}

output ""master_security_group_ids"" {
  value = [""${aws_security_group.masters-privateweave-example-com.id}""]
}

output ""masters_role_arn"" {
  value = ""${aws_iam_role.masters-privateweave-example-com.arn}""
}

output ""masters_role_name"" {
  value = ""${aws_iam_role.masters-privateweave-example-com.name}""
}

output ""node_security_group_ids"" {
  value = [""${aws_security_group.nodes-privateweave-example-com.id}""]
}

output ""node_subnet_ids"" {
  value = [""${aws_subnet.us-test-1a-privateweave-example-com.id}""]
}

output ""nodes_role_arn"" {
  value = ""${aws_iam_role.nodes-privateweave-example-com.arn}""
}

output ""nodes_role_name"" {
  value = ""${aws_iam_role.nodes-privateweave-example-com.name}""
}

output ""region"" {
  value = ""us-test-1""
}

output ""vpc_id"" {
  value = ""${aws_vpc.privateweave-example-com.id}""
}

provider ""aws"" {
  region = ""us-test-1""
}

resource ""aws_autoscaling_group"" ""bastion-privateweave-example-com"" {
  name                 = ""bastion.privateweave.example.com""
  launch_configuration = ""${aws_launch_configuration.bastion-privateweave-example-com.id}""
  max_size             = 1
  min_size             = 1
  vpc_zone_identifier  = [""${aws_subnet.utility-us-test-1a-privateweave-example-com.id}""]

  tag = {
    key                 = ""KubernetesCluster""
    value               = ""privateweave.example.com""
    propagate_at_launch = true
  }

  tag = {
    key                 = ""Name""
    value               = ""bastion.privateweave.example.com""
    propagate_at_launch = true
  }

  tag = {
    key                 = ""k8s.io/role/bastion""
    value               = ""1""
    propagate_at_launch = true
  }
}

resource ""aws_autoscaling_group"" ""master-us-test-1a-masters-privateweave-example-com"" {
  name                 = ""master-us-test-1a.masters.privateweave.example.com""
  launch_configuration = ""${aws_launch_configuration.master-us-test-1a-masters-privateweave-example-com.id}""
  max_size             = 1
  min_size             = 1
  vpc_zone_identifier  = [""${aws_subnet.us-test-1a-privateweave-example-com.id}""]

  tag = {
    key                 = ""KubernetesCluster""
    value               = ""privateweave.example.com""
    propagate_at_launch = true
  }

  tag = {
    key                 = ""Name""
    value               = ""master-us-test-1a.masters.privateweave.example.com""
    propagate_at_launch = true
  }

  tag = {
    key                 = ""k8s.io/role/master""
    value               = ""1""
    propagate_at_launch = true
  }
}

resource ""aws_autoscaling_group"" ""nodes-privateweave-example-com"" {
  name                 = ""nodes.privateweave.example.com""
  launch_configuration = ""${aws_launch_configuration.nodes-privateweave-example-com.id}""
  max_size             = 2
  min_size             = 2
  vpc_zone_identifier  = [""${aws_subnet.us-test-1a-privateweave-example-com.id}""]

  tag = {
    key                 = ""KubernetesCluster""
    value               = ""privateweave.example.com""
    propagate_at_launch = true
  }

  tag = {
    key                 = ""Name""
    value               = ""nodes.privateweave.example.com""
    propagate_at_launch = true
  }

  tag = {
    key                 = ""k8s.io/role/node""
    value               = ""1""
    propagate_at_launch = true
  }
}

resource ""aws_ebs_volume"" ""us-test-1a-etcd-events-privateweave-example-com"" {
  availability_zone = ""us-test-1a""
  size              = 20
  type              = ""gp2""
  encrypted         = false

  tags = {
    KubernetesCluster    = ""privateweave.example.com""
    Name                 = ""us-test-1a.etcd-events.privateweave.example.com""
    ""k8s.io/etcd/events"" = ""us-test-1a/us-test-1a""
    ""k8s.io/role/master"" = ""1""
  }
}

resource ""aws_ebs_volume"" ""us-test-1a-etcd-main-privateweave-example-com"" {
  availability_zone = ""us-test-1a""
  size              = 20
  type              = ""gp2""
  encrypted         = false

  tags = {
    KubernetesCluster    = ""privateweave.example.com""
    Name                 = ""us-test-1a.etcd-main.privateweave.example.com""
    ""k8s.io/etcd/main""   = ""us-test-1a/us-test-1a""
    ""k8s.io/role/master"" = ""1""
  }
}
resource ""aws_launch_configuration"" ""bastion-privateweave-example-com"" {
  name_prefix                 = ""bastion.privateweave.example.com-""
  image_id                    = ""ami-12345678""
  instance_type               = ""t2.micro""
  key_name                    = ""${aws_key_pair.kubernetes-privateweave-example-com-c4a6ed9aa889b9e2c39cd663eb9c7157.id}""
  iam_instance_profile        = ""${aws_iam_instance_profile.bastions-privateweave-example-com.id}""
  security_groups             = [""${aws_security_group.bastion-privateweave-example-com.id}""]
  associate_public_ip_address = true

  root_block_device = {
    volume_type           = ""gp2""
    volume_size           = 32
    delete_on_termination = true
  }

  lifecycle = {
    create_before_destroy = true
  }
}

resource ""aws_launch_configuration"" ""master-us-test-1a-masters-privateweave-example-com"" {
  name_prefix                 = ""master-us-test-1a.masters.privateweave.example.com-""
  image_id                    = ""ami-12345678""
  instance_type               = ""m3.medium""
  key_name                    = ""${aws_key_pair.kubernetes-privateweave-example-com-c4a6ed9aa889b9e2c39cd663eb9c7157.id}""
  iam_instance_profile        = ""${aws_iam_instance_profile.masters-privateweave-example-com.id}""
  security_groups             = [""${aws_security_group.masters-privateweave-example-com.id}""]
  associate_public_ip_address = false
  user_data                   = ""${file(""${path.module}/data/aws_launch_configuration_master-us-test-1a.masters.privateweave.example.com_user_data"")}""

  root_block_device = {
    volume_type           = ""gp2""
    volume_size           = 64
    delete_on_termination = true
  }

  ephemeral_block_device = {
    device_name  = ""/dev/sdc""
    virtual_name = ""ephemeral0""
  }

  lifecycle = {
    create_before_destroy = true
  }
}

resource ""aws_launch_configuration"" ""nodes-privateweave-example-com"" {
  name_prefix                 = ""nodes.privateweave.example.com-""
  image_id                    = ""ami-12345678""
  instance_type               = ""t2.medium""
  key_name                    = ""${aws_key_pair.kubernetes-privateweave-example-com-c4a6ed9aa889b9e2c39cd663eb9c7157.id}""
  iam_instance_profile        = ""${aws_iam_instance_profile.nodes-privateweave-example-com.id}""
  security_groups             = [""${aws_security_group.nodes-privateweave-example-com.id}""]
  associate_public_ip_address = false
  user_data                   = ""${file(""${path.module}/data/aws_launch_configuration_nodes.privateweave.example.com_user_data"")}""

  root_block_device = {
    volume_type           = ""gp2""
    volume_size           = 128
    delete_on_termination = true
  }

  lifecycle = {
    create_before_destroy = true
  }
}

terraform = {
  required_version = "">= 0.9.3""
}


output ""bastion_security_group_ids"" {
  value = [""${aws_security_group.bastion-privateweave-example-com.id}""]
}

output ""bastions_role_arn"" {
  value = ""${aws_iam_role.bastions-privateweave-example-com.arn}""
}

output ""bastions_role_name"" {
  value = ""${aws_iam_role.bastions-privateweave-example-com.name}""
}

output ""cluster_name"" {
  value = ""privateweave.example.com""
}

output ""master_security_group_ids"" {
  value = [""${aws_security_group.masters-privateweave-example-com.id}""]
}

output ""masters_role_arn"" {
  value = ""${aws_iam_role.masters-privateweave-example-com.arn}""
}

output ""masters_role_name"" {
  value = ""${aws_iam_role.masters-privateweave-example-com.name}""
}

output ""node_security_group_ids"" {
  value = [""${aws_security_group.nodes-privateweave-example-com.id}""]
}

output ""node_subnet_ids"" {
  value = [""${aws_subnet.us-test-1a-privateweave-example-com.id}""]
}

output ""nodes_role_arn"" {
  value = ""${aws_iam_role.nodes-privateweave-example-com.arn}""
}

output ""nodes_role_name"" {
  value = ""${aws_iam_role.nodes-privateweave-example-com.name}""
}

output ""region"" {
  value = ""us-test-1""
}

output ""vpc_id"" {
  value = ""${aws_vpc.privateweave-example-com.id}""
}

provider ""aws"" {
  region = ""us-test-1""
}

resource ""aws_autoscaling_attachment"" ""bastion-privateweave-example-com"" {
  elb                    = ""${aws_elb.bastion-privateweave-example-com.id}""
  autoscaling_group_name = ""${aws_autoscaling_group.bastion-privateweave-example-com.id}""
}

resource ""aws_autoscaling_attachment"" ""master-us-test-1a-masters-privateweave-example-com"" {
  elb                    = ""${aws_elb.api-privateweave-example-com.id}""
  autoscaling_group_name = ""${aws_autoscaling_group.master-us-test-1a-masters-privateweave-example-com.id}""
}


resource ""aws_elb"" ""api-privateweave-example-com"" {
  name = ""api-privateweave-example--l94cb4""

  listener = {
    instance_port     = 443
    instance_protocol = ""TCP""
    lb_port           = 443
    lb_protocol       = ""TCP""
  }

  security_groups = [""${aws_security_group.api-elb-privateweave-example-com.id}""]
  subnets         = [""${aws_subnet.utility-us-test-1a-privateweave-example-com.id}""]

  health_check = {
    target              = ""SSL:443""
    healthy_threshold   = 2
    unhealthy_threshold = 2
    interval            = 10
    timeout             = 5
  }

  idle_timeout = 300

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""api.privateweave.example.com""
  }
}

resource ""aws_elb"" ""bastion-privateweave-example-com"" {
  name = ""bastion-privateweave-exam-fdb6ge""

  listener = {
    instance_port     = 22
    instance_protocol = ""TCP""
    lb_port           = 22
    lb_protocol       = ""TCP""
  }

  security_groups = [""${aws_security_group.bastion-elb-privateweave-example-com.id}""]
  subnets         = [""${aws_subnet.utility-us-test-1a-privateweave-example-com.id}""]

  health_check = {
    target              = ""TCP:22""
    healthy_threshold   = 2
    unhealthy_threshold = 2
    interval            = 10
    timeout             = 5
  }

  idle_timeout = 300

  tags = {
    KubernetesCluster = ""privateweave.example.com""
    Name              = ""bastion.privateweave.example.com""
  }
}


resource ""aws_route53_record"" ""api-privateweave-example-com"" {
  name = ""api.privateweave.example.com""
  type = ""A""

  alias = {
    name                   = ""${aws_elb.api-privateweave-example-com.dns_name}""
    zone_id                = ""${aws_elb.api-privateweave-example-com.zone_id}""
    evaluate_target_health = false
  }

  zone_id = ""/hostedzone/Z1AFAKE1ZON3YO""
}


terraform = {
  required_version = "">= 0.9.3""
}


","{
  ""userQuery1"": ""The user wants to set up a private Kubernetes cluster named 'privateweave.example.com' in the AWS region 'us-test-1'."",
  ""userQuery2"": ""The user wants to create a Virtual Private Cloud (VPC) with the CIDR block '172.20.0.0/16', and enable DNS hostnames and DNS support for it. The VPC should be tagged with the cluster name."",
  ""userQuery3"": ""The user wants to create two subnets within the VPC, one for internal use and the other for utility purposes. Both subnets should be in the availability zone 'us-test-1a'."",
  ""userQuery4"": ""The user wants to set up an Elastic IP, an Internet Gateway, and a NAT Gateway for the VPC. The Internet Gateway and NAT Gateway should be associated with the VPC."",
  ""userQuery5"": ""The user wants to create route"
88,google,exposure-notifications-server,terraform/alerting,"# Copyright 2020 the Exposure Notifications Server authors
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

resource ""google_project_service"" ""services"" {
  project = var.project

  for_each = toset([
    ""monitoring.googleapis.com"",
  ])
  service            = each.value
  disable_on_destroy = false
}


# Copyright 2020 the Exposure Notifications Server authors
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

variable ""project"" {
  type        = string
  description = ""GCP project for key server. Required.""
}

variable ""exposure_hosts"" {
  type        = list(string)
  description = ""List of domains upon which the exposure uploads are served.""
  default     = []
}

variable ""alert-notification-channel-paging"" {
  type = map(any)
  default = {
    email = {
      labels = {
        email_address = ""nobody@example.com""
      }
    }
    slack = {
      labels = {
        channel_name = ""#paging-channel""
        auth_token   = ""abr""
      }
    }
  }
  description = ""Paging notification channels""
}

variable ""alert-notification-channel-non-paging"" {
  type = map(any)
  default = {
    email = {
      labels = {
        email_address = ""nobody@example.com""
      }
    }
    slack = {
      labels = {
        channel_name = ""#non-paging-channel""
        auth_token   = ""non-paging channel""
      }
    }
  }
  description = ""Non-paging notification channels""
}

variable ""alert_on_human_accessed_secret"" {
  type    = bool
  default = true

  description = ""Alert when a human accesses a secret. You must enable DATA_READ audit logs for Secret Manager.""
}

variable ""alert_on_human_decrypted_value"" {
  type    = bool
  default = true

  description = ""Alert when a human accesses a secret. You must enable DATA_READ audit logs for Cloud KMS.""
}

variable ""alert_on_cloud_run_breakglass"" {
  type    = bool
  default = true

  description = ""Alert when a service is deployed that bypassed Binary Authorization.""
}

variable ""capture_export_file_downloads"" {
  type    = bool
  default = true

  description = ""Capture metrics about mobile devices downloading export files. This can be used to create alerts when values drop below acceptable thresholds.""
}

variable ""forward_progress_indicators"" {
  type = map(object({
    metric = string
    window = number
  }))

  description = ""Map of overrides for forward progress indicators. These are merged with the default variables. The window must be in seconds.""
  default     = {}
}

terraform {
  required_version = ""~> 1.2""

  required_providers {
    google = {
      source  = ""hashicorp/google""
      version = ""~> 4.28""
    }
    google-beta = {
      source  = ""hashicorp/google-beta""
      version = ""~> 4.28""
    }
  }
}


# Copyright 2021 the Exposure Notifications Server authors
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

resource ""null_resource"" ""manual-step-to-enable-workspace"" {
  # TODO: remove once
  # https://github.com/hashicorp/terraform-provider-google/issues/2605 is
  # fixed.
  provisioner ""local-exec"" {
    command = <<EOF
    echo -e '>>>> WARNING WARNING WARNING!'
    echo -e '>>>> Please use https://console.cloud.google.com/monitoring/signup?project=${var.project}&nextPath=monitoring to create the first workspace.'
    echo -e '>>>> Terraform cannot create workspace yet, you can only create workspace via the Google Cloud Console.'
    echo -e '>>>> Related doc: https://cloud.google.com/monitoring/workspaces/create#single-project-workspace'
    EOF
  }
}


# Copyright 2020 the Exposure Notifications Server authors
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

locals {
  playbook_prefix = ""https://github.com/google/exposure-notifications-server/blob/main/docs/playbooks/alerts""
  custom_prefix   = ""custom.googleapis.com/opencensus/en-server""

  second = 1
  minute = 60 * local.second
  hour   = 60 * local.minute

  forward_progress_indicators = merge(
    {
      # backup runs every 4h, alert after 2 failures
      ""backup"" = { metric = ""backup/success"", window = 8 * local.hour + 10 * local.minute },

      # cleanup-export runs every 4h, alert after 2 failures
      ""cleanup-export"" = { metric = ""cleanup/export/success"", window = 8 * local.hour + 10 * local.minute },

      # cleanup-exposure runs every 4h, alert after 2 failures
      ""cleanup-exposure"" = { metric = ""cleanup/exposure/success"", window = 8 * local.hour + 10 * local.minute },

      # export-batcher runs every 5m, alert after 3 failures
      ""export-batcher"" = { metric = ""export/batcher/success"", window = 15 * local.minute + 3 * local.minute },

      # export-worker runs every 1m but can take up to 5m to finish, alert
      # after ~2 failures
      ""export-worker"" = { metric = ""export/worker/success"", window = 10 * local.minute + 2 * local.minute },

      # export-importer-schedule runs every 15m, alert after 2 failures
      ""export-importer-schedule"" = { metric = ""export-importer/schedule/success"", window = 30 * local.minute + 5 * local.minute },

      # export-importer-import runs every 5m, alert after 3 failures
      ""export-importer-import"" = { metric = ""export-importer/import/success"", window = 15 * local.minute + 3 * local.minute },

      # jwks runs every 2m, alert after ~15 failures
      ""jwks"" = { metric = ""jwks/success"", window = 30 * local.minute + 5 * local.minute },

      # key-rotation runs every 4h, alert after 2 failures
      ""key-rotation"" = { metric = ""key-rotation/success"", window = 8 * local.hour + 10 * local.minute + 2 * local.minute },

      # mirror runs every 5m but has a default lock time of 15m, alert after 2 failures
      ""mirror"" = { metric = ""mirror/success"", window = 30 * local.minute + 5 * local.minute },
    },
    var.forward_progress_indicators,
  )
}

# This resource creates two conditions for each metric: one if the metric's
# threshold is <= 0 for the duration, and another of the metric is missing for
# the duration. This handles both the case when a job has never run and when a
# job previously ran but is now failing.
resource ""google_monitoring_alert_policy"" ""ForwardProgress"" {
  for_each = local.forward_progress_indicators

  project      = var.project
  display_name = ""ForwardProgress-${each.key}""
  combiner     = ""OR""

  conditions {
    display_name = ""${each.key} failing""

    condition_threshold {
      filter   = ""metric.type = \""${local.custom_prefix}/${each.value.metric}\"" AND resource.type = \""generic_task\""""
      duration = ""${each.value.window}s""

      comparison      = ""COMPARISON_LT""
      threshold_value = 1

      aggregations {
        alignment_period     = ""60s""
        per_series_aligner   = ""ALIGN_DELTA""
        group_by_fields      = [""resource.labels.job""]
        cross_series_reducer = ""REDUCE_SUM""
      }

      trigger {
        count = 1
      }
    }
  }

  conditions {
    display_name = ""${each.key} missing""

    condition_absent {
      filter   = ""metric.type = \""${local.custom_prefix}/${each.value.metric}\"" AND resource.type = \""generic_task\""""
      duration = ""${each.value.window}s""

      aggregations {
        alignment_period     = ""60s""
        per_series_aligner   = ""ALIGN_DELTA""
        group_by_fields      = [""resource.labels.job""]
        cross_series_reducer = ""REDUCE_SUM""
      }
    }
  }

  documentation {
    content   = ""${local.playbook_prefix}/ForwardProgressFailed.md""
    mime_type = ""text/markdown""
  }

  notification_channels = [for x in values(google_monitoring_notification_channel.paging) : x.id]

  depends_on = [
    null_resource.manual-step-to-enable-workspace,
  ]
}

resource ""google_monitoring_alert_policy"" ""probers"" {
  project = var.project

  display_name = ""HostDown""
  combiner     = ""OR""
  conditions {
    display_name = ""Host is unreachable""
    condition_monitoring_query_language {
      duration = ""60s""
      query    = <<-EOT
      fetch
      uptime_url :: monitoring.googleapis.com/uptime_check/check_passed
      | align next_older(1m)
      | every 1m
      | group_by [resource.host], [val: fraction_true(value.check_passed)]
      | condition val < 20 '%'
      EOT
      trigger {
        count = 1
      }
    }
  }

  documentation {
    content   = ""${local.playbook_prefix}/HostDown.md""
    mime_type = ""text/markdown""
  }

  notification_channels = [for x in values(google_monitoring_notification_channel.paging) : x.id]

  depends_on = [
    null_resource.manual-step-to-enable-workspace,
  ]
}

resource ""google_logging_metric"" ""stackdriver_export_error_count"" {
  project     = var.project
  name        = ""stackdriver_export_error_count""
  description = ""Error occurred trying to export metrics to stackdriver""

  filter = <<-EOT
  resource.type=""cloud_run_revision""
  jsonPayload.logger=""stackdriver""
  jsonPayload.message=""failed to export metric""
  EOT

  metric_descriptor {
    metric_kind = ""DELTA""
    unit        = ""1""
    value_type  = ""INT64""
  }
}

resource ""google_monitoring_alert_policy"" ""StackdriverExportFailed"" {
  project      = var.project
  display_name = ""StackdriverExportFailed""
  combiner     = ""OR""
  conditions {
    display_name = ""Stackdriver metric export error rate""
    condition_monitoring_query_language {
      duration = ""900s""
      # NOTE: this query calculates the rate over a 5min window instead of
      # usual 1min window. This is intentional:
      # The rate window should be larger than the interval of the errors.
      # Currently we export to stackdriver every 2min, meaning if the export is
      # constantly failing, our calculated error rate with 1min window will
      # have the number oscillating between 0 and 1, and we would never get an
      # alert beacuase each time the value reaches 0 the timer to trigger the
      # alert is reset.
      #
      # Changing this to 5min window means the condition is ""on"" as soon as
      # there's a single export error and last at least 5min. The alert is
      # firing if the condition is ""on"" for >15min.
      query = <<-EOT
      fetch
      cloud_run_revision::logging.googleapis.com/user/stackdriver_export_error_count
      | align rate(5m)
      | group_by [resource.service_name], [val: sum(value.stackdriver_export_error_count)]
      | condition val > 0
      EOT
      trigger {
        count = 1
      }
    }
  }

  documentation {
    content   = ""${local.playbook_prefix}/StackdriverExportFailed.md""
    mime_type = ""text/markdown""
  }

  notification_channels = [for x in values(google_monitoring_notification_channel.non-paging) : x.id]

  depends_on = [
    null_resource.manual-step-to-enable-workspace,
    google_logging_metric.stackdriver_export_error_count
  ]
}

resource ""google_logging_metric"" ""human_accessed_secret"" {
  name    = ""human_accessed_secret""
  project = var.project
  filter  = <<EOT
protoPayload.@type=""type.googleapis.com/google.cloud.audit.AuditLog""
protoPayload.serviceName=""secretmanager.googleapis.com""
protoPayload.methodName=~""AccessSecretVersion$""
protoPayload.authenticationInfo.principalEmail!~""gserviceaccount.com$""
EOT

  metric_descriptor {
    metric_kind = ""DELTA""
    value_type  = ""INT64""

    labels {
      key         = ""email""
      value_type  = ""STRING""
      description = ""Email address of the violating principal.""
    }
    labels {
      key         = ""secret""
      value_type  = ""STRING""
      description = ""Full resource ID of the secret.""
    }
  }
  label_extractors = {
    ""email""  = ""EXTRACT(protoPayload.authenticationInfo.principalEmail)""
    ""secret"" = ""EXTRACT(protoPayload.resourceName)""
  }
}

resource ""google_logging_metric"" ""human_decrypted_value"" {
  name    = ""human_decrypted_value""
  project = var.project
  filter  = <<EOT
protoPayload.@type=""type.googleapis.com/google.cloud.audit.AuditLog""
protoPayload.serviceName=""cloudkms.googleapis.com""
protoPayload.methodName=""Decrypt""
protoPayload.authenticationInfo.principalEmail!~""gserviceaccount.com$""
EOT

  metric_descriptor {
    metric_kind = ""DELTA""
    value_type  = ""INT64""

    labels {
      key         = ""email""
      value_type  = ""STRING""
      description = ""Email address of the violating principal.""
    }
    labels {
      key         = ""key""
      value_type  = ""STRING""
      description = ""Full resource ID of the key.""
    }
  }
  label_extractors = {
    ""email"" = ""EXTRACT(protoPayload.authenticationInfo.principalEmail)""
    ""key""   = ""EXTRACT(protoPayload.resourceName)""
  }
}

resource ""google_monitoring_alert_policy"" ""HumanAccessedSecret"" {
  count = var.alert_on_human_accessed_secret ? 1 : 0

  project      = var.project
  display_name = ""HumanAccessedSecret""
  combiner     = ""OR""

  conditions {
    display_name = ""A non-service account accessed a secret.""

    condition_monitoring_query_language {
      duration = ""0s""

      query = <<-EOT
      fetch audited_resource
      | metric 'logging.googleapis.com/user/${google_logging_metric.human_accessed_secret.name}'
      | align rate(5m)
      | every 1m
      | group_by [resource.project_id],
          [val: aggregate(value.human_accessed_secret)]
      | condition val > 0
      EOT

      trigger {
        count = 1
      }
    }
  }

  documentation {
    content   = ""${local.playbook_prefix}/HumanAccessedSecret.md""
    mime_type = ""text/markdown""
  }

  notification_channels = [for x in values(google_monitoring_notification_channel.paging) : x.id]
}

resource ""google_monitoring_alert_policy"" ""HumanDecryptedValue"" {
  count = var.alert_on_human_decrypted_value ? 1 : 0

  project      = var.project
  display_name = ""HumanDecryptedValue""
  combiner     = ""OR""

  conditions {
    display_name = ""A non-service account decrypted something.""

    condition_monitoring_query_language {
      duration = ""0s""

      query = <<-EOT
      fetch global
      | metric 'logging.googleapis.com/user/${google_logging_metric.human_decrypted_value.name}'
      | align rate(5m)
      | every 1m
      | group_by [resource.project_id],
          [val: aggregate(value.human_decrypted_value)]
      | condition val > 0
      EOT

      trigger {
        count = 1
      }
    }
  }

  documentation {
    content   = ""${local.playbook_prefix}/HumanDecryptedValue.md""
    mime_type = ""text/markdown""
  }

  notification_channels = [for x in values(google_monitoring_notification_channel.paging) : x.id]
}

resource ""google_logging_metric"" ""export_file_downloaded"" {
  count = var.capture_export_file_downloads ? 1 : 0

  name        = ""export_file_downloaded""
  description = ""Incremented on each export file download.""
  project     = var.project
  filter      = <<EOT
resource.type=""http_load_balancer""
httpRequest.requestUrl=~""/index.txt$""
httpRequest.status=200
EOT

  metric_descriptor {
    metric_kind = ""DELTA""
    value_type  = ""INT64""

    labels {
      key         = ""path""
      value_type  = ""STRING""
      description = ""Path of the export""
    }

    labels {
      key         = ""platform""
      value_type  = ""STRING""
      description = ""Mobile operating system""
    }
  }

  label_extractors = {
    ""path""     = ""REGEXP_EXTRACT(httpRequest.requestUrl, \""https?://.+/(.+)/index\\\\.txt\"")""
    ""platform"" = ""REGEXP_EXTRACT(httpRequest.userAgent, \""(Android|Darwin)\"")""
  }
}

resource ""google_logging_metric"" ""export_archive_downloaded"" {
  count = var.capture_export_file_downloads ? 1 : 0

  name        = ""export_archive_downloaded""
  description = ""Incremented on each export zip file download.""
  project     = var.project
  filter      = <<EOT
resource.type=""http_load_balancer""
httpRequest.requestUrl=~"".zip$""
httpRequest.status=200
EOT

  metric_descriptor {
    metric_kind = ""DELTA""
    value_type  = ""INT64""

    labels {
      key         = ""path""
      value_type  = ""STRING""
      description = ""Path of the export""
    }

    labels {
      key         = ""platform""
      value_type  = ""STRING""
      description = ""Mobile operating system""
    }
  }

  label_extractors = {
    ""path""     = ""REGEXP_EXTRACT(httpRequest.requestUrl, \""https?://.+/(.+/.+)\\\\.zip\"")""
    ""platform"" = ""REGEXP_EXTRACT(httpRequest.userAgent, \""(Android|Darwin)\"")""
  }
}

resource ""google_logging_metric"" ""cloud_run_breakglass"" {
  name    = ""cloud_run_breakglass""
  project = var.project

  filter = <<EOT
protoPayload.@type=""type.googleapis.com/google.cloud.audit.AuditLog""
protoPayload.serviceName=""run.googleapis.com""
protoPayload.status.message:""breakglass""
resource.labels.revision_name!=""""
EOT

  metric_descriptor {
    metric_kind = ""DELTA""
    value_type  = ""INT64""

    labels {
      key         = ""revision""
      value_type  = ""STRING""
      description = ""Name of the revision which was deployed with breakglass""
    }
  }

  label_extractors = {
    ""revision"" = ""EXTRACT(resource.labels.revision_name)""
  }
}

resource ""google_monitoring_alert_policy"" ""CloudRunBreakglass"" {
  count = var.alert_on_cloud_run_breakglass ? 1 : 0

  project      = var.project
  display_name = ""CloudRunBreakglass""
  combiner     = ""OR""

  conditions {
    display_name = ""A service was deployed that bypassed Binary Authorization""

    condition_monitoring_query_language {
      duration = ""0s""

      query = <<-EOT
      fetch global
      | metric 'logging.googleapis.com/user/${google_logging_metric.cloud_run_breakglass.name}'
      | align rate(5m)
      | every 1m
      | group_by [resource.project_id],
          [val: aggregate(value.cloud_run_breakglass)]
      | condition val > 0
      EOT

      trigger {
        count = 1
      }
    }
  }

  documentation {
    content   = ""${local.playbook_prefix}/CloudRunBreakglass.md""
    mime_type = ""text/markdown""
  }

  notification_channels = [for x in values(google_monitoring_notification_channel.paging) : x.id]

  depends_on = [
    null_resource.manual-step-to-enable-workspace,
  ]
}


# Copyright 2020 the Exposure Notifications Server authors
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

resource ""google_monitoring_notification_channel"" ""paging"" {
  provider     = google-beta
  project      = var.project
  display_name = ""Paging Notification Channel""
  type         = each.key
  labels       = each.value.labels
  depends_on = [
    null_resource.manual-step-to-enable-workspace
  ]

  for_each = var.alert-notification-channel-paging
}

resource ""google_monitoring_notification_channel"" ""non-paging"" {
  provider     = google-beta
  project      = var.project
  display_name = ""Non-paging Notification Channel""
  type         = each.key
  labels       = each.value.labels
  depends_on = [
    null_resource.manual-step-to-enable-workspace
  ]

  for_each = var.alert-notification-channel-non-paging
}


# Copyright 2021 the Exposure Notifications Server authors
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

resource ""google_monitoring_uptime_check_config"" ""https"" {
  project = var.project

  for_each = toset(compact(concat(var.exposure_hosts)))

  display_name = each.key
  timeout      = ""10s""
  period       = ""60s""

  http_check {
    path         = ""/health""
    port         = ""443""
    use_ssl      = true
    validate_ssl = true
  }

  monitored_resource {
    type = ""uptime_url""
    labels = {
      project_id = var.project
      host       = each.key
    }
  }

  depends_on = [
    null_resource.manual-step-to-enable-workspace,
  ]
}


# Copyright 2021 the Exposure Notifications Server authors
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

resource ""google_monitoring_dashboard"" ""export-batches"" {
  project        = var.project
  dashboard_json = file(""${path.module}/dashboards/export-batches.json"")
  depends_on = [
    null_resource.manual-step-to-enable-workspace,
  ]
}


","{
  ""userQuery1"": ""The user wants to enable a specific Google Cloud service (monitoring.googleapis.com) for a given project. The project ID is provided as a variable."",
  ""userQuery2"": ""The user wants to set up a series of alert notifications for various events. These events include human access to secrets, decryption of values by humans, service deployment bypassing Binary Authorization, and export file downloads. The user also wants to specify different notification channels for paging and non-paging alerts."",
  ""userQuery3"": ""The user wants to monitor the health of various services and tasks. This includes checking the uptime of certain hosts, tracking the progress of tasks, and monitoring the rate of errors in Stackdriver metric exports. The user also wants to create dashboards for visualizing the status of export batches."",
  ""userQuery4"": ""The user wants to create a series of variables to be used in the configuration. These variables include the project ID, a list of"
89,neerdoc,benevolent,molecular_cloud/protoplanets/swarm-init,"##################################################################################################################
# Create a temporary master node
##################################################################################################################
provider ""digitalocean"" {
  token = ""${var.do_token}""
}

# We need data from the account setup
data ""terraform_remote_state"" ""digitalocean"" {
  backend = ""local""
  config {
    path = ""../../account/00/terraform.tfstate""  }
}

module ""digitalocean_init_manager_node"" {
  source = ""../../../../modules/digitalocean_init_node""

  # Set variables
  droplet_size        = ""${var.droplet_size}""
  droplet_image       = ""${var.droplet_image}""
  droplet_user        = ""${var.droplet_user}""
  index               = ""${var.index}""
  region              = ""${var.region}""
  public_key          = ""${var.public_key}""
  ssh_key_list        = [
    ""${data.terraform_remote_state.digitalocean.ssh_key_id}"",
  ]
  private_key         = ""${var.private_key}""
  system_name         = ""${var.system_name}""
  swarm_token_dir     = ""${var.swarm_token_dir}""
}


output ""ip_address"" {
  value = ""${module.digitalocean_init_manager_node.ip_address}""
}


","{
  ""userQuery1"": ""The user wants to create a temporary master node on DigitalOcean using a specific token for authentication."",
  ""userQuery2"": ""The user needs to retrieve data from a previously set up account, specifically from a local backend located at the path '../../account/00/terraform.tfstate'."",
  ""userQuery3"": ""The user intends to initialize a node on DigitalOcean with specific configurations such as droplet size, image, user, index, region, public key, a list of SSH keys, private key, system name, and swarm token directory."",
  ""userQuery4"": ""The user wants to output the IP address of the initialized node.""
}"
90,GoogleCloudPlatform,beyondcorp-clientconnector,modules/storage,"/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""producer_project_id"" {
  description = ""The ID of the producer project where storage will be created""
  type        = string
}

variable ""prefix"" {
  description = ""The prefix to prepend resource names with""
  type        = string
}

variable ""customer_id"" {
  description = ""The Google Workspace customer ID. See https://support.google.com/cloudidentity/answer/10070793""
  type        = string
}

variable ""service_port"" {
  description = ""Port serving client connections""
  type        = number
}

variable ""client_params"" {
  description = ""The client parameters to store""
  type = object({
    remote_ipv4_addresses = set(string),
    remote_ipv6_addresses = set(string),
    ca_cert_pem           = string,
    private_subnets       = set(string)
  })
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

# Create a storage bucket to store customer's client parameters.
resource ""google_storage_bucket"" ""bucket"" {
  project  = var.producer_project_id
  name     = ""${var.prefix}-${var.customer_id}-bucket""
  location = ""US""

  # Deleting bucket will delete all contained objects.
  force_destroy = true

  # Access is only governed by IAM policies. Disables other ACL controls.
  uniform_bucket_level_access = true
}

# Create object within the bucket containing the client parameters in JSON
# format.
resource ""google_storage_bucket_object"" ""client_params"" {
  name         = ""${var.prefix}-client-params.json""
  bucket       = google_storage_bucket.bucket.name
  content_type = ""application/json""

  # Params to be made available to OpenVPN client.
  content = jsonencode({
    ""connections"" = [
      for ip in concat(
        tolist(var.client_params.remote_ipv6_addresses),
        tolist(var.client_params.remote_ipv4_addresses)
      ) :
      {
        ""remote"" = {
          ""address""  = ip
          ""port""     = var.service_port
          ""protocol"" = ""TCP""
        }
      }
    ],
    ""routes"" = [
      for cidr in var.client_params.private_subnets :
      {
        ""address"" = cidrhost(cidr, 0)
        ""mask""    = cidrnetmask(cidr)
      }
    ],
    ""server_verification"" = {
      ""ca"" = {
        ""ca_pem"" = [var.client_params.ca_cert_pem]
      }
    }
    ""channel_security"" = {
      ""renegotiation"" = {
        ""seconds"" = 0
      }
      ""data_ciphers"" = [""AES-256-GCM""]
    }
  })
}


","{
  ""userQuery1"": ""The user needs to create a storage bucket in the Google Cloud Platform. The bucket should be located in the US, and its name should be a combination of a prefix, the customer's ID, and the word 'bucket'. The bucket should be deleted along with all its contained objects when it's no longer needed. The access to the bucket should be governed only by IAM policies, disabling other ACL controls."",
  ""userQuery2"": ""The user needs to store client parameters in a JSON format within the created bucket. The parameters include remote IPv4 and IPv6 addresses, a CA certificate in PEM format, and private subnets. The name of the object should be a combination of a prefix and the phrase 'client-params.json'. The content type of the object should be 'application/json'."",
  ""userQuery3"": ""The user needs to create a JSON object that includes connection details for each remote IP address (both IPv4 and IPv6"
91,terraform-google-modules,terraform-example-foundation,5-app-infra/business_unit_1/development,"/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  backend ""gcs"" {
    bucket = ""UPDATE_APP_INFRA_BUCKET""
    prefix = ""terraform/app-infra/business_unit_1/development""
  }
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

locals {
  business_unit = ""business_unit_1""
  environment   = ""development""
}

module ""base_shared_gce_instance"" {
  source = ""../../modules/env_base""

  environment         = local.environment
  business_unit       = local.business_unit
  project_suffix      = ""sample-base""
  region              = var.instance_region
  remote_state_bucket = var.remote_state_bucket
}

module ""peering_gce_instance"" {
  source = ""../../modules/env_base""

  environment         = local.environment
  business_unit       = local.business_unit
  project_suffix      = ""sample-peering""
  region              = var.instance_region
  remote_state_bucket = var.remote_state_bucket
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""instance_region"" {
  description = ""The region where compute instance will be created. A subnetwork must exists in the instance region.""
  type        = string
}

variable ""remote_state_bucket"" {
  description = ""Backend bucket to load remote state information from previous steps.""
  type        = string
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""instances_self_links"" {
  description = ""List of self-links for compute instances""
  value       = module.base_shared_gce_instance.instances_self_links
}

output ""instances_names"" {
  description = ""List of names for compute instances""
  value       = [for u in module.base_shared_gce_instance.instances_details : u.name]
  sensitive   = true
}

output ""instances_zones"" {
  description = ""List of zone for compute instances""
  value       = [for u in module.base_shared_gce_instance.instances_details : u.zone]
  sensitive   = true
}

output ""instances_details"" {
  description = ""List of details for compute instances""
  value       = module.base_shared_gce_instance.instances_details
  sensitive   = true
}

output ""available_zones"" {
  description = ""List of available zones in region""
  value       = module.base_shared_gce_instance.available_zones
}

output ""project_id"" {
  description = ""Project where compute instance was created""
  value       = module.base_shared_gce_instance.project_id
}

output ""region"" {
  description = ""Region where compute instance was created""
  value       = module.base_shared_gce_instance.region
}


/**
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">= 0.13""

  required_providers {

    google = {
      source  = ""hashicorp/google""
      version = "">= 3.77, < 6""
    }

    google-beta = {
      source  = ""hashicorp/google-beta""
      version = "">= 3.77, < 6""
    }

    null = {
      source  = ""hashicorp/null""
      version = ""~> 3.0""
    }

    random = {
      source  = ""hashicorp/random""
      version = ""~> 3.1""
    }

  }
}


","{
  ""userQuery1"": ""The user needs to set up a backend for Terraform state files using Google Cloud Storage (GCS). The bucket name needs to be updated and the prefix for the state files should be 'terraform/app-infra/business_unit_1/development'."",
  ""userQuery2"": ""The user intends to create two modules named 'base_shared_gce_instance' and 'peering_gce_instance'. These modules are sourced from a relative path '../../modules/env_base'. The user wants to pass the environment, business unit, project suffix, region, and remote state bucket as variables to these modules."",
  ""userQuery3"": ""The user wants to output several details about the instances created by the 'base_shared_gce_instance' module. These details include self-links, names, zones, and other details of the instances. The user also wants to output the available zones in the region, the project ID where the instance was created, and the region where the"
92,terraform-google-modules,terraform-google-lb-http,test/fixtures/cloudrun,"/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">= 0.13.0""
}


/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""project_id"" {
  description = ""The ID of the project in which to provision resources.""
  type        = string
}


/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ""example"" {
  source     = ""../../../examples/cloudrun""
  project_id = var.project_id
  ssl        = false
  domain     = null
}


/**
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""project_id"" {
  description = ""The ID of the project in which resources are provisioned.""
  value       = var.project_id
}

output ""lb_ip"" {
  value = module.example.load-balancer-ip
}


","{
  ""userQuery1"": ""What is the minimum version of Terraform required to run this configuration?"",
  ""userQuery2"": ""What is the ID of the project in which resources are to be provisioned?"",
  ""userQuery3"": ""What is the source of the 'example' module and what are its parameters?"",
  ""userQuery4"": ""Is SSL enabled for the 'example' module?"",
  ""userQuery5"": ""What is the domain for the 'example' module?"",
  ""userQuery6"": ""What is the output of the project ID after the resources are provisioned?"",
  ""userQuery7"": ""What is the IP address of the load balancer in the 'example' module?""
}"
93,GoogleCloudPlatform,terraform-validator,example,"/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""project_id"" {
  description = ""The project to create resources inside of.""
  type        = string
  default     = null
}

variable ""org_id"" {
  description = ""The organization ID use for creating resources.""
}


output ""project_id"" {
  value = var.project_id
}

output ""org_id"" {
  value = var.org_id
}

/**
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">= 0.12""

  required_providers {
    google = {
      source = ""hashicorp/google""
      version = ""~>3.57.0""
    }
  }
}

provider ""google"" {
  project = var.project_id
}

resource ""google_folder"" ""test"" {
  display_name = ""validator-test""
  parent       = ""organizations/${var.org_id}""
}

resource ""google_project"" ""my_project"" {
  name       = ""test-project""
  project_id = ""test-project-912""
  org_id     = ""organizations/${var.org_id}""
  # folder_id  = google_folder.test.name

  labels  = {
    ""project-label-key-a"" = ""project-label-val-a""
  }
}

resource ""google_compute_disk"" ""my-disk"" {
  name    = ""my-disk""
  project = var.project_id
  type    = ""pd-ssd""
  zone    = ""us-central1-a""
  image   = ""debian-8-jessie-v20170523""

  labels = {
    foo = ""bar""
  }
}

resource ""google_compute_firewall"" ""my-test-firewall"" {
  name    = ""my-test-firewall""
  network = ""default""
  project = var.project_id

  allow {
    protocol = ""icmp""
  }

  allow {
    protocol = ""tcp""
    ports    = [""80"", ""8080"", ""1000-2000""]
  }

  source_tags = [""web""]
}

resource ""random_id"" ""bucket"" {
  byte_length = 8
}

resource ""google_storage_bucket"" ""my-bucket"" {
  name     = ""my-bucket-${random_id.bucket.hex}""
  project  = var.project_id
  location = ""US""

  labels = {
    foo = ""bar""
  }

  website {
    main_page_suffix = ""index.html""
    not_found_page   = ""404.html""
  }

  cors {
    origin = [""*""]
    method = [""POST""]
  }
}

/* Uncomment and change emails to try out IAM policies.
resource ""google_project_iam_member"" ""owner-a"" {
  project = ""${var.project_id}""
  role    = ""roles/owner""
  member  = ""user:example-a@google.com""
}

resource ""google_project_iam_member"" ""viewer-a"" {
  project = ""${var.project_id}""
  role    = ""roles/viewer""
  member  = ""user:example-a@google.com""
}

resource ""google_project_iam_member"" ""viewer-b"" {
  project = ""${var.project_id}""
  role    = ""roles/viewer""
  member  = ""user:example-b@google.com""
}

resource ""google_project_iam_binding"" ""editors"" {
  project = ""${var.project_id}""
  role    = ""roles/editor""
  members  = [
    ""user:example-a@google.com"",
    ""user:example-b@google.com""
  ]
}
*/


","{
  ""userQuery1"": ""The user needs to create a new project in Google Cloud Platform (GCP) with a specific project ID and within a specific organization. The project should be labeled with a key-value pair."",
  ""userQuery2"": ""The user intends to create a new folder within the specified organization in GCP. The folder should have a display name 'validator-test'."",
  ""userQuery3"": ""The user wants to create a new Compute Engine disk in the 'us-central1-a' zone of the project. The disk should be of type 'pd-ssd', use the 'debian-8-jessie-v20170523' image, and be labeled with a key-value pair."",
  ""userQuery4"": ""The user intends to create a new firewall rule in the default network of the project. The rule should allow ICMP and TCP protocols, with TCP allowed on ports 80, 8080, and the range 1000-"
94,kwilczynski,terraform-templates,modules/common/origin,"data ""external"" ""mod"" {
  program = [
    ""bash"",
    ""${path.module}/scripts/origin.sh""
  ]

  query = {
    add_cidr = ""${var.add_cidr}""
  }
}


terraform {
  required_version = "">= 0.10""
}


variable ""add_cidr"" {
  default = true
}


output ""origin"" {
  value = ""${data.external.mod.result.origin}""
}


","{
  ""userQuery1"": ""The user needs to run a bash script named 'origin.sh' located in the 'scripts' directory of the current module."",
  ""userQuery2"": ""The user wants to pass a variable 'add_cidr' to the bash script. The default value of 'add_cidr' is set to true."",
  ""userQuery3"": ""The user wants to ensure that the Terraform version being used is 0.10 or higher."",
  ""userQuery4"": ""The user wants to output the result of the 'origin.sh' script, specifically the 'origin' value.""
}"
95,googleforgames,open-saves,deploy/terraform/gcp,"# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http:#www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

terraform {
  backend ""gcs"" {
    bucket = ""triton-state""
    prefix = ""terraform/state""
  }
}

resource ""google_storage_bucket"" ""triton-gcs-blob"" {
  name          = ""triton-dev-store""
  location      = ""US""
  force_destroy = true
}

resource ""google_storage_bucket"" ""triton-integration"" {
  name          = ""triton-integration""
  location      = ""US""
  force_destroy = true
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

resource ""google_datastore_index"" ""blob_status_updated_at"" {
  kind = ""blob""
  properties {
    name      = ""Status""
    direction = ""ASCENDING""
  }
  properties {
    name      = ""Timestamps.UpdatedAt""
    direction = ""ASCENDING""
  }
}

resource ""google_datastore_index"" ""chunk_status_updated_at"" {
  kind = ""chunk""
  properties {
    name      = ""Status""
    direction = ""ASCENDING""
  }
  properties {
    name      = ""Timestamps.UpdatedAt""
    direction = ""ASCENDING""
  }
}

resource ""google_datastore_index"" ""default_indexed_properties"" {
  kind     = ""record""
  ancestor = ""ALL_ANCESTORS""
  properties {
    name      = ""Properties.prop1""
    direction = ""ASCENDING""
  }
  properties {
    name      = ""Properties.prop1""
    direction = ""DESCENDING""
  }

  properties {
    name      = ""Timestamps.CreatedAt""
    direction = ""ASCENDING""
  }

  properties {
    name      = ""Timestamps.UpdatedAt""
    direction = ""ASCENDING""
  }
}


","{
  ""userQuery1"": ""The user needs a way to manage the state of their Terraform configurations. They want to use Google Cloud Storage (GCS) for this purpose, specifically a bucket named 'triton-state' and a prefix of 'terraform/state'."",
  ""userQuery2"": ""The user wants to create two Google Cloud Storage buckets. The first bucket should be named 'triton-dev-store' and the second should be named 'triton-integration'. Both buckets should be located in the US and should be forcefully destroyed when the Terraform configuration is destroyed."",
  ""userQuery3"": ""The user needs to create three Google Datastore indexes. The first index is for a kind named 'blob' and should index the 'Status' and 'Timestamps.UpdatedAt' properties in ascending order. The second index is for a kind named 'chunk' and should also index the 'Status' and 'Timestamps.UpdatedAt' properties in ascending order. The third"
96,terraform-google-modules,terraform-google-pubsub,,"/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

data ""google_project"" ""project"" {
  project_id = var.project_id
}

locals {
  default_ack_deadline_seconds = 10
  pubsub_svc_account_email     = ""service-${data.google_project.project.number}@gcp-sa-pubsub.iam.gserviceaccount.com""
}

resource ""google_pubsub_schema"" ""schema"" {
  count      = var.schema != null ? 1 : 0
  project    = var.project_id
  name       = var.schema.name
  type       = var.schema.type
  definition = var.schema.definition
}

resource ""google_project_iam_member"" ""bigquery_metadata_viewer_binding"" {
  count   = length(var.bigquery_subscriptions) != 0 ? 1 : 0
  project = var.project_id
  role    = ""roles/bigquery.metadataViewer""
  member  = ""serviceAccount:${local.pubsub_svc_account_email}""
}

resource ""google_project_iam_member"" ""bigquery_data_editor_binding"" {
  count   = length(var.bigquery_subscriptions) != 0 ? 1 : 0
  project = var.project_id
  role    = ""roles/bigquery.dataEditor""
  member  = ""serviceAccount:${local.pubsub_svc_account_email}""
}

resource ""google_project_iam_member"" ""storage_admin_binding"" {
  count   = length(var.cloud_storage_subscriptions) != 0 ? 1 : 0
  project = var.project_id
  role    = ""roles/storage.admin""
  member  = ""serviceAccount:${local.pubsub_svc_account_email}""
}

resource ""google_project_iam_member"" ""token_creator_binding"" {
  count   = var.grant_token_creator ? 1 : 0
  project = var.project_id
  role    = ""roles/iam.serviceAccountTokenCreator""
  member  = ""serviceAccount:${local.pubsub_svc_account_email}""
  depends_on = [
    google_pubsub_subscription.push_subscriptions,
  ]
}

resource ""google_pubsub_topic_iam_member"" ""push_topic_binding"" {
  for_each = var.create_topic ? { for i in var.push_subscriptions : i.name => i if try(i.dead_letter_topic, """") != """" } : {}

  project = var.project_id
  topic   = each.value.dead_letter_topic
  role    = ""roles/pubsub.publisher""
  member  = ""serviceAccount:${local.pubsub_svc_account_email}""
  depends_on = [
    google_pubsub_topic.topic,
  ]
}

resource ""google_pubsub_topic_iam_member"" ""pull_topic_binding"" {
  for_each = var.create_topic ? { for i in var.pull_subscriptions : i.name => i if try(i.dead_letter_topic, """") != """" } : {}

  project = var.project_id
  topic   = each.value.dead_letter_topic
  role    = ""roles/pubsub.publisher""
  member  = ""serviceAccount:${local.pubsub_svc_account_email}""
  depends_on = [
    google_pubsub_topic.topic,
  ]
}

resource ""google_pubsub_topic_iam_member"" ""bigquery_topic_binding"" {
  for_each = var.create_topic ? { for i in var.bigquery_subscriptions : i.name => i if try(i.dead_letter_topic, """") != """" } : {}

  project = var.project_id
  topic   = each.value.dead_letter_topic
  role    = ""roles/pubsub.publisher""
  member  = ""serviceAccount:${local.pubsub_svc_account_email}""
  depends_on = [
    google_pubsub_topic.topic,
  ]
}

resource ""google_pubsub_subscription_iam_member"" ""pull_subscription_binding"" {
  for_each = var.create_subscriptions ? { for i in var.pull_subscriptions : i.name => i if try(i.dead_letter_topic, """") != """" } : {}

  project      = var.project_id
  subscription = each.value.name
  role         = ""roles/pubsub.subscriber""
  member       = ""serviceAccount:${local.pubsub_svc_account_email}""
  depends_on = [
    google_pubsub_subscription.pull_subscriptions,
  ]
}

resource ""google_pubsub_subscription_iam_member"" ""push_subscription_binding"" {
  for_each = var.create_subscriptions ? { for i in var.push_subscriptions : i.name => i if try(i.dead_letter_topic, """") != """" } : {}

  project      = var.project_id
  subscription = each.value.name
  role         = ""roles/pubsub.subscriber""
  member       = ""serviceAccount:${local.pubsub_svc_account_email}""
  depends_on = [
    google_pubsub_subscription.push_subscriptions,
  ]
}

resource ""google_pubsub_subscription_iam_member"" ""bigquery_subscription_binding"" {
  for_each = var.create_subscriptions ? { for i in var.bigquery_subscriptions : i.name => i if try(i.dead_letter_topic, """") != """" } : {}

  project      = var.project_id
  subscription = each.value.name
  role         = ""roles/pubsub.subscriber""
  member       = ""serviceAccount:${local.pubsub_svc_account_email}""
  depends_on = [
    google_pubsub_subscription.bigquery_subscriptions,
  ]
}

resource ""google_pubsub_topic"" ""topic"" {
  count                      = var.create_topic ? 1 : 0
  project                    = var.project_id
  name                       = var.topic
  labels                     = var.topic_labels
  kms_key_name               = var.topic_kms_key_name
  message_retention_duration = var.topic_message_retention_duration

  dynamic ""message_storage_policy"" {
    for_each = var.message_storage_policy
    content {
      allowed_persistence_regions = message_storage_policy.key == ""allowed_persistence_regions"" ? message_storage_policy.value : null
    }
  }

  dynamic ""schema_settings"" {
    for_each = var.schema != null ? [var.schema] : []
    content {
      schema   = google_pubsub_schema.schema[0].id
      encoding = lookup(schema_settings.value, ""encoding"", null)
    }
  }
  depends_on = [google_pubsub_schema.schema]
}

resource ""google_pubsub_subscription"" ""push_subscriptions"" {
  for_each = var.create_subscriptions ? { for i in var.push_subscriptions : i.name => i } : {}

  name    = each.value.name
  topic   = var.create_topic ? google_pubsub_topic.topic[0].name : var.topic
  project = var.project_id
  labels  = var.subscription_labels
  ack_deadline_seconds = lookup(
    each.value,
    ""ack_deadline_seconds"",
    local.default_ack_deadline_seconds,
  )
  message_retention_duration = lookup(
    each.value,
    ""message_retention_duration"",
    null,
  )
  retain_acked_messages = lookup(
    each.value,
    ""retain_acked_messages"",
    null,
  )
  filter = lookup(
    each.value,
    ""filter"",
    null,
  )
  dynamic ""expiration_policy"" {
    // check if the 'expiration_policy' key exists, if yes, return a list containing it.
    for_each = contains(keys(each.value), ""expiration_policy"") ? [each.value.expiration_policy] : []
    content {
      ttl = expiration_policy.value
    }
  }

  dynamic ""dead_letter_policy"" {
    for_each = (lookup(each.value, ""dead_letter_topic"", """") != """") ? [each.value.dead_letter_topic] : []
    content {
      dead_letter_topic     = lookup(each.value, ""dead_letter_topic"", """")
      max_delivery_attempts = lookup(each.value, ""max_delivery_attempts"", ""5"")
    }
  }

  dynamic ""retry_policy"" {
    for_each = (lookup(each.value, ""maximum_backoff"", """") != """") ? [each.value.maximum_backoff] : []
    content {
      maximum_backoff = lookup(each.value, ""maximum_backoff"", """")
      minimum_backoff = lookup(each.value, ""minimum_backoff"", """")
    }
  }

  push_config {
    push_endpoint = each.value[""push_endpoint""]

    // FIXME: This should be programmable, but nested map isn't supported at this time.
    //   https://github.com/hashicorp/terraform/issues/2114
    attributes = {
      x-goog-version = lookup(each.value, ""x-goog-version"", ""v1"")
    }

    dynamic ""oidc_token"" {
      for_each = (lookup(each.value, ""oidc_service_account_email"", """") != """") ? [true] : []
      content {
        service_account_email = lookup(each.value, ""oidc_service_account_email"", """")
        audience              = lookup(each.value, ""audience"", """")
      }
    }
  }
  depends_on = [
    google_pubsub_topic.topic,
  ]
}

resource ""google_pubsub_subscription"" ""pull_subscriptions"" {
  for_each = var.create_subscriptions ? { for i in var.pull_subscriptions : i.name => i } : {}

  name    = each.value.name
  topic   = var.create_topic ? google_pubsub_topic.topic[0].name : var.topic
  project = var.project_id
  labels  = var.subscription_labels
  enable_exactly_once_delivery = lookup(
    each.value,
    ""enable_exactly_once_delivery"",
    null,
  )
  ack_deadline_seconds = lookup(
    each.value,
    ""ack_deadline_seconds"",
    local.default_ack_deadline_seconds,
  )
  message_retention_duration = lookup(
    each.value,
    ""message_retention_duration"",
    null,
  )
  retain_acked_messages = lookup(
    each.value,
    ""retain_acked_messages"",
    null,
  )
  filter = lookup(
    each.value,
    ""filter"",
    null,
  )
  enable_message_ordering = lookup(
    each.value,
    ""enable_message_ordering"",
    null,
  )
  dynamic ""expiration_policy"" {
    // check if the 'expiration_policy' key exists, if yes, return a list containing it.
    for_each = contains(keys(each.value), ""expiration_policy"") ? [each.value.expiration_policy] : []
    content {
      ttl = expiration_policy.value
    }
  }

  dynamic ""dead_letter_policy"" {
    for_each = (lookup(each.value, ""dead_letter_topic"", """") != """") ? [each.value.dead_letter_topic] : []
    content {
      dead_letter_topic     = lookup(each.value, ""dead_letter_topic"", """")
      max_delivery_attempts = lookup(each.value, ""max_delivery_attempts"", ""5"")
    }
  }

  dynamic ""retry_policy"" {
    for_each = (lookup(each.value, ""maximum_backoff"", """") != """") ? [each.value.maximum_backoff] : []
    content {
      maximum_backoff = lookup(each.value, ""maximum_backoff"", """")
      minimum_backoff = lookup(each.value, ""minimum_backoff"", """")
    }
  }

  depends_on = [
    google_pubsub_topic.topic,
  ]
}

resource ""google_pubsub_subscription"" ""bigquery_subscriptions"" {
  for_each = var.create_subscriptions ? { for i in var.bigquery_subscriptions : i.name => i } : {}

  name    = each.value.name
  topic   = var.create_topic ? google_pubsub_topic.topic[0].name : var.topic
  project = var.project_id
  labels  = var.subscription_labels
  ack_deadline_seconds = lookup(
    each.value,
    ""ack_deadline_seconds"",
    local.default_ack_deadline_seconds,
  )
  message_retention_duration = lookup(
    each.value,
    ""message_retention_duration"",
    null,
  )
  retain_acked_messages = lookup(
    each.value,
    ""retain_acked_messages"",
    null,
  )
  filter = lookup(
    each.value,
    ""filter"",
    null,
  )
  enable_message_ordering = lookup(
    each.value,
    ""enable_message_ordering"",
    null,
  )
  dynamic ""expiration_policy"" {
    // check if the 'expiration_policy' key exists, if yes, return a list containing it.
    for_each = contains(keys(each.value), ""expiration_policy"") ? [each.value.expiration_policy] : []
    content {
      ttl = expiration_policy.value
    }
  }

  dynamic ""dead_letter_policy"" {
    for_each = (lookup(each.value, ""dead_letter_topic"", """") != """") ? [each.value.dead_letter_topic] : []
    content {
      dead_letter_topic     = lookup(each.value, ""dead_letter_topic"", """")
      max_delivery_attempts = lookup(each.value, ""max_delivery_attempts"", ""5"")
    }
  }

  dynamic ""retry_policy"" {
    for_each = (lookup(each.value, ""maximum_backoff"", """") != """") ? [each.value.maximum_backoff] : []
    content {
      maximum_backoff = lookup(each.value, ""maximum_backoff"", """")
      minimum_backoff = lookup(each.value, ""minimum_backoff"", """")
    }
  }

  bigquery_config {
    table               = each.value[""table""]
    use_topic_schema    = lookup(each.value, ""use_topic_schema"", false)
    write_metadata      = lookup(each.value, ""write_metadata"", false)
    drop_unknown_fields = lookup(each.value, ""drop_unknown_fields"", false)
  }

  depends_on = [
    google_pubsub_topic.topic,
    google_project_iam_member.bigquery_metadata_viewer_binding,
    google_project_iam_member.bigquery_data_editor_binding
  ]
}

resource ""google_pubsub_subscription"" ""cloud_storage_subscriptions"" {
  for_each = var.create_subscriptions ? { for i in var.cloud_storage_subscriptions : i.name => i } : {}

  name    = each.value.name
  topic   = var.create_topic ? google_pubsub_topic.topic[0].name : var.topic
  project = var.project_id
  labels  = var.subscription_labels
  ack_deadline_seconds = lookup(
    each.value,
    ""ack_deadline_seconds"",
    local.default_ack_deadline_seconds,
  )
  message_retention_duration = lookup(
    each.value,
    ""message_retention_duration"",
    null,
  )
  retain_acked_messages = lookup(
    each.value,
    ""retain_acked_messages"",
    null,
  )
  filter = lookup(
    each.value,
    ""filter"",
    null,
  )
  enable_message_ordering = lookup(
    each.value,
    ""enable_message_ordering"",
    null,
  )
  dynamic ""expiration_policy"" {
    // check if the 'expiration_policy' key exists, if yes, return a list containing it.
    for_each = contains(keys(each.value), ""expiration_policy"") ? [each.value.expiration_policy] : []
    content {
      ttl = expiration_policy.value
    }
  }

  dynamic ""dead_letter_policy"" {
    for_each = (lookup(each.value, ""dead_letter_topic"", """") != """") ? [each.value.dead_letter_topic] : []
    content {
      dead_letter_topic     = lookup(each.value, ""dead_letter_topic"", """")
      max_delivery_attempts = lookup(each.value, ""max_delivery_attempts"", ""5"")
    }
  }

  dynamic ""retry_policy"" {
    for_each = (lookup(each.value, ""maximum_backoff"", """") != """") ? [each.value.maximum_backoff] : []
    content {
      maximum_backoff = lookup(each.value, ""maximum_backoff"", """")
      minimum_backoff = lookup(each.value, ""minimum_backoff"", """")
    }
  }

  cloud_storage_config {
    bucket          = each.value[""bucket""]
    filename_prefix = lookup(each.value, ""filename_prefix"", null)
    filename_suffix = lookup(each.value, ""filename_suffix"", null)
    max_duration    = lookup(each.value, ""max_duration"", null)
    max_bytes       = lookup(each.value, ""max_bytes"", null)
    dynamic ""avro_config"" {
      for_each = (lookup(each.value, ""output_format"", """") == ""avro"") ? [true] : []
      content {
        write_metadata = lookup(each.value, ""write_metadata"", null)
      }
    }
  }

  depends_on = [
    google_pubsub_topic.topic,
    google_project_iam_member.storage_admin_binding
  ]
}

resource ""google_pubsub_subscription_iam_member"" ""pull_subscription_sa_binding_subscriber"" {
  for_each = var.create_subscriptions ? { for i in var.pull_subscriptions : i.name => i if lookup(i, ""service_account"", null) != null } : {}

  project      = var.project_id
  subscription = each.value.name
  role         = ""roles/pubsub.subscriber""
  member       = ""serviceAccount:${each.value.service_account}""
  depends_on = [
    google_pubsub_subscription.pull_subscriptions,
  ]
}

resource ""google_pubsub_subscription_iam_member"" ""pull_subscription_sa_binding_viewer"" {
  for_each = var.create_subscriptions ? { for i in var.pull_subscriptions : i.name => i if lookup(i, ""service_account"", null) != null } : {}

  project      = var.project_id
  subscription = each.value.name
  role         = ""roles/pubsub.viewer""
  member       = ""serviceAccount:${each.value.service_account}""
  depends_on = [
    google_pubsub_subscription.pull_subscriptions,
  ]
}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

variable ""project_id"" {
  type        = string
  description = ""The project ID to manage the Pub/Sub resources.""
}

variable ""topic"" {
  type        = string
  description = ""The Pub/Sub topic name.""
}

variable ""create_topic"" {
  type        = bool
  description = ""Specify true if you want to create a topic.""
  default     = true
}

variable ""create_subscriptions"" {
  type        = bool
  description = ""Specify true if you want to create subscriptions.""
  default     = true
}
variable ""topic_labels"" {
  type        = map(string)
  description = ""A map of labels to assign to the Pub/Sub topic.""
  default     = {}
}

variable ""push_subscriptions"" {
  type        = list(map(string))
  description = ""The list of the push subscriptions.""
  default     = []
}

variable ""pull_subscriptions"" {
  type        = list(map(string))
  description = ""The list of the pull subscriptions.""
  default     = []
}

variable ""bigquery_subscriptions"" {
  type        = list(map(string))
  description = ""The list of the Bigquery push subscriptions.""
  default     = []
}

variable ""cloud_storage_subscriptions"" {
  type        = list(map(string))
  description = ""The list of the Cloud Storage push subscriptions.""
  default     = []
}

variable ""subscription_labels"" {
  type        = map(string)
  description = ""A map of labels to assign to every Pub/Sub subscription.""
  default     = {}
}

variable ""topic_message_retention_duration"" {
  type        = string
  description = ""The minimum duration in seconds to retain a message after it is published to the topic.""
  default     = null
}

variable ""message_storage_policy"" {
  type        = map(any)
  description = ""A map of storage policies. Default - inherit from organization's Resource Location Restriction policy.""
  default     = {}
}

variable ""topic_kms_key_name"" {
  type        = string
  description = ""The resource name of the Cloud KMS CryptoKey to be used to protect access to messages published on this topic.""
  default     = null
}

variable ""grant_token_creator"" {
  type        = bool
  description = ""Specify true if you want to add token creator role to the default Pub/Sub SA.""
  default     = true
}

variable ""schema"" {
  type = object({
    name       = string
    type       = string
    definition = string
    encoding   = string
  })
  description = ""Schema for the topic.""
  default     = null
}


/**
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

terraform {
  required_version = "">= 0.13""
  required_providers {

    google = {
      source  = ""hashicorp/google""
      version = "">= 4.78, < 6""
    }
  }

  provider_meta ""google"" {
    module_name = ""blueprints/terraform/terraform-google-pubsub/v6.0.0""
  }

}


/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

output ""topic"" {
  value       = length(google_pubsub_topic.topic) > 0 ? google_pubsub_topic.topic[0].name : """"
  description = ""The name of the Pub/Sub topic""
}

output ""topic_labels"" {
  value       = length(google_pubsub_topic.topic) > 0 ? google_pubsub_topic.topic[0].labels : {}
  description = ""Labels assigned to the Pub/Sub topic""
}

output ""id"" {
  value       = length(google_pubsub_topic.topic) > 0 ? google_pubsub_topic.topic[0].id : """"
  description = ""The ID of the Pub/Sub topic""
}

output ""uri"" {
  value       = length(google_pubsub_topic.topic) > 0 ? ""pubsub.googleapis.com/${google_pubsub_topic.topic[0].id}"" : """"
  description = ""The URI of the Pub/Sub topic""
}

output ""subscription_names"" {
  value = concat(
    values({ for k, v in google_pubsub_subscription.push_subscriptions : k => v.name }),
    values({ for k, v in google_pubsub_subscription.pull_subscriptions : k => v.name }),
    values({ for k, v in google_pubsub_subscription.bigquery_subscriptions : k => v.name }),
    values({ for k, v in google_pubsub_subscription.cloud_storage_subscriptions : k => v.name }),
  )

  description = ""The name list of Pub/Sub subscriptions""
}

output ""subscription_paths"" {
  value = concat(
    values({ for k, v in google_pubsub_subscription.push_subscriptions : k => v.id }),
    values({ for k, v in google_pubsub_subscription.pull_subscriptions : k => v.id }),
    values({ for k, v in google_pubsub_subscription.bigquery_subscriptions : k => v.name }),
    values({ for k, v in google_pubsub_subscription.cloud_storage_subscriptions : k => v.name }),
  )

  description = ""The path list of Pub/Sub subscriptions""
}



","{
  ""userQuery1"": ""The user wants to manage Google Cloud Pub/Sub resources for a specific project. They want to create a Pub/Sub topic and various types of subscriptions including push, pull, BigQuery, and Cloud Storage subscriptions. They also want to assign specific roles to the service account associated with the Pub/Sub resources."",
  ""userQuery2"": ""The user wants to control the creation of the topic and subscriptions through boolean variables. They also want to assign labels to the topic and subscriptions. They want to specify the message retention duration for the topic and the storage policy."",
  ""userQuery3"": ""The user wants to configure the subscriptions with various settings such as ack deadline seconds, message retention duration, filter, and enable message ordering. They also want to specify the expiration policy, dead letter policy, and retry policy for the subscriptions. For BigQuery and Cloud Storage subscriptions, they want to specify additional configurations.""
}"
97,lsinfo3,BDD-mininet,terraformFiles/flat_2sw_2h,"
# Configure the OpenStack Provider
# before terraform apply set TF_VAR_os_user and TF_VAR_os_password

#VARIABLES
variable os_user {
  description = ""LDAP username""
}
variable os_password {
  description = ""LDAP password (shown in plain-text!)""
}
variable os_project {
  #default = ""user-benedikt.pfaff""
  description = ""OpenStack Project""
}
variable os_domain_name {
  description = ""Domain Name""
}
variable os_auth_url {
  description = ""Auth URL""
}



#PROVIDER
provider ""openstack"" {
    user_name  = ""${var.os_user}""
    tenant_name = ""${var.os_project}""
    password  = ""${var.os_password}""
    domain_name = ""${var.os_domain_name}""
    auth_url = ""${var.os_auth_url}""
#    api_key = ""...""
#    domain_name = ""lsinfo3""
#    auth_url  = ""https://172.17.0.3:5000/v3""
    insecure = ""true""
}



#KEYPAIRS (VM, Mac, Steffen)
resource ""openstack_compute_keypair_v2"" ""bpf"" {
    name = ""bpf_tf""
    public_key = ""${file(""~/.ssh/id_rsa.pub"")}""
}
resource ""openstack_compute_keypair_v2"" ""mac"" {
    name = ""mac""
    public_key = ""ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCUuJ0t4q2vtgYhL+Pevycd6ptnFCCGgFAePIEKq6dmYG8HNrR+VHprfHfn9/8keFuVU2dn0bKR3epV5wEL77O9H5GxNXnVn8JrRNjrIOcwWsua1uMOKumjVsH8IVW0LH+5qUd6zrZ3LP0N52wO8lJpnz4Dk8eTV8lD2Dp+bEIQmvZ1wO+eiWZrhCm59OSiAm2okcpW1NzBBFIwbAK2yhE83F+vZ3ROR9cjIXtvWaYq6EPaSZK1j/7z1Pzuc56by1+uhOlsX6mmXCEcTwhtB6YsMQJ8/s1tLxpNlOLn/C93Lq3AylEifRF/NmHiR/qiQKApks+C5OBq1bDPPFFln3pja6RTGPPt6sAyYv6S4DRspejJilxgKvu3D9XB4T/8Fq6ATTM41zKhn/bwK71F19pCHqtujo71s0F8WNlWE+3/JO+oHtVflMuqhVPI4Jyw/rUH7Rj4pprI7MkOEHIu2R6Xh68ILWhF364M3uXE96cBpBJy/5KZOkCyg2ARls4cjdDrpzjbYmhggY4Qy1LJr/2Yi7bggUpJkq4PVmfGlAVQFGH7qh98Q96bK+utwbZgE8KuRHsFAYPhhWKlLzKcYBh7irtRA8kBAqZ9RV3GOqS2/pl84BaOiu8kPWIeIgLx9LBAoe8E4mLfKLgFhkUbhxGXLzzKyW9SMlcgmHudmsmXCQ== Bene@Bene-MBPs-MacBook-Pro.local""
}
resource ""openstack_compute_keypair_v2"" ""stg"" {
    name = ""stg_terraform""
    public_key = ""ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAyRKAea5teRt2KWvkIOnJZ2BPekTSKb0f5mzV87vEap6qcxtVdh1EyHLUhDzkzpgsWiLho6nXTh1iIJnr9D5GFg47Fl70KE9nnjdEuMC7y+RqTxxw1Npi9QuIpIuI/efoWgGEiMQVfooJ/gRDyDwDG/iGXMMlU8s2dDiZ5W/pMKC1ElJzHiws4sorJFcdjLyjPANoCn5YVmZzH9SQTI8Xmsar+opSf311JgDwLRtyuGR3MTFTj3g22MZNNHYj/2pqvYK5n/e9ZlCt2g/Db2jKrTwgjIjwRZfANeYjCY5IHhJsKjGWyLNc+Uuej5GAjDL3DLh0dZzQ1zyQ+ARDB1AYlw== steffen""
}


#NETWORKING
resource ""openstack_networking_network_v2"" ""network_0"" {
  name = ""access""
  admin_state_up = ""true""
}
resource ""openstack_networking_network_v2"" ""network_sw_1"" {
  name = ""network_switch_1""
  admin_state_up = ""true""
}
resource ""openstack_networking_network_v2"" ""network_1"" {
  name = ""network_one""
  admin_state_up = ""true""
}
resource ""openstack_networking_network_v2"" ""network_2"" {
  name = ""network_two""
  admin_state_up = ""true""
}


#NETWORKING  Subnets for Networks
resource ""openstack_networking_subnet_v2"" ""subnet_0"" {
  name = ""subnet_access""
  network_id = ""${openstack_networking_network_v2.network_0.id}""
  cidr = ""10.0.0.0/24""
  ip_version = 4
  dns_nameservers = [""132.187.0.13""]
}
resource ""openstack_networking_subnet_v2"" ""subnet_sw_1"" {
  name = ""subnet_switch_1""
  network_id = ""${openstack_networking_network_v2.network_sw_1.id}""
  cidr = ""10.10.10.0/24""
  ip_version = 4
  dns_nameservers = [""132.187.0.13""]
}
resource ""openstack_networking_subnet_v2"" ""subnet_1"" {
  name = ""subnet_one""
  network_id = ""${openstack_networking_network_v2.network_1.id}""
  cidr = ""192.168.10.0/24""
  ip_version = 4
  dns_nameservers = [""132.187.0.13""]
}
resource ""openstack_networking_subnet_v2"" ""subnet_2"" {
  name = ""subnet_two""
  network_id = ""${openstack_networking_network_v2.network_2.id}""
  cidr = ""192.168.20.0/24""
  ip_version = 4
  dns_nameservers = [""132.187.0.13""]
}

#NETWORKING ports
# definition of ports for switch_1
resource ""openstack_networking_port_v2"" ""sw1_port_1"" {
  name = ""port_sw1_one""
  security_group_ids = [""cb8b4b7a-714a-4182-927b-71e50c94f053""]
  network_id = ""${openstack_networking_network_v2.network_1.id}""
  fixed_ip = {
    subnet_id = ""${openstack_networking_subnet_v2.subnet_1.id}""
    ip_address = ""192.168.10.10""
  }
  admin_state_up = ""true""
}
resource ""openstack_networking_port_v2"" ""sw1_port_2"" {
  name = ""port_sw1_two""
  security_group_ids = [""cb8b4b7a-714a-4182-927b-71e50c94f053""]
  network_id = ""${openstack_networking_network_v2.network_sw_1.id}""
  fixed_ip = {
    subnet_id = ""${openstack_networking_subnet_v2.subnet_sw_1.id}""
    ip_address = ""10.10.10.10""
  }
  admin_state_up = ""true""
}

# definition of ports for switch_2
resource ""openstack_networking_port_v2"" ""sw2_port_1"" {
  name = ""port_sw2_one""
  security_group_ids = [""cb8b4b7a-714a-4182-927b-71e50c94f053""]
  network_id = ""${openstack_networking_network_v2.network_2.id}""
  fixed_ip = {
    subnet_id = ""${openstack_networking_subnet_v2.subnet_2.id}""
    ip_address = ""192.168.20.10""
  }
  admin_state_up = ""true""
}
resource ""openstack_networking_port_v2"" ""sw2_port_2"" {
  name = ""port_sw2_two""
  security_group_ids = [""cb8b4b7a-714a-4182-927b-71e50c94f053""]
  network_id = ""${openstack_networking_network_v2.network_sw_1.id}""
  fixed_ip = {
    subnet_id = ""${openstack_networking_subnet_v2.subnet_sw_1.id}""
    ip_address = ""10.10.10.11""
  }
  admin_state_up = ""true""
}



#ROUTER
#Router for external access
resource ""openstack_networking_router_v2"" ""router"" {
  region = ""RegionOne""
  name = ""Router""
  external_gateway = ""753af3b7-49ff-4522-b3a8-0cf85d66b0ff""

}
#ROUTER Interface (access -> Router)
resource ""openstack_networking_router_interface_v2"" ""router_interface"" {
  region = """"
  router_id = ""${openstack_networking_router_v2.router.id}""
  subnet_id = ""${openstack_networking_subnet_v2.subnet_0.id}""
}




#FLOATING IP
resource ""openstack_compute_floatingip_v2"" ""floatip_con"" {
  pool = ""net04_ext""
}
resource ""openstack_compute_floatingip_v2"" ""floatip_sw1"" {
  pool = ""net04_ext""
}
resource ""openstack_compute_floatingip_v2"" ""floatip_sw2"" {
  pool = ""net04_ext""
}
resource ""openstack_compute_floatingip_v2"" ""floatip_1"" {
  pool = ""net04_ext""
}
resource ""openstack_compute_floatingip_v2"" ""floatip_2"" {
  pool = ""net04_ext""
}



#RESOURCES
#VM controller (ONOS)
resource ""openstack_compute_instance_v2"" ""controller_Instance"" {
  name = ""controller""
  image_name = ""controllerSnapshot""
  flavor_name = ""i3.medium""
  security_groups = [""default""]
  region = ""RegionOne""
  key_pair = ""bpf_tf""
  floating_ip = ""${openstack_compute_floatingip_v2.floatip_con.address}""
  network { uuid = ""${openstack_networking_network_v2.network_0.id}"" }
  provisioner ""remote-exec"" {
      inline = [
         ""sudo sed -i 's/ localhost/ localhost controller/' /etc/hosts"",
         ""sudo docker start onos"",
         ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCUuJ0t4q2vtgYhL+Pevycd6ptnFCCGgFAePIEKq6dmYG8HNrR+VHprfHfn9/8keFuVU2dn0bKR3epV5wEL77O9H5GxNXnVn8JrRNjrIOcwWsua1uMOKumjVsH8IVW0LH+5qUd6zrZ3LP0N52wO8lJpnz4Dk8eTV8lD2Dp+bEIQmvZ1wO+eiWZrhCm59OSiAm2okcpW1NzBBFIwbAK2yhE83F+vZ3ROR9cjIXtvWaYq6EPaSZK1j/7z1Pzuc56by1+uhOlsX6mmXCEcTwhtB6YsMQJ8/s1tLxpNlOLn/C93Lq3AylEifRF/NmHiR/qiQKApks+C5OBq1bDPPFFln3pja6RTGPPt6sAyYv6S4DRspejJilxgKvu3D9XB4T/8Fq6ATTM41zKhn/bwK71F19pCHqtujo71s0F8WNlWE+3/JO+oHtVflMuqhVPI4Jyw/rUH7Rj4pprI7MkOEHIu2R6Xh68ILWhF364M3uXE96cBpBJy/5KZOkCyg2ARls4cjdDrpzjbYmhggY4Qy1LJr/2Yi7bggUpJkq4PVmfGlAVQFGH7qh98Q96bK+utwbZgE8KuRHsFAYPhhWKlLzKcYBh7irtRA8kBAqZ9RV3GOqS2/pl84BaOiu8kPWIeIgLx9LBAoe8E4mLfKLgFhkUbhxGXLzzKyW9SMlcgmHudmsmXCQ== Bene@Bene-MBPs-MacBook-Pro.local' >> ~/.ssh/authorized_keys"",
         ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAyRKAea5teRt2KWvkIOnJZ2BPekTSKb0f5mzV87vEap6qcxtVdh1EyHLUhDzkzpgsWiLho6nXTh1iIJnr9D5GFg47Fl70KE9nnjdEuMC7y+RqTxxw1Npi9QuIpIuI/efoWgGEiMQVfooJ/gRDyDwDG/iGXMMlU8s2dDiZ5W/pMKC1ElJzHiws4sorJFcdjLyjPANoCn5YVmZzH9SQTI8Xmsar+opSf311JgDwLRtyuGR3MTFTj3g22MZNNHYj/2pqvYK5n/e9ZlCt2g/Db2jKrTwgjIjwRZfANeYjCY5IHhJsKjGWyLNc+Uuej5GAjDL3DLh0dZzQ1zyQ+ARDB1AYlw== steffen' >> ~/.ssh/authorized_keys""
      ]
      connection {
          user = ""ubuntu""
          type = ""ssh""
          private_key = ""${file(""~/.ssh/id_rsa"")}""
          timeout = ""2m""
          agent = false
      }
  }
}


#VM switch_1
resource ""openstack_compute_instance_v2"" ""default_Instance_sw1"" {
  name = ""switch1""
  image_name = ""ubuntu14.04-x64""
  flavor_name = ""i3.xmall""
  #security_groups = [""bpf_tf_secgroup_1""]
  security_groups = [""default""]
  region = ""RegionOne""
  key_pair = ""bpf_tf""
#  key_pair = ""${openstack_compute_keypair_v2.bpf.name}""
  floating_ip = ""${openstack_compute_floatingip_v2.floatip_sw1.address}""
  #this creates a default port to network_1 (access)
  network { uuid = ""${openstack_networking_network_v2.network_0.id}"" }
  network {
      port = ""${openstack_networking_port_v2.sw1_port_1.id}""
  }
  network {
      port = ""${openstack_networking_port_v2.sw1_port_2.id}""
  }
  provisioner ""remote-exec"" {
      # edit /etc/hosts to prevent error ""unable to resolve host switch""
      inline = [
          ""sudo sed -i 's/ localhost/ localhost switch1/' /etc/hosts"",
          ""sudo ifconfig eth1 promisc ${openstack_networking_port_v2.sw1_port_1.fixed_ip.0.ip_address} netmask 255.255.0.0 up"",
          ""sudo ifconfig eth2 promisc ${openstack_networking_port_v2.sw1_port_2.fixed_ip.0.ip_address} netmask 255.255.0.0 up"",
          ""sudo apt-get update"",
          #""sudo apt-get -y upgrade"",
          ""sudo apt-get update"",
          ""sudo apt-get install -y openvswitch-switch openvswitch-common"",
          ""sudo ovs-vsctl add-br myBridge"",
          ""sudo ovs-vsctl add-port myBridge eth1"",
          ""sudo ovs-vsctl add-port myBridge eth2"",
          ""sudo ovs-vsctl set-controller myBridge tcp:${openstack_compute_instance_v2.controller_Instance.network.0.fixed_ip_v4}:6633"",
          ""sudo ovs-vsctl set-fail-mode myBridge secure"",
          ""sudo ovs-ofctl add-flow myBridge 'in_port=1,priority=10,actions=output:2'"",
          ""sudo ovs-ofctl add-flow myBridge 'in_port=2,priority=10,actions=output:1'"",
          ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCUuJ0t4q2vtgYhL+Pevycd6ptnFCCGgFAePIEKq6dmYG8HNrR+VHprfHfn9/8keFuVU2dn0bKR3epV5wEL77O9H5GxNXnVn8JrRNjrIOcwWsua1uMOKumjVsH8IVW0LH+5qUd6zrZ3LP0N52wO8lJpnz4Dk8eTV8lD2Dp+bEIQmvZ1wO+eiWZrhCm59OSiAm2okcpW1NzBBFIwbAK2yhE83F+vZ3ROR9cjIXtvWaYq6EPaSZK1j/7z1Pzuc56by1+uhOlsX6mmXCEcTwhtB6YsMQJ8/s1tLxpNlOLn/C93Lq3AylEifRF/NmHiR/qiQKApks+C5OBq1bDPPFFln3pja6RTGPPt6sAyYv6S4DRspejJilxgKvu3D9XB4T/8Fq6ATTM41zKhn/bwK71F19pCHqtujo71s0F8WNlWE+3/JO+oHtVflMuqhVPI4Jyw/rUH7Rj4pprI7MkOEHIu2R6Xh68ILWhF364M3uXE96cBpBJy/5KZOkCyg2ARls4cjdDrpzjbYmhggY4Qy1LJr/2Yi7bggUpJkq4PVmfGlAVQFGH7qh98Q96bK+utwbZgE8KuRHsFAYPhhWKlLzKcYBh7irtRA8kBAqZ9RV3GOqS2/pl84BaOiu8kPWIeIgLx9LBAoe8E4mLfKLgFhkUbhxGXLzzKyW9SMlcgmHudmsmXCQ== Bene@Bene-MBPs-MacBook-Pro.local' >> ~/.ssh/authorized_keys"",
          ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAyRKAea5teRt2KWvkIOnJZ2BPekTSKb0f5mzV87vEap6qcxtVdh1EyHLUhDzkzpgsWiLho6nXTh1iIJnr9D5GFg47Fl70KE9nnjdEuMC7y+RqTxxw1Npi9QuIpIuI/efoWgGEiMQVfooJ/gRDyDwDG/iGXMMlU8s2dDiZ5W/pMKC1ElJzHiws4sorJFcdjLyjPANoCn5YVmZzH9SQTI8Xmsar+opSf311JgDwLRtyuGR3MTFTj3g22MZNNHYj/2pqvYK5n/e9ZlCt2g/Db2jKrTwgjIjwRZfANeYjCY5IHhJsKjGWyLNc+Uuej5GAjDL3DLh0dZzQ1zyQ+ARDB1AYlw== steffen' >> ~/.ssh/authorized_keys""
      ]
      connection {
          user = ""ubuntu""
          type = ""ssh""
          private_key = ""${file(""~/.ssh/id_rsa"")}""
          timeout = ""2m""
          agent = false
      }
  }
}

#VM switch_2
resource ""openstack_compute_instance_v2"" ""default_Instance_sw2"" {
  name = ""switch2""
  image_name = ""ubuntu14.04-x64""
  flavor_name = ""i3.xmall""
  #security_groups = [""bpf_tf_secgroup_1""]
  security_groups = [""default""]
  region = ""RegionOne""
  key_pair = ""bpf_tf""
#  key_pair = ""${openstack_compute_keypair_v2.bpf.name}""
  floating_ip = ""${openstack_compute_floatingip_v2.floatip_sw2.address}""
  #this creates a default port to network_1 (access)
  network { uuid = ""${openstack_networking_network_v2.network_0.id}"" }
  network {
      port = ""${openstack_networking_port_v2.sw2_port_1.id}""
  }
  network {
      port = ""${openstack_networking_port_v2.sw2_port_2.id}""
  }
  provisioner ""remote-exec"" {
      # edit /etc/hosts to prevent error ""unable to resolve host switch""
      inline = [
          ""sudo sed -i 's/ localhost/ localhost switch2/' /etc/hosts"",
          ""sudo ifconfig eth1 promisc ${openstack_networking_port_v2.sw2_port_1.fixed_ip.0.ip_address} netmask 255.255.0.0 up"",
          ""sudo ifconfig eth2 promisc ${openstack_networking_port_v2.sw2_port_2.fixed_ip.0.ip_address} netmask 255.255.0.0 up"",
          ""sudo apt-get update"",
          #""sudo apt-get -y upgrade"",
          ""sudo apt-get update"",
          ""sudo apt-get install -y openvswitch-switch openvswitch-common"",
          ""sudo ovs-vsctl add-br myBridge"",
          ""sudo ovs-vsctl add-port myBridge eth1"",
          ""sudo ovs-vsctl add-port myBridge eth2"",
          ""sudo ovs-vsctl set-controller myBridge tcp:${openstack_compute_instance_v2.controller_Instance.network.0.fixed_ip_v4}:6633"",
          ""sudo ovs-vsctl set-fail-mode myBridge secure"",
          ""sudo ovs-ofctl add-flow myBridge 'in_port=1,priority=10,actions=output:2'"",
          ""sudo ovs-ofctl add-flow myBridge 'in_port=2,priority=10,actions=output:1'"",
          ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCUuJ0t4q2vtgYhL+Pevycd6ptnFCCGgFAePIEKq6dmYG8HNrR+VHprfHfn9/8keFuVU2dn0bKR3epV5wEL77O9H5GxNXnVn8JrRNjrIOcwWsua1uMOKumjVsH8IVW0LH+5qUd6zrZ3LP0N52wO8lJpnz4Dk8eTV8lD2Dp+bEIQmvZ1wO+eiWZrhCm59OSiAm2okcpW1NzBBFIwbAK2yhE83F+vZ3ROR9cjIXtvWaYq6EPaSZK1j/7z1Pzuc56by1+uhOlsX6mmXCEcTwhtB6YsMQJ8/s1tLxpNlOLn/C93Lq3AylEifRF/NmHiR/qiQKApks+C5OBq1bDPPFFln3pja6RTGPPt6sAyYv6S4DRspejJilxgKvu3D9XB4T/8Fq6ATTM41zKhn/bwK71F19pCHqtujo71s0F8WNlWE+3/JO+oHtVflMuqhVPI4Jyw/rUH7Rj4pprI7MkOEHIu2R6Xh68ILWhF364M3uXE96cBpBJy/5KZOkCyg2ARls4cjdDrpzjbYmhggY4Qy1LJr/2Yi7bggUpJkq4PVmfGlAVQFGH7qh98Q96bK+utwbZgE8KuRHsFAYPhhWKlLzKcYBh7irtRA8kBAqZ9RV3GOqS2/pl84BaOiu8kPWIeIgLx9LBAoe8E4mLfKLgFhkUbhxGXLzzKyW9SMlcgmHudmsmXCQ== Bene@Bene-MBPs-MacBook-Pro.local' >> ~/.ssh/authorized_keys"",
          ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAyRKAea5teRt2KWvkIOnJZ2BPekTSKb0f5mzV87vEap6qcxtVdh1EyHLUhDzkzpgsWiLho6nXTh1iIJnr9D5GFg47Fl70KE9nnjdEuMC7y+RqTxxw1Npi9QuIpIuI/efoWgGEiMQVfooJ/gRDyDwDG/iGXMMlU8s2dDiZ5W/pMKC1ElJzHiws4sorJFcdjLyjPANoCn5YVmZzH9SQTI8Xmsar+opSf311JgDwLRtyuGR3MTFTj3g22MZNNHYj/2pqvYK5n/e9ZlCt2g/Db2jKrTwgjIjwRZfANeYjCY5IHhJsKjGWyLNc+Uuej5GAjDL3DLh0dZzQ1zyQ+ARDB1AYlw== steffen' >> ~/.ssh/authorized_keys""
      ]
      connection {
          user = ""ubuntu""
          type = ""ssh""
          private_key = ""${file(""~/.ssh/id_rsa"")}""
          timeout = ""2m""
          agent = false
      }
  }
}

#VM one
resource ""openstack_compute_instance_v2"" ""default_Instance_1"" {
  name = ""one""
  image_name = ""ubuntu14.04-x64""
  flavor_name = ""i3.xmall""
  security_groups = [""default""]
  region = ""RegionOne""
  key_pair = ""bpf_tf""
#  key_pair = ""${openstack_compute_keypair_v2.bpf.name}""
  floating_ip = ""${openstack_compute_floatingip_v2.floatip_1.address}""
  network { uuid = ""${openstack_networking_network_v2.network_0.id}"" }
  network { uuid = ""${openstack_networking_network_v2.network_1.id}"" }
  provisioner ""remote-exec"" {
      inline = [
         ""sudo sed -i 's/ localhost/ localhost one/' /etc/hosts"",
         ""sudo ifconfig eth1 ${openstack_compute_instance_v2.default_Instance_1.network.1.fixed_ip_v4} netmask 255.255.0.0"",
         ""sudo apt-get update"",
         ""sudo apt-get install apache2 -y"",
         ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCUuJ0t4q2vtgYhL+Pevycd6ptnFCCGgFAePIEKq6dmYG8HNrR+VHprfHfn9/8keFuVU2dn0bKR3epV5wEL77O9H5GxNXnVn8JrRNjrIOcwWsua1uMOKumjVsH8IVW0LH+5qUd6zrZ3LP0N52wO8lJpnz4Dk8eTV8lD2Dp+bEIQmvZ1wO+eiWZrhCm59OSiAm2okcpW1NzBBFIwbAK2yhE83F+vZ3ROR9cjIXtvWaYq6EPaSZK1j/7z1Pzuc56by1+uhOlsX6mmXCEcTwhtB6YsMQJ8/s1tLxpNlOLn/C93Lq3AylEifRF/NmHiR/qiQKApks+C5OBq1bDPPFFln3pja6RTGPPt6sAyYv6S4DRspejJilxgKvu3D9XB4T/8Fq6ATTM41zKhn/bwK71F19pCHqtujo71s0F8WNlWE+3/JO+oHtVflMuqhVPI4Jyw/rUH7Rj4pprI7MkOEHIu2R6Xh68ILWhF364M3uXE96cBpBJy/5KZOkCyg2ARls4cjdDrpzjbYmhggY4Qy1LJr/2Yi7bggUpJkq4PVmfGlAVQFGH7qh98Q96bK+utwbZgE8KuRHsFAYPhhWKlLzKcYBh7irtRA8kBAqZ9RV3GOqS2/pl84BaOiu8kPWIeIgLx9LBAoe8E4mLfKLgFhkUbhxGXLzzKyW9SMlcgmHudmsmXCQ== Bene@Bene-MBPs-MacBook-Pro.local' >> ~/.ssh/authorized_keys"",
         ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAyRKAea5teRt2KWvkIOnJZ2BPekTSKb0f5mzV87vEap6qcxtVdh1EyHLUhDzkzpgsWiLho6nXTh1iIJnr9D5GFg47Fl70KE9nnjdEuMC7y+RqTxxw1Npi9QuIpIuI/efoWgGEiMQVfooJ/gRDyDwDG/iGXMMlU8s2dDiZ5W/pMKC1ElJzHiws4sorJFcdjLyjPANoCn5YVmZzH9SQTI8Xmsar+opSf311JgDwLRtyuGR3MTFTj3g22MZNNHYj/2pqvYK5n/e9ZlCt2g/Db2jKrTwgjIjwRZfANeYjCY5IHhJsKjGWyLNc+Uuej5GAjDL3DLh0dZzQ1zyQ+ARDB1AYlw== steffen' >> ~/.ssh/authorized_keys""
      ]
      connection {
          user = ""ubuntu""
          type = ""ssh""
          private_key = ""${file(""~/.ssh/id_rsa"")}""
          timeout = ""2m""
          agent = false
      }
  }
}


resource ""openstack_compute_instance_v2"" ""default_Instance_2"" {
  name = ""two""
  image_name = ""ubuntu14.04-x64""
  flavor_name = ""i3.xmall""
  #security_groups = [""bpf_tf_secgroup_1""]
  security_groups = [""default""]
  region = ""RegionOne""
  key_pair = ""bpf_tf""
#  key_pair = ""${openstack_compute_keypair_v2.bpf.name}""
  floating_ip = ""${openstack_compute_floatingip_v2.floatip_2.address}""
  network { uuid = ""${openstack_networking_network_v2.network_0.id}"" }
  network { uuid = ""${openstack_networking_network_v2.network_2.id}"" }
  provisioner ""remote-exec"" {
      inline = [
          ""sudo sed -i 's/ localhost/ localhost two/' /etc/hosts"",
          ""sudo ifconfig eth1 ${openstack_compute_instance_v2.default_Instance_2.network.1.fixed_ip_v4} netmask 255.255.0.0"",
          #""sudo apt-get update"",
          ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCUuJ0t4q2vtgYhL+Pevycd6ptnFCCGgFAePIEKq6dmYG8HNrR+VHprfHfn9/8keFuVU2dn0bKR3epV5wEL77O9H5GxNXnVn8JrRNjrIOcwWsua1uMOKumjVsH8IVW0LH+5qUd6zrZ3LP0N52wO8lJpnz4Dk8eTV8lD2Dp+bEIQmvZ1wO+eiWZrhCm59OSiAm2okcpW1NzBBFIwbAK2yhE83F+vZ3ROR9cjIXtvWaYq6EPaSZK1j/7z1Pzuc56by1+uhOlsX6mmXCEcTwhtB6YsMQJ8/s1tLxpNlOLn/C93Lq3AylEifRF/NmHiR/qiQKApks+C5OBq1bDPPFFln3pja6RTGPPt6sAyYv6S4DRspejJilxgKvu3D9XB4T/8Fq6ATTM41zKhn/bwK71F19pCHqtujo71s0F8WNlWE+3/JO+oHtVflMuqhVPI4Jyw/rUH7Rj4pprI7MkOEHIu2R6Xh68ILWhF364M3uXE96cBpBJy/5KZOkCyg2ARls4cjdDrpzjbYmhggY4Qy1LJr/2Yi7bggUpJkq4PVmfGlAVQFGH7qh98Q96bK+utwbZgE8KuRHsFAYPhhWKlLzKcYBh7irtRA8kBAqZ9RV3GOqS2/pl84BaOiu8kPWIeIgLx9LBAoe8E4mLfKLgFhkUbhxGXLzzKyW9SMlcgmHudmsmXCQ== Bene@Bene-MBPs-MacBook-Pro.local' >> ~/.ssh/authorized_keys"",
          ""sudo echo 'ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAyRKAea5teRt2KWvkIOnJZ2BPekTSKb0f5mzV87vEap6qcxtVdh1EyHLUhDzkzpgsWiLho6nXTh1iIJnr9D5GFg47Fl70KE9nnjdEuMC7y+RqTxxw1Npi9QuIpIuI/efoWgGEiMQVfooJ/gRDyDwDG/iGXMMlU8s2dDiZ5W/pMKC1ElJzHiws4sorJFcdjLyjPANoCn5YVmZzH9SQTI8Xmsar+opSf311JgDwLRtyuGR3MTFTj3g22MZNNHYj/2pqvYK5n/e9ZlCt2g/Db2jKrTwgjIjwRZfANeYjCY5IHhJsKjGWyLNc+Uuej5GAjDL3DLh0dZzQ1zyQ+ARDB1AYlw== steffen' >> ~/.ssh/authorized_keys""
      ]
      connection {
          user = ""ubuntu""
          type = ""ssh""
          private_key = ""${file(""~/.ssh/id_rsa"")}""
          timeout = ""2m""
          agent = false
      }
  }
}



#controller outputs
output ""controller_ip"" {
    value = ""${openstack_compute_instance_v2.controller_Instance.network.0.fixed_ip_v4}""
}
output ""controller_fip"" {
    value = ""${openstack_compute_floatingip_v2.floatip_con.address}""
}

#switch outputs
output ""switch1_Id"" {
    value = ""${openstack_compute_instance_v2.default_Instance_sw1.id}""
}
output ""switch1_fip"" {
    value = ""${openstack_compute_floatingip_v2.floatip_sw1.address}""
}
output ""switch1_portId_one"" {
    value = ""${openstack_compute_instance_v2.default_Instance_sw1.network.1.port}""
}
output ""switch1_portId_two"" {
    value = ""${openstack_compute_instance_v2.default_Instance_sw1.network.2.port}""
}
#switch outputs
output ""switch2_Id"" {
    value = ""${openstack_compute_instance_v2.default_Instance_sw2.id}""
}
output ""switch2_fip"" {
    value = ""${openstack_compute_floatingip_v2.floatip_sw2.address}""
}
output ""switch2_portId_one"" {
    value = ""${openstack_compute_instance_v2.default_Instance_sw2.network.1.port}""
}
output ""switch2_portId_two"" {
    value = ""${openstack_compute_instance_v2.default_Instance_sw2.network.2.port}""
}


#Port outputs
output ""sw1_port_ip_one"" {
    value = ""${openstack_networking_port_v2.sw1_port_1.fixed_ip.0.ip_address}""
}
output ""sw1_port_ip_two"" {
    value = ""${openstack_networking_port_v2.sw1_port_2.fixed_ip.0.ip_address}""
}
output ""sw2_port_ip_one"" {
    value = ""${openstack_networking_port_v2.sw2_port_1.fixed_ip.0.ip_address}""
}
output ""sw2_port_ip_two"" {
    value = ""${openstack_networking_port_v2.sw2_port_2.fixed_ip.0.ip_address}""
}


#VM client outputs
output ""one_Id"" {
    value = ""${openstack_compute_instance_v2.default_Instance_1.id}""
}
output ""one_fip"" {
    value = ""${openstack_compute_floatingip_v2.floatip_1.address}""
}
output ""one_ip"" {
   value = ""${openstack_compute_instance_v2.default_Instance_1.network.1.fixed_ip_v4}""
}
output ""one_mac"" {
   value = ""${openstack_compute_instance_v2.default_Instance_1.network.1.mac}""
}

output ""two_Id"" {
    value = ""${openstack_compute_instance_v2.default_Instance_2.id}""
}
output ""two_fip"" {
    value = ""${openstack_compute_floatingip_v2.floatip_2.address}""
}
output ""two_ip"" {
   value = ""${openstack_compute_instance_v2.default_Instance_2.network.1.fixed_ip_v4}""
}
output ""two_mac"" {
   value = ""${openstack_compute_instance_v2.default_Instance_2.network.1.mac}""
}



","An error occurred: Error code: 400 - {'error': {'message': ""This model's maximum context length is 8192 tokens. However, your messages resulted in 9153 tokens. Please reduce the length of the messages."", 'type': 'invalid_request_error', 'param': 'messages', 'code': 'context_length_exceeded'}}"
98,GoogleCloudPlatform,terraform-google-splunk-enterprise,,"# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

terraform {
  required_version = ""~> 0.12.20""
  experiments = [variable_validation]
}

provider ""google"" {
  project = var.project
  region  = var.region
  version = ""~> 2.14""
}

provider ""google-beta"" {
  project = var.project
  region  = var.region
  version = ""~> 2.14""
}

locals {
  splunk_package_name = ""splunk-8.0.5-a1a6394cc5ae-Linux-x86_64.tgz""
  splunk_package_url = ""http://download.splunk.com/products/splunk/releases/8.0.5/linux/${local.splunk_package_name}""
  splunk_cluster_master_name = ""splunk-cm""
  zone    = var.zone == """" ? data.google_compute_zones.available.names[0] : var.zone
}

data ""template_file"" ""splunk_startup_script"" {
  template = file(format(""${path.module}/startup_script.sh.tpl""))

  vars = {
    SPLUNK_PACKAGE_URL              = local.splunk_package_url
    SPLUNK_PACKAGE_NAME             = local.splunk_package_name
    SPLUNK_ADMIN_PASSWORD           = var.splunk_admin_password
    SPLUNK_CLUSTER_SECRET           = var.splunk_cluster_secret
    SPLUNK_INDEXER_DISCOVERY_SECRET = var.splunk_indexer_discovery_secret
    SPLUNK_CM_PRIVATE_IP            = google_compute_address.splunk_cluster_master_ip.address
    SPLUNK_DEPLOYER_PRIVATE_IP      = google_compute_address.splunk_deployer_ip.address
  }

  depends_on = [
    google_compute_address.splunk_cluster_master_ip,
    google_compute_address.splunk_deployer_ip,
  ]
}

data ""google_compute_zones"" ""available"" {
    region = var.region
}

output ""search_head_cluster_url"" {
  value = ""http://${google_compute_global_address.search_head_cluster_address.address}""
}

output ""search_head_deployer_url"" {
  value = ""http://${google_compute_instance.splunk_deployer.network_interface.0.access_config.0.nat_ip}:8000""
}

output ""indexer_cluster_master_url"" {
  value = ""http://${google_compute_instance.splunk_cluster_master.network_interface.0.access_config.0.nat_ip}:8000""
}

output ""indexer_cluster_hec_url"" {
  value = ""http://${google_compute_global_address.indexer_hec_input_address.address}:8080""
}

output ""indexer_cluster_hec_token"" {
  value = ""${module.shell_output_token.stdout}""
}

# Copyright 2019 Google LLC
# 
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     https://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
variable ""project"" {
  description = ""Project for Splunk deployment""
}

variable ""region"" {
  description = ""Region to deploy to""
}

variable ""zone"" {
  description = ""Zone to deploy master and deployer into""
  default = """"
}

variable ""splunk_idx_cluster_size"" {
  description = ""Number of nodes in Splunk indexer cluster""
  default     = 3
}

variable ""splunk_sh_cluster_size"" {
  description = ""Number of nodes in Splunk search head cluster""
  default     = 3
}

variable ""splunk_admin_password"" {
  description = ""Splunk admin password""

   validation {
     condition = !can(regex(""[$()']"", var.splunk_admin_password))
     error_message = ""Admin password cannot contain any of the following illegal characters: ' ( ) $.""
   }
}

variable ""splunk_cluster_secret"" {
  description = ""Splunk cluster secret""

  validation {
    condition = !can(regex(""[$()']"", var.splunk_cluster_secret))
    error_message = ""Cluster secret cannot contain any of the following illegal characters: ' ( ) $.""
  }
}

variable ""splunk_indexer_discovery_secret"" {
  description = ""Splunk indexer discovery secret""

  validation {
    condition = !can(regex(""[$()']"", var.splunk_indexer_discovery_secret))
    error_message = ""Indexer discovery secret cannot contain any of the following illegal characters: ' ( ) $.""
  }
}

variable ""splunk_network"" {
  description = ""Network to attach Splunk nodes to""
  default = ""splunk-network""
}


variable ""splunk_subnet"" {
  description = ""Subnet to attach Splunk nodes to""
  default = ""splunk-subnet""
}

variable ""splunk_subnet_cidr"" {
  description = ""Subnet CIDR to attach Splunk nodes to""
  default = ""192.168.0.0/16""
}

variable ""create_network"" {
  description = ""Create Splunk Network (true or false)""
  type = bool
  default = true
}


variable ""idx_disk_type"" {
  description = ""Disk type to use for data volume on indexers.  Can be local-ssd, pd-ssd or pd-standard""
  type = string
  default = ""pd-ssd""
}

variable ""idx_disk_size"" {
  description = ""Default disk size for persistent disk data volumes (if not using local-ssd)""
  type = number
  default = 100
}

# Only used for Local SSD's
variable ""idx_disk_count"" {
  description = ""Number of disks to attach if using local-ssd (each volume 375 GB)""
  type = number
  default = 1
}


# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

####
## VPC
####
resource ""google_compute_network"" ""vpc_network"" {
  count                   = var.create_network ? 1 : 0
  name                    = var.splunk_network
  auto_create_subnetworks = false
}

resource ""google_compute_subnetwork"" ""splunk_subnet"" {
  count         = var.create_network ? 1 : 0
  name          = var.splunk_subnet
  ip_cidr_range = var.splunk_subnet_cidr
  region        = var.region
  network       = google_compute_network.vpc_network[0].self_link
}

resource ""google_compute_address"" ""splunk_cluster_master_ip"" {
  name         = ""splunk-cm-ip""
  address_type = ""INTERNAL""
  subnetwork = var.create_network ? google_compute_subnetwork.splunk_subnet[0].self_link : var.splunk_subnet 
}

resource ""google_compute_address"" ""splunk_deployer_ip"" {
  name         = ""splunk-deployer-ip""
  address_type = ""INTERNAL""
  subnetwork   = var.create_network ? google_compute_subnetwork.splunk_subnet[0].self_link : var.splunk_subnet
}

resource ""google_compute_global_forwarding_rule"" ""search_head_cluster_rule"" {
  name       = ""splunk-shc-splunkweb-rule""
  target     = google_compute_target_http_proxy.search_head_cluster_proxy.self_link
  ip_address = google_compute_global_address.search_head_cluster_address.address
  port_range = ""80""
}

resource ""google_compute_global_address"" ""search_head_cluster_address"" {
  name = ""splunk-shc-splunkweb-address""
}

resource ""google_compute_target_http_proxy"" ""search_head_cluster_proxy"" {
  name    = ""splunk-shc-splunkweb-proxy""
  url_map = google_compute_url_map.search_head_cluster_url_map.self_link
}

resource ""google_compute_url_map"" ""search_head_cluster_url_map"" {
  name            = ""splunk-shc-splunkweb-url-map""
  default_service = google_compute_backend_service.default.self_link
}

resource ""google_compute_backend_service"" ""default"" {
  name      = ""shc-splunkweb""
  port_name = ""splunkweb""
  protocol  = ""HTTP""

  backend {
    group          = google_compute_region_instance_group_manager.search_head_cluster.instance_group
    balancing_mode = ""UTILIZATION""
  }

  health_checks = [google_compute_health_check.default.self_link]

  session_affinity        = ""GENERATED_COOKIE""
  affinity_cookie_ttl_sec = ""86400""
  enable_cdn              = true

  connection_draining_timeout_sec = ""300""
}

resource ""google_compute_global_forwarding_rule"" ""indexer_hec_input_rule"" {
  name       = ""splunk-idx-hecinput-rule""
  target     = google_compute_target_http_proxy.indexer_hec_input_proxy.self_link
  ip_address = google_compute_global_address.indexer_hec_input_address.address
  port_range = ""8080""
}

resource ""google_compute_global_address"" ""indexer_hec_input_address"" {
  name = ""splunk-idx-hecinput-address""
}

resource ""google_compute_target_http_proxy"" ""indexer_hec_input_proxy"" {
  name    = ""splunk-idx-hecinput-proxy""
  url_map = google_compute_url_map.indexer_hec_input_url_map.self_link
}

resource ""google_compute_url_map"" ""indexer_hec_input_url_map"" {
  name            = ""splunk-idx-hecinput-url-map""
  default_service = google_compute_backend_service.splunk_hec.self_link
}

resource ""google_compute_backend_service"" ""splunk_hec"" {
  name      = ""idx-splunk-hec""
  port_name = ""splunkhec""
  protocol  = ""HTTPS""
  backend {
    group          = google_compute_region_instance_group_manager.indexer_cluster.instance_group
    balancing_mode = ""UTILIZATION""
  }
  health_checks = [google_compute_health_check.splunk_hec.self_link]
  connection_draining_timeout_sec = ""300""
}

####
## Firewall Rules
####
resource ""google_compute_firewall"" ""allow_internal"" {
  name    = ""splunk-network-allow-internal""
  network = var.create_network ? google_compute_network.vpc_network[0].name : var.splunk_network

  allow {
    protocol = ""tcp""
  }
  allow {
    protocol = ""udp""
  }
  allow {
    protocol = ""icmp""
  }

  source_tags = [""splunk""]
  target_tags = [""splunk""]
}

resource ""google_compute_firewall"" ""allow_health_checks"" {
  name    = ""splunk-network-allow-health-checks""
  network = var.create_network ? google_compute_network.vpc_network[0].name : var.splunk_network

  allow {
    protocol = ""tcp""
    ports    = [""8089"", ""8088""]
  }

  source_ranges = [""35.191.0.0/16"", ""130.211.0.0/22""]
  target_tags   = [""splunk""]
}

resource ""google_compute_firewall"" ""allow_ssh"" {
  name    = ""splunk-network-allow-ssh""
  network = var.create_network ? google_compute_network.vpc_network[0].name : var.splunk_network

  allow {
    protocol = ""tcp""
    ports    = [""22""]
  }

  target_tags = [""splunk""]
}

resource ""google_compute_firewall"" ""allow_splunk_web"" {
  name    = ""splunk-network-allow-web""
  network = var.create_network ? google_compute_network.vpc_network[0].name : var.splunk_network

  allow {
    protocol = ""tcp""
    ports    = [""8000""]
  }

  target_tags = [""splunk""]
}

####
## Health Checks
####
resource ""google_compute_health_check"" ""default"" {
  name                = ""shc-mgmt-port-health-check""
  check_interval_sec  = 15
  timeout_sec         = 5
  healthy_threshold   = 2
  unhealthy_threshold = 3

  tcp_health_check {
    port = ""8089""
  }

  depends_on = [google_compute_firewall.allow_health_checks]
}

resource ""google_compute_health_check"" ""splunk_hec"" {
  name                = ""idx-hec-port-health-check""
  check_interval_sec  = 15
  timeout_sec         = 5
  healthy_threshold   = 2
  unhealthy_threshold = 3

  https_health_check {
    request_path = ""/services/collector/health""
    port         = ""8088""
  }

  depends_on = [google_compute_firewall.allow_health_checks]
}

resource ""google_compute_health_check"" ""splunk_idx"" {
  name                = ""idx-mgmt-port-health-check""
  check_interval_sec  = 30
  timeout_sec         = 10
  healthy_threshold   = 2
  unhealthy_threshold = 4 # 2 minutes

  https_health_check {
    request_path = ""/""
    port         = ""8089""
  }

  depends_on = [google_compute_firewall.allow_health_checks]
}



# Copyright 2019 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


####
## Cluster Master
####
resource ""google_compute_instance"" ""splunk_cluster_master"" {
  name         = local.splunk_cluster_master_name
  machine_type = ""n1-standard-4""
  zone = local.zone
  tags = [""splunk""]

  boot_disk {
    initialize_params {
      image = ""ubuntu-os-cloud/ubuntu-1604-lts""
      type  = ""pd-ssd""
      size  = ""50""
    }
  }

  network_interface {
    network = var.create_network ? google_compute_network.vpc_network[0].self_link : var.splunk_network
    network_ip = google_compute_address.splunk_cluster_master_ip.address
    subnetwork = var.create_network ? google_compute_subnetwork.splunk_subnet[0].self_link : var.splunk_subnet

    access_config {
      # Ephemeral IP
    }
  }

  metadata = {
    startup-script = data.template_file.splunk_startup_script.rendered
    splunk-role    = ""IDX-Master""
    enable-guest-attributes = ""TRUE""
  }

  depends_on = [
    google_compute_firewall.allow_internal,
    google_compute_firewall.allow_ssh,
    google_compute_firewall.allow_splunk_web,
  ]
}

####
## Search Head Deployer
####
resource ""google_compute_instance"" ""splunk_deployer"" {
  name         = ""splunk-deployer""
  machine_type = ""n1-standard-4""
  zone = local.zone

  tags = [""splunk""]

  boot_disk {
    initialize_params {
      image = ""ubuntu-os-cloud/ubuntu-1604-lts""
      type  = ""pd-ssd""
      size  = ""50""
    }
  }

  network_interface {
    network = var.create_network ? google_compute_network.vpc_network[0].self_link : var.splunk_network
    network_ip = google_compute_address.splunk_deployer_ip.address
    subnetwork = var.create_network ? google_compute_subnetwork.splunk_subnet[0].self_link : var.splunk_subnet
    access_config {
      # Ephemeral IP
    }
  }

  metadata = {
    startup-script = data.template_file.splunk_startup_script.rendered
    splunk-role    = ""SHC-Deployer""
    enable-guest-attributes = ""TRUE""
  }

  depends_on = [
    google_compute_firewall.allow_internal,
    google_compute_firewall.allow_ssh,
    google_compute_firewall.allow_splunk_web,
  ]
}

####
## Indexers
####
resource ""google_compute_disk"" ""indexer-data-disk"" {
  # Don't create if using local ssd
  count = var.idx_disk_type == ""local-ssd"" ? 0 : 1
  name = ""splunk-indexer-data""
  size = var.idx_disk_size
  type = var.idx_disk_type
  zone = local.zone
}

resource ""google_compute_image"" ""indexer-data-disk-image"" {
  # Don't create if using local ssd
  count = var.idx_disk_type == ""local-ssd"" ? 0 : 1
  name = ""splunk-indexer-data-image""
  source_disk = google_compute_disk.indexer-data-disk[0].self_link
  depends_on = [google_compute_disk.indexer-data-disk]
}

# Indexer Template for Persistent Disk
resource ""google_compute_instance_template"" ""splunk_idx_template-pd"" {
  count = var.idx_disk_type != ""local-ssd"" ? 1 : 0
  name_prefix  = ""splunk-idx-template-""
  machine_type = ""n1-standard-4""
  tags = [""splunk""]

  # boot disk
  disk {
    source_image = ""ubuntu-os-cloud/ubuntu-1604-lts""
    disk_type    = ""pd-ssd""
    disk_size_gb = ""50""
    auto_delete  = false
    boot         = true
  }
  # data disk
  disk {
    source_image = google_compute_image.indexer-data-disk-image[0].name
    disk_name = ""splunk-db""
    auto_delete = false
    boot = false
  }
  network_interface {
    network = var.create_network ? google_compute_network.vpc_network[0].self_link : var.splunk_network
    subnetwork = var.create_network ? google_compute_subnetwork.splunk_subnet[0].self_link : var.splunk_subnet
    access_config {
      # Ephemeral IP
    }
  }
  metadata = {
    startup-script = data.template_file.splunk_startup_script.rendered
    splunk-role    = ""IDX-Peer""
    enable-guest-attributes = ""TRUE""
  }

  lifecycle {
    create_before_destroy = true
  }
  
  depends_on = [google_compute_image.indexer-data-disk-image]
}

# Indexer Template for Local SSD's
resource ""google_compute_instance_template"" ""splunk_idx_template-localssd"" {
  count = var.idx_disk_type == ""local-ssd"" ? 1 : 0
  name_prefix  = ""splunk-idx-template-""
  machine_type = ""n1-standard-4""
  tags = [""splunk""]
  # boot disk
  disk {
    source_image = ""ubuntu-os-cloud/ubuntu-1604-lts""
    disk_type    = ""pd-ssd""
    disk_size_gb = ""50""
    auto_delete = false
    boot        = true
  }
  # Local SSD Block
  dynamic ""disk"" {
    for_each = range(var.idx_disk_count)
    content {
      disk_type = ""local-ssd""
      interface = ""SCSI""
      type = ""SCRATCH""
      disk_size_gb = 375
    }
  }
  network_interface {
    network = var.create_network ? google_compute_network.vpc_network[0].self_link : var.splunk_network
    subnetwork = var.create_network ? google_compute_subnetwork.splunk_subnet[0].self_link : var.splunk_subnet
    access_config {
      # Ephemeral IP
    }
  }
  metadata = {
    startup-script = data.template_file.splunk_startup_script.rendered
    splunk-role    = ""IDX-Peer""
    enable-guest-attributes = ""TRUE""
  }

  lifecycle {
    create_before_destroy = true
  }
}

resource ""google_compute_region_instance_group_manager"" ""indexer_cluster"" {
  provider           = google-beta
  name               = ""splunk-idx-mig""
  region             = var.region
  base_instance_name = ""splunk-idx""
  target_size        = var.splunk_idx_cluster_size

  version {
    name              = ""splunk-idx-mig-version-0""
    instance_template = var.idx_disk_type == ""local-ssd"" ? google_compute_instance_template.splunk_idx_template-localssd[0].self_link : google_compute_instance_template.splunk_idx_template-pd[0].self_link
  }

  named_port {
    name = ""splunkhec""
    port = ""8088""
  }

  named_port {
    name = ""splunktcp""
    port = ""9997""
  }

  auto_healing_policies {
    health_check      = google_compute_health_check.splunk_idx.self_link
    initial_delay_sec = 300
  }

  depends_on = [google_compute_instance.splunk_cluster_master]
}

####
## Search Heads
####
resource ""google_compute_instance_template"" ""splunk_shc_template"" {
  name_prefix  = ""splunk-shc-template-""
  machine_type = ""n1-standard-4""

  tags = [""splunk""]

  # boot disk
  disk {
    source_image = ""ubuntu-os-cloud/ubuntu-1604-lts""
    disk_type    = ""pd-ssd""
    disk_size_gb = ""50""
    boot         = ""true""
  }

  network_interface {
    network = var.create_network ? google_compute_network.vpc_network[0].self_link : var.splunk_network
    subnetwork = var.create_network ? google_compute_subnetwork.splunk_subnet[0].self_link : var.splunk_subnet
    access_config {
      # Ephemeral IP
    }
  }

  metadata = {
    startup-script = data.template_file.splunk_startup_script.rendered
    splunk-role    = ""SHC-Member""
    enable-guest-attributes = ""TRUE""
  }
}

resource ""google_compute_region_instance_group_manager"" ""search_head_cluster"" {
  provider           = google-beta
  name               = ""splunk-shc-mig""
  region             = var.region
  base_instance_name = ""splunk-sh""

  target_size = var.splunk_sh_cluster_size

  version {
    name              = ""splunk-shc-mig-version-0""
    instance_template = google_compute_instance_template.splunk_shc_template.self_link
  }

  named_port {
    name = ""splunkweb""
    port = ""8000""
  }

  depends_on = [
    google_compute_instance.splunk_cluster_master,
    google_compute_instance.splunk_deployer,
    google_compute_instance_template.splunk_shc_template
  ]
}





####
## Local Scripts
####

# Continuously check for HEC token for output
module ""shell_output_token"" {
  source = ""matti/resource/shell""
  version = ""0.12.0""
  command =  <<CMD
sleep 10
until \
token=`gcloud compute instances get-guest-attributes ${local.splunk_cluster_master_name} --zone ${local.zone} --query-path=splunk/token --format=""value(VALUE)"" --quiet 2> /dev/null`
do sleep 10
done
echo $token
CMD
}

# Wait until successful install then remove startup-script from instance metadata
# Note, doesn't remove from instance template
module ""shell_output_install_progress"" {
  source = ""matti/resource/shell""
  version = ""0.12.0""
  command = <<CMD
sleep 30
until gcloud compute instances list --format=""value(name,zone)"" --filter=""metadata['items']['key']=splunk-role"" | sort |  \
awk '
BEGIN {r=0;h="""";t="""";c=0}
{
cmd = ""gcloud compute instances get-guest-attributes ""$1"" --zone ""$2"" --query-path=splunk/install --format=\""value(VALUE)\"" 2> /dev/null""
rv=""""
rs=""""
cmd | getline rv
cmd = ""gcloud compute instances get-guest-attributes ""$1"" --zone ""$2"" --query-path=splunk/install-status --format=\""value(VALUE)\"" 2> /dev/null""
cmd | getline rs
if (rv == """") { rv = ""booting"" }
if (rv != ""complete"") { r = 1; h = h"" ""$1 }
t=sprintf(""%s\n %-25s %-14s %s"",t,$1,rv,rs)
c=c+1
}
END {
print ""Install progress:""t
if (c == 0) { r=1; }
if (h != """" && c!=0) {
  print ""Still installing on hosts: ""h
}
exit r
}'
do sleep 15
done
echo ""All hosts completed install, now removing metadata from hosts""
gcloud compute instances list --format=""value(name,zone)"" --filter=""metadata['items']['key']=splunk-role"" | \
awk '{system(""gcloud compute instances remove-metadata ""$1"" --zone ""$2"" --keys startup-script --quiet"")}'
CMD
}

","{
  ""userQuery1"": ""The user wants to deploy a Splunk environment on Google Cloud Platform. The environment includes a Splunk cluster master, a search head deployer, indexer cluster, and search head cluster. The user wants to specify the project, region, and zone for the deployment."",
  ""userQuery2"": ""The user wants to specify the size of the Splunk indexer cluster and search head cluster. They also want to set the admin password, cluster secret, and indexer discovery secret for the Splunk deployment, with certain restrictions on the characters that can be used."",
  ""userQuery3"": ""The user wants to create a new network for the Splunk deployment, with the ability to specify the network name, subnet, and subnet CIDR. They also want to specify the disk type and size for the indexers, with the option to use local SSDs."",
  ""userQuery4"": ""The user wants to create firewall rules to allow internal traffic, health"
99,terraform-google-modules,docs-examples,network_services_edge_cache_origin_advanced,"resource ""google_network_services_edge_cache_origin"" ""fallback"" {
  name                 = ""my-fallback-${local.name_suffix}""
  origin_address       = ""fallback.example.com""
  description          = ""The default bucket for media edge test""
  max_attempts         = 3
  protocol = ""HTTP""
  port = 80

  retry_conditions = [
    ""CONNECT_FAILURE"",
    ""NOT_FOUND"",
    ""HTTP_5XX"",
    ""FORBIDDEN"",
  ]
  timeout {
    connect_timeout = ""10s""
    max_attempts_timeout = ""20s""
    response_timeout = ""60s""
    read_timeout = ""5s""
  }
  origin_override_action {
    url_rewrite {
      host_rewrite = ""example.com""
    }
    header_action {
      request_headers_to_add {
        header_name = ""x-header""
	header_value = ""value""
	replace = true
      }
    }
  }
  origin_redirect {
    redirect_conditions = [
      ""MOVED_PERMANENTLY"",
      ""FOUND"",
      ""SEE_OTHER"",
      ""TEMPORARY_REDIRECT"",
      ""PERMANENT_REDIRECT"",
    ]
  }
}

resource ""google_network_services_edge_cache_origin"" ""default"" {
  name                 = ""my-origin-${local.name_suffix}""
  origin_address       = ""gs://media-edge-default""
  failover_origin      = google_network_services_edge_cache_origin.fallback.id
  description          = ""The default bucket for media edge test""
  max_attempts         = 2
  labels = {
    a = ""b""
  }

  timeout {
    connect_timeout = ""10s""
  }
}


# This file has some scaffolding to make sure that names are unique and that
# a region and zone are selected when you try to create your Terraform resources.

locals {
  name_suffix = ""${random_pet.suffix.id}""
}

resource ""random_pet"" ""suffix"" {
  length = 2
}

provider ""google"" {
  region = ""us-central1""
  zone   = ""us-central1-c""
}


","{
  ""userQuery1"": ""The user wants to create a fallback edge cache origin named 'my-fallback' with a unique suffix. This origin should use the HTTP protocol on port 80 and should be able to retry up to 3 times under certain conditions. The user also wants to specify timeouts for different stages of the connection and to override the origin with a URL rewrite and a header action. Additionally, the user wants to set up redirection under certain conditions."",
  ""userQuery2"": ""The user wants to create a default edge cache origin named 'my-origin' with a unique suffix. This origin should use a Google Cloud Storage bucket as its address and should failover to the previously created fallback origin. The user also wants to specify a maximum of 2 retry attempts and to label the origin. The user also wants to specify a connect timeout for this origin."",
  ""userQuery3"": ""The user wants to use the Google Cloud provider and wants to specify 'us-central"